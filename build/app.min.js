var CLM =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/lib/glsl/CopyShader.js":
/*!***********************************!*\
  !*** ./js/lib/glsl/CopyShader.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * Full-screen textured quad shader\r\n */\n\nTHREE.CopyShader = {\n\n\t\tuniforms: {\n\n\t\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\t\"opacity\": { value: 1.0 }\n\n\t\t},\n\n\t\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\t\tfragmentShader: [\"uniform float opacity;\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 texel = texture2D( tDiffuse, vUv );\", \"gl_FragColor = opacity * texel;\", \"}\"].join(\"\\n\")\n\n};\n\n//# sourceURL=webpack://CLM/./js/lib/glsl/CopyShader.js?");

/***/ }),

/***/ "./js/lib/glsl/EffectComposer.js":
/*!***************************************!*\
  !*** ./js/lib/glsl/EffectComposer.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\nTHREE.EffectComposer = function (renderer, renderTarget) {\n\n\tthis.renderer = renderer;\n\n\tif (renderTarget === undefined) {\n\n\t\tvar parameters = {\n\t\t\tminFilter: THREE.LinearFilter,\n\t\t\tmagFilter: THREE.LinearFilter,\n\t\t\tformat: THREE.RGBAFormat,\n\t\t\tstencilBuffer: false\n\t\t};\n\n\t\tvar size = renderer.getDrawingBufferSize();\n\t\trenderTarget = new THREE.WebGLRenderTarget(size.width, size.height, parameters);\n\t\trenderTarget.texture.name = 'EffectComposer.rt1';\n\t}\n\n\tthis.renderTarget1 = renderTarget;\n\tthis.renderTarget2 = renderTarget.clone();\n\tthis.renderTarget2.texture.name = 'EffectComposer.rt2';\n\n\tthis.writeBuffer = this.renderTarget1;\n\tthis.readBuffer = this.renderTarget2;\n\n\tthis.passes = [];\n\n\t// dependencies\n\n\tif (THREE.CopyShader === undefined) {\n\n\t\tconsole.error('THREE.EffectComposer relies on THREE.CopyShader');\n\t}\n\n\tif (THREE.ShaderPass === undefined) {\n\n\t\tconsole.error('THREE.EffectComposer relies on THREE.ShaderPass');\n\t}\n\n\tthis.copyPass = new THREE.ShaderPass(THREE.CopyShader);\n};\n\nObject.assign(THREE.EffectComposer.prototype, {\n\n\tswapBuffers: function () {\n\n\t\tvar tmp = this.readBuffer;\n\t\tthis.readBuffer = this.writeBuffer;\n\t\tthis.writeBuffer = tmp;\n\t},\n\n\taddPass: function (pass) {\n\n\t\tthis.passes.push(pass);\n\n\t\tvar size = this.renderer.getDrawingBufferSize();\n\t\tpass.setSize(size.width, size.height);\n\t},\n\n\tinsertPass: function (pass, index) {\n\n\t\tthis.passes.splice(index, 0, pass);\n\t},\n\n\trender: function (delta) {\n\n\t\tvar maskActive = false;\n\n\t\tvar pass,\n\t\t    i,\n\t\t    il = this.passes.length;\n\n\t\tfor (i = 0; i < il; i++) {\n\n\t\t\tpass = this.passes[i];\n\n\t\t\tif (pass.enabled === false) continue;\n\n\t\t\tpass.render(this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive);\n\n\t\t\tif (pass.needsSwap) {\n\n\t\t\t\tif (maskActive) {\n\n\t\t\t\t\tvar context = this.renderer.context;\n\n\t\t\t\t\tcontext.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);\n\n\t\t\t\t\tthis.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, delta);\n\n\t\t\t\t\tcontext.stencilFunc(context.EQUAL, 1, 0xffffffff);\n\t\t\t\t}\n\n\t\t\t\tthis.swapBuffers();\n\t\t\t}\n\n\t\t\tif (THREE.MaskPass !== undefined) {\n\n\t\t\t\tif (pass instanceof THREE.MaskPass) {\n\n\t\t\t\t\tmaskActive = true;\n\t\t\t\t} else if (pass instanceof THREE.ClearMaskPass) {\n\n\t\t\t\t\tmaskActive = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\treset: function (renderTarget) {\n\n\t\tif (renderTarget === undefined) {\n\n\t\t\tvar size = this.renderer.getDrawingBufferSize();\n\n\t\t\trenderTarget = this.renderTarget1.clone();\n\t\t\trenderTarget.setSize(size.width, size.height);\n\t\t}\n\n\t\tthis.renderTarget1.dispose();\n\t\tthis.renderTarget2.dispose();\n\t\tthis.renderTarget1 = renderTarget;\n\t\tthis.renderTarget2 = renderTarget.clone();\n\n\t\tthis.writeBuffer = this.renderTarget1;\n\t\tthis.readBuffer = this.renderTarget2;\n\t},\n\n\tsetSize: function (width, height) {\n\n\t\tthis.renderTarget1.setSize(width, height);\n\t\tthis.renderTarget2.setSize(width, height);\n\n\t\tfor (var i = 0; i < this.passes.length; i++) {\n\n\t\t\tthis.passes[i].setSize(width, height);\n\t\t}\n\t}\n\n});\n\nTHREE.Pass = function () {\n\n\t// if set to true, the pass is processed by the composer\n\tthis.enabled = true;\n\n\t// if set to true, the pass indicates to swap read and write buffer after rendering\n\tthis.needsSwap = true;\n\n\t// if set to true, the pass clears its buffer before rendering\n\tthis.clear = false;\n\n\t// if set to true, the result of the pass is rendered to screen\n\tthis.renderToScreen = false;\n};\n\nObject.assign(THREE.Pass.prototype, {\n\n\tsetSize: function (width, height) {},\n\n\trender: function (renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tconsole.error('THREE.Pass: .render() must be implemented in derived pass.');\n\t}\n\n});\n\n//# sourceURL=webpack://CLM/./js/lib/glsl/EffectComposer.js?");

/***/ }),

/***/ "./js/lib/glsl/FXAA.js":
/*!*****************************!*\
  !*** ./js/lib/glsl/FXAA.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author davidedc / http://www.sketchpatch.net/\r\n *\r\n * NVIDIA FXAA by Timothy Lottes\r\n * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html\r\n * - WebGL port by @supereggbert\r\n * http://www.glge.org/demos/fxaa/\r\n */\n\nTHREE.FXAAShader = {\n\n  uniforms: {\n\n    \"tDiffuse\": { value: null },\n    \"resolution\": { value: new THREE.Vector2(1 / 1024, 1 / 512) }\n\n  },\n\n  vertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n  fragmentShader: [\"precision highp float;\", \"\", \"uniform sampler2D tDiffuse;\", \"\", \"uniform vec2 resolution;\", \"\", \"varying vec2 vUv;\", \"\", \"// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\", \"\", \"//----------------------------------------------------------------------------------\", \"// File:        es3-kepler\\FXAA\\assets\\shaders/FXAA_DefaultES.frag\", \"// SDK Version: v3.00\", \"// Email:       gameworks@nvidia.com\", \"// Site:        http://developer.nvidia.com/\", \"//\", \"// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\", \"//\", \"// Redistribution and use in source and binary forms, with or without\", \"// modification, are permitted provided that the following conditions\", \"// are met:\", \"//  * Redistributions of source code must retain the above copyright\", \"//    notice, this list of conditions and the following disclaimer.\", \"//  * Redistributions in binary form must reproduce the above copyright\", \"//    notice, this list of conditions and the following disclaimer in the\", \"//    documentation and/or other materials provided with the distribution.\", \"//  * Neither the name of NVIDIA CORPORATION nor the names of its\", \"//    contributors may be used to endorse or promote products derived\", \"//    from this software without specific prior written permission.\", \"//\", \"// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\", \"// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\", \"// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\", \"// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\", \"// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\", \"// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\", \"// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\", \"// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\", \"// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\", \"// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\", \"// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\", \"//\", \"//----------------------------------------------------------------------------------\", \"\", \"#define FXAA_PC 1\", \"#define FXAA_GLSL_100 1\", \"#define FXAA_QUALITY_PRESET 12\", \"\", \"#define FXAA_GREEN_AS_LUMA 1\", \"\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_PC_CONSOLE\", \"    //\", \"    // The console algorithm for PC is included\", \"    // for developers targeting really low spec machines.\", \"    // Likely better to just run FXAA_PC, and use a really low preset.\", \"    //\", \"    #define FXAA_PC_CONSOLE 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_GLSL_120\", \"    #define FXAA_GLSL_120 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_GLSL_130\", \"    #define FXAA_GLSL_130 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_HLSL_3\", \"    #define FXAA_HLSL_3 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_HLSL_4\", \"    #define FXAA_HLSL_4 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_HLSL_5\", \"    #define FXAA_HLSL_5 0\", \"#endif\", \"/*==========================================================================*/\", \"#ifndef FXAA_GREEN_AS_LUMA\", \"    //\", \"    // For those using non-linear color,\", \"    // and either not able to get luma in alpha, or not wanting to,\", \"    // this enables FXAA to run using green as a proxy for luma.\", \"    // So with this enabled, no need to pack luma in alpha.\", \"    //\", \"    // This will turn off AA on anything which lacks some amount of green.\", \"    // Pure red and blue or combination of only R and B, will get no AA.\", \"    //\", \"    // Might want to lower the settings for both,\", \"    //    fxaaConsoleEdgeThresholdMin\", \"    //    fxaaQualityEdgeThresholdMin\", \"    // In order to insure AA does not get turned off on colors\", \"    // which contain a minor amount of green.\", \"    //\", \"    // 1 = On.\", \"    // 0 = Off.\", \"    //\", \"    #define FXAA_GREEN_AS_LUMA 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_EARLY_EXIT\", \"    //\", \"    // Controls algorithm's early exit path.\", \"    // On PS3 turning this ON adds 2 cycles to the shader.\", \"    // On 360 turning this OFF adds 10ths of a millisecond to the shader.\", \"    // Turning this off on console will result in a more blurry image.\", \"    // So this defaults to on.\", \"    //\", \"    // 1 = On.\", \"    // 0 = Off.\", \"    //\", \"    #define FXAA_EARLY_EXIT 1\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_DISCARD\", \"    //\", \"    // Only valid for PC OpenGL currently.\", \"    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\", \"    //\", \"    // 1 = Use discard on pixels which don't need AA.\", \"    //     For APIs which enable concurrent TEX+ROP from same surface.\", \"    // 0 = Return unchanged color on pixels which don't need AA.\", \"    //\", \"    #define FXAA_DISCARD 0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_FAST_PIXEL_OFFSET\", \"    //\", \"    // Used for GLSL 120 only.\", \"    //\", \"    // 1 = GL API supports fast pixel offsets\", \"    // 0 = do not use fast pixel offsets\", \"    //\", \"    #ifdef GL_EXT_gpu_shader4\", \"        #define FXAA_FAST_PIXEL_OFFSET 1\", \"    #endif\", \"    #ifdef GL_NV_gpu_shader5\", \"        #define FXAA_FAST_PIXEL_OFFSET 1\", \"    #endif\", \"    #ifdef GL_ARB_gpu_shader5\", \"        #define FXAA_FAST_PIXEL_OFFSET 1\", \"    #endif\", \"    #ifndef FXAA_FAST_PIXEL_OFFSET\", \"        #define FXAA_FAST_PIXEL_OFFSET 0\", \"    #endif\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#ifndef FXAA_GATHER4_ALPHA\", \"    //\", \"    // 1 = API supports gather4 on alpha channel.\", \"    // 0 = API does not support gather4 on alpha channel.\", \"    //\", \"    #if (FXAA_HLSL_5 == 1)\", \"        #define FXAA_GATHER4_ALPHA 1\", \"    #endif\", \"    #ifdef GL_ARB_gpu_shader5\", \"        #define FXAA_GATHER4_ALPHA 1\", \"    #endif\", \"    #ifdef GL_NV_gpu_shader5\", \"        #define FXAA_GATHER4_ALPHA 1\", \"    #endif\", \"    #ifndef FXAA_GATHER4_ALPHA\", \"        #define FXAA_GATHER4_ALPHA 0\", \"    #endif\", \"#endif\", \"\", \"\", \"/*============================================================================\", \"                        FXAA QUALITY - TUNING KNOBS\", \"------------------------------------------------------------------------------\", \"NOTE the other tuning knobs are now in the shader function inputs!\", \"============================================================================*/\", \"#ifndef FXAA_QUALITY_PRESET\", \"    //\", \"    // Choose the quality preset.\", \"    // This needs to be compiled into the shader as it effects code.\", \"    // Best option to include multiple presets is to\", \"    // in each shader define the preset, then include this file.\", \"    //\", \"    // OPTIONS\", \"    // -----------------------------------------------------------------------\", \"    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\", \"    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\", \"    // 39       - no dither, very expensive\", \"    //\", \"    // NOTES\", \"    // -----------------------------------------------------------------------\", \"    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\", \"    // 13 = about same speed as FXAA 3.9 and better than 12\", \"    // 23 = closest to FXAA 3.9 visually and performance wise\", \"    //  _ = the lowest digit is directly related to performance\", \"    // _  = the highest digit is directly related to style\", \"    //\", \"    #define FXAA_QUALITY_PRESET 12\", \"#endif\", \"\", \"\", \"/*============================================================================\", \"\", \"                           FXAA QUALITY - PRESETS\", \"\", \"============================================================================*/\", \"\", \"/*============================================================================\", \"                     FXAA QUALITY - MEDIUM DITHER PRESETS\", \"============================================================================*/\", \"#if (FXAA_QUALITY_PRESET == 10)\", \"    #define FXAA_QUALITY_PS 3\", \"    #define FXAA_QUALITY_P0 1.5\", \"    #define FXAA_QUALITY_P1 3.0\", \"    #define FXAA_QUALITY_P2 12.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 11)\", \"    #define FXAA_QUALITY_PS 4\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 3.0\", \"    #define FXAA_QUALITY_P3 12.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 12)\", \"    #define FXAA_QUALITY_PS 5\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 4.0\", \"    #define FXAA_QUALITY_P4 12.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 13)\", \"    #define FXAA_QUALITY_PS 6\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 4.0\", \"    #define FXAA_QUALITY_P5 12.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 14)\", \"    #define FXAA_QUALITY_PS 7\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 4.0\", \"    #define FXAA_QUALITY_P6 12.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 15)\", \"    #define FXAA_QUALITY_PS 8\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 2.0\", \"    #define FXAA_QUALITY_P6 4.0\", \"    #define FXAA_QUALITY_P7 12.0\", \"#endif\", \"\", \"/*============================================================================\", \"                     FXAA QUALITY - LOW DITHER PRESETS\", \"============================================================================*/\", \"#if (FXAA_QUALITY_PRESET == 20)\", \"    #define FXAA_QUALITY_PS 3\", \"    #define FXAA_QUALITY_P0 1.5\", \"    #define FXAA_QUALITY_P1 2.0\", \"    #define FXAA_QUALITY_P2 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 21)\", \"    #define FXAA_QUALITY_PS 4\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 22)\", \"    #define FXAA_QUALITY_PS 5\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 23)\", \"    #define FXAA_QUALITY_PS 6\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 24)\", \"    #define FXAA_QUALITY_PS 7\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 3.0\", \"    #define FXAA_QUALITY_P6 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 25)\", \"    #define FXAA_QUALITY_PS 8\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 2.0\", \"    #define FXAA_QUALITY_P6 4.0\", \"    #define FXAA_QUALITY_P7 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 26)\", \"    #define FXAA_QUALITY_PS 9\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 2.0\", \"    #define FXAA_QUALITY_P6 2.0\", \"    #define FXAA_QUALITY_P7 4.0\", \"    #define FXAA_QUALITY_P8 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 27)\", \"    #define FXAA_QUALITY_PS 10\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 2.0\", \"    #define FXAA_QUALITY_P6 2.0\", \"    #define FXAA_QUALITY_P7 2.0\", \"    #define FXAA_QUALITY_P8 4.0\", \"    #define FXAA_QUALITY_P9 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 28)\", \"    #define FXAA_QUALITY_PS 11\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 2.0\", \"    #define FXAA_QUALITY_P6 2.0\", \"    #define FXAA_QUALITY_P7 2.0\", \"    #define FXAA_QUALITY_P8 2.0\", \"    #define FXAA_QUALITY_P9 4.0\", \"    #define FXAA_QUALITY_P10 8.0\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_QUALITY_PRESET == 29)\", \"    #define FXAA_QUALITY_PS 12\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.5\", \"    #define FXAA_QUALITY_P2 2.0\", \"    #define FXAA_QUALITY_P3 2.0\", \"    #define FXAA_QUALITY_P4 2.0\", \"    #define FXAA_QUALITY_P5 2.0\", \"    #define FXAA_QUALITY_P6 2.0\", \"    #define FXAA_QUALITY_P7 2.0\", \"    #define FXAA_QUALITY_P8 2.0\", \"    #define FXAA_QUALITY_P9 2.0\", \"    #define FXAA_QUALITY_P10 4.0\", \"    #define FXAA_QUALITY_P11 8.0\", \"#endif\", \"\", \"/*============================================================================\", \"                     FXAA QUALITY - EXTREME QUALITY\", \"============================================================================*/\", \"#if (FXAA_QUALITY_PRESET == 39)\", \"    #define FXAA_QUALITY_PS 12\", \"    #define FXAA_QUALITY_P0 1.0\", \"    #define FXAA_QUALITY_P1 1.0\", \"    #define FXAA_QUALITY_P2 1.0\", \"    #define FXAA_QUALITY_P3 1.0\", \"    #define FXAA_QUALITY_P4 1.0\", \"    #define FXAA_QUALITY_P5 1.5\", \"    #define FXAA_QUALITY_P6 2.0\", \"    #define FXAA_QUALITY_P7 2.0\", \"    #define FXAA_QUALITY_P8 2.0\", \"    #define FXAA_QUALITY_P9 2.0\", \"    #define FXAA_QUALITY_P10 4.0\", \"    #define FXAA_QUALITY_P11 8.0\", \"#endif\", \"\", \"\", \"\", \"/*============================================================================\", \"\", \"                                API PORTING\", \"\", \"============================================================================*/\", \"#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\", \"    #define FxaaBool bool\", \"    #define FxaaDiscard discard\", \"    #define FxaaFloat float\", \"    #define FxaaFloat2 vec2\", \"    #define FxaaFloat3 vec3\", \"    #define FxaaFloat4 vec4\", \"    #define FxaaHalf float\", \"    #define FxaaHalf2 vec2\", \"    #define FxaaHalf3 vec3\", \"    #define FxaaHalf4 vec4\", \"    #define FxaaInt2 ivec2\", \"    #define FxaaSat(x) clamp(x, 0.0, 1.0)\", \"    #define FxaaTex sampler2D\", \"#else\", \"    #define FxaaBool bool\", \"    #define FxaaDiscard clip(-1)\", \"    #define FxaaFloat float\", \"    #define FxaaFloat2 float2\", \"    #define FxaaFloat3 float3\", \"    #define FxaaFloat4 float4\", \"    #define FxaaHalf half\", \"    #define FxaaHalf2 half2\", \"    #define FxaaHalf3 half3\", \"    #define FxaaHalf4 half4\", \"    #define FxaaSat(x) saturate(x)\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_GLSL_100 == 1)\", \"  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)\", \"  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_GLSL_120 == 1)\", \"    // Requires,\", \"    //  #version 120\", \"    // And at least,\", \"    //  #extension GL_EXT_gpu_shader4 : enable\", \"    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\", \"    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\", \"    #if (FXAA_FAST_PIXEL_OFFSET == 1)\", \"        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\", \"    #else\", \"        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\", \"    #endif\", \"    #if (FXAA_GATHER4_ALPHA == 1)\", \"        // use #extension GL_ARB_gpu_shader5 : enable\", \"        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\", \"        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\", \"        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\", \"        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\", \"    #endif\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_GLSL_130 == 1)\", \"    // Requires \\\"#version 130\\\" or better\", \"    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\", \"    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\", \"    #if (FXAA_GATHER4_ALPHA == 1)\", \"        // use #extension GL_ARB_gpu_shader5 : enable\", \"        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\", \"        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\", \"        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\", \"        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\", \"    #endif\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_HLSL_3 == 1)\", \"    #define FxaaInt2 float2\", \"    #define FxaaTex sampler2D\", \"    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\", \"    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_HLSL_4 == 1)\", \"    #define FxaaInt2 int2\", \"    struct FxaaTex { SamplerState smpl; Texture2D tex; };\", \"    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\", \"    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\", \"#endif\", \"/*--------------------------------------------------------------------------*/\", \"#if (FXAA_HLSL_5 == 1)\", \"    #define FxaaInt2 int2\", \"    struct FxaaTex { SamplerState smpl; Texture2D tex; };\", \"    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\", \"    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\", \"    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\", \"    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\", \"    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\", \"    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\", \"#endif\", \"\", \"\", \"/*============================================================================\", \"                   GREEN AS LUMA OPTION SUPPORT FUNCTION\", \"============================================================================*/\", \"#if (FXAA_GREEN_AS_LUMA == 0)\", \"    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\", \"#else\", \"    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\", \"#endif\", \"\", \"\", \"\", \"\", \"/*============================================================================\", \"\", \"                             FXAA3 QUALITY - PC\", \"\", \"============================================================================*/\", \"#if (FXAA_PC == 1)\", \"/*--------------------------------------------------------------------------*/\", \"FxaaFloat4 FxaaPixelShader(\", \"    //\", \"    // Use noperspective interpolation here (turn off perspective interpolation).\", \"    // {xy} = center of pixel\", \"    FxaaFloat2 pos,\", \"    //\", \"    // Used only for FXAA Console, and not used on the 360 version.\", \"    // Use noperspective interpolation here (turn off perspective interpolation).\", \"    // {xy_} = upper left of pixel\", \"    // {_zw} = lower right of pixel\", \"    FxaaFloat4 fxaaConsolePosPos,\", \"    //\", \"    // Input color texture.\", \"    // {rgb_} = color in linear or perceptual color space\", \"    // if (FXAA_GREEN_AS_LUMA == 0)\", \"    //     {__a} = luma in perceptual color space (not linear)\", \"    FxaaTex tex,\", \"    //\", \"    // Only used on the optimized 360 version of FXAA Console.\", \"    // For everything but 360, just use the same input here as for \\\"tex\\\".\", \"    // For 360, same texture, just alias with a 2nd sampler.\", \"    // This sampler needs to have an exponent bias of -1.\", \"    FxaaTex fxaaConsole360TexExpBiasNegOne,\", \"    //\", \"    // Only used on the optimized 360 version of FXAA Console.\", \"    // For everything but 360, just use the same input here as for \\\"tex\\\".\", \"    // For 360, same texture, just alias with a 3nd sampler.\", \"    // This sampler needs to have an exponent bias of -2.\", \"    FxaaTex fxaaConsole360TexExpBiasNegTwo,\", \"    //\", \"    // Only used on FXAA Quality.\", \"    // This must be from a constant/uniform.\", \"    // {x_} = 1.0/screenWidthInPixels\", \"    // {_y} = 1.0/screenHeightInPixels\", \"    FxaaFloat2 fxaaQualityRcpFrame,\", \"    //\", \"    // Only used on FXAA Console.\", \"    // This must be from a constant/uniform.\", \"    // This effects sub-pixel AA quality and inversely sharpness.\", \"    //   Where N ranges between,\", \"    //     N = 0.50 (default)\", \"    //     N = 0.33 (sharper)\", \"    // {x__} = -N/screenWidthInPixels\", \"    // {_y_} = -N/screenHeightInPixels\", \"    // {_z_} =  N/screenWidthInPixels\", \"    // {__w} =  N/screenHeightInPixels\", \"    FxaaFloat4 fxaaConsoleRcpFrameOpt,\", \"    //\", \"    // Only used on FXAA Console.\", \"    // Not used on 360, but used on PS3 and PC.\", \"    // This must be from a constant/uniform.\", \"    // {x__} = -2.0/screenWidthInPixels\", \"    // {_y_} = -2.0/screenHeightInPixels\", \"    // {_z_} =  2.0/screenWidthInPixels\", \"    // {__w} =  2.0/screenHeightInPixels\", \"    FxaaFloat4 fxaaConsoleRcpFrameOpt2,\", \"    //\", \"    // Only used on FXAA Console.\", \"    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\", \"    // This must be from a constant/uniform.\", \"    // {x__} =  8.0/screenWidthInPixels\", \"    // {_y_} =  8.0/screenHeightInPixels\", \"    // {_z_} = -4.0/screenWidthInPixels\", \"    // {__w} = -4.0/screenHeightInPixels\", \"    FxaaFloat4 fxaaConsole360RcpFrameOpt2,\", \"    //\", \"    // Only used on FXAA Quality.\", \"    // This used to be the FXAA_QUALITY_SUBPIX define.\", \"    // It is here now to allow easier tuning.\", \"    // Choose the amount of sub-pixel aliasing removal.\", \"    // This can effect sharpness.\", \"    //   1.00 - upper limit (softer)\", \"    //   0.75 - default amount of filtering\", \"    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\", \"    //   0.25 - almost off\", \"    //   0.00 - completely off\", \"    FxaaFloat fxaaQualitySubpix,\", \"    //\", \"    // Only used on FXAA Quality.\", \"    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\", \"    // It is here now to allow easier tuning.\", \"    // The minimum amount of local contrast required to apply algorithm.\", \"    //   0.333 - too little (faster)\", \"    //   0.250 - low quality\", \"    //   0.166 - default\", \"    //   0.125 - high quality\", \"    //   0.063 - overkill (slower)\", \"    FxaaFloat fxaaQualityEdgeThreshold,\", \"    //\", \"    // Only used on FXAA Quality.\", \"    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\", \"    // It is here now to allow easier tuning.\", \"    // Trims the algorithm from processing darks.\", \"    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\", \"    //   0.0625 - high quality (faster)\", \"    //   0.0312 - visible limit (slower)\", \"    // Special notes when using FXAA_GREEN_AS_LUMA,\", \"    //   Likely want to set this to zero.\", \"    //   As colors that are mostly not-green\", \"    //   will appear very dark in the green channel!\", \"    //   Tune by looking at mostly non-green content,\", \"    //   then start at zero and increase until aliasing is a problem.\", \"    FxaaFloat fxaaQualityEdgeThresholdMin,\", \"    //\", \"    // Only used on FXAA Console.\", \"    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\", \"    // It is here now to allow easier tuning.\", \"    // This does not effect PS3, as this needs to be compiled in.\", \"    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\", \"    //   Due to the PS3 being ALU bound,\", \"    //   there are only three safe values here: 2 and 4 and 8.\", \"    //   These options use the shaders ability to a free *|/ by 2|4|8.\", \"    // For all other platforms can be a non-power of two.\", \"    //   8.0 is sharper (default!!!)\", \"    //   4.0 is softer\", \"    //   2.0 is really soft (good only for vector graphics inputs)\", \"    FxaaFloat fxaaConsoleEdgeSharpness,\", \"    //\", \"    // Only used on FXAA Console.\", \"    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\", \"    // It is here now to allow easier tuning.\", \"    // This does not effect PS3, as this needs to be compiled in.\", \"    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\", \"    //   Due to the PS3 being ALU bound,\", \"    //   there are only two safe values here: 1/4 and 1/8.\", \"    //   These options use the shaders ability to a free *|/ by 2|4|8.\", \"    // The console setting has a different mapping than the quality setting.\", \"    // Other platforms can use other values.\", \"    //   0.125 leaves less aliasing, but is softer (default!!!)\", \"    //   0.25 leaves more aliasing, and is sharper\", \"    FxaaFloat fxaaConsoleEdgeThreshold,\", \"    //\", \"    // Only used on FXAA Console.\", \"    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\", \"    // It is here now to allow easier tuning.\", \"    // Trims the algorithm from processing darks.\", \"    // The console setting has a different mapping than the quality setting.\", \"    // This only applies when FXAA_EARLY_EXIT is 1.\", \"    // This does not apply to PS3,\", \"    // PS3 was simplified to avoid more shader instructions.\", \"    //   0.06 - faster but more aliasing in darks\", \"    //   0.05 - default\", \"    //   0.04 - slower and less aliasing in darks\", \"    // Special notes when using FXAA_GREEN_AS_LUMA,\", \"    //   Likely want to set this to zero.\", \"    //   As colors that are mostly not-green\", \"    //   will appear very dark in the green channel!\", \"    //   Tune by looking at mostly non-green content,\", \"    //   then start at zero and increase until aliasing is a problem.\", \"    FxaaFloat fxaaConsoleEdgeThresholdMin,\", \"    //\", \"    // Extra constants for 360 FXAA Console only.\", \"    // Use zeros or anything else for other platforms.\", \"    // These must be in physical constant registers and NOT immedates.\", \"    // Immedates will result in compiler un-optimizing.\", \"    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\", \"    FxaaFloat4 fxaaConsole360ConstDir\", \") {\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat2 posM;\", \"    posM.x = pos.x;\", \"    posM.y = pos.y;\", \"    #if (FXAA_GATHER4_ALPHA == 1)\", \"        #if (FXAA_DISCARD == 0)\", \"            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\", \"            #if (FXAA_GREEN_AS_LUMA == 0)\", \"                #define lumaM rgbyM.w\", \"            #else\", \"                #define lumaM rgbyM.y\", \"            #endif\", \"        #endif\", \"        #if (FXAA_GREEN_AS_LUMA == 0)\", \"            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\", \"            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\", \"        #else\", \"            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\", \"            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\", \"        #endif\", \"        #if (FXAA_DISCARD == 1)\", \"            #define lumaM luma4A.w\", \"        #endif\", \"        #define lumaE luma4A.z\", \"        #define lumaS luma4A.x\", \"        #define lumaSE luma4A.y\", \"        #define lumaNW luma4B.w\", \"        #define lumaN luma4B.z\", \"        #define lumaW luma4B.x\", \"    #else\", \"        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\", \"        #if (FXAA_GREEN_AS_LUMA == 0)\", \"            #define lumaM rgbyM.w\", \"        #else\", \"            #define lumaM rgbyM.y\", \"        #endif\", \"        #if (FXAA_GLSL_100 == 1)\", \"          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\", \"        #else\", \"          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\", \"        #endif\", \"    #endif\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat maxSM = max(lumaS, lumaM);\", \"    FxaaFloat minSM = min(lumaS, lumaM);\", \"    FxaaFloat maxESM = max(lumaE, maxSM);\", \"    FxaaFloat minESM = min(lumaE, minSM);\", \"    FxaaFloat maxWN = max(lumaN, lumaW);\", \"    FxaaFloat minWN = min(lumaN, lumaW);\", \"    FxaaFloat rangeMax = max(maxWN, maxESM);\", \"    FxaaFloat rangeMin = min(minWN, minESM);\", \"    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\", \"    FxaaFloat range = rangeMax - rangeMin;\", \"    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\", \"    FxaaBool earlyExit = range < rangeMaxClamped;\", \"/*--------------------------------------------------------------------------*/\", \"    if(earlyExit)\", \"        #if (FXAA_DISCARD == 1)\", \"            FxaaDiscard;\", \"        #else\", \"            return rgbyM;\", \"        #endif\", \"/*--------------------------------------------------------------------------*/\", \"    #if (FXAA_GATHER4_ALPHA == 0)\", \"        #if (FXAA_GLSL_100 == 1)\", \"          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\", \"        #else\", \"          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\", \"          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\", \"        #endif\", \"    #else\", \"        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\", \"        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\", \"    #endif\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat lumaNS = lumaN + lumaS;\", \"    FxaaFloat lumaWE = lumaW + lumaE;\", \"    FxaaFloat subpixRcpRange = 1.0/range;\", \"    FxaaFloat subpixNSWE = lumaNS + lumaWE;\", \"    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\", \"    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat lumaNESE = lumaNE + lumaSE;\", \"    FxaaFloat lumaNWNE = lumaNW + lumaNE;\", \"    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\", \"    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat lumaNWSW = lumaNW + lumaSW;\", \"    FxaaFloat lumaSWSE = lumaSW + lumaSE;\", \"    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\", \"    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\", \"    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\", \"    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\", \"    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\", \"    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\", \"    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\", \"    FxaaBool horzSpan = edgeHorz >= edgeVert;\", \"    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\", \"/*--------------------------------------------------------------------------*/\", \"    if(!horzSpan) lumaN = lumaW;\", \"    if(!horzSpan) lumaS = lumaE;\", \"    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\", \"    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat gradientN = lumaN - lumaM;\", \"    FxaaFloat gradientS = lumaS - lumaM;\", \"    FxaaFloat lumaNN = lumaN + lumaM;\", \"    FxaaFloat lumaSS = lumaS + lumaM;\", \"    FxaaBool pairN = abs(gradientN) >= abs(gradientS);\", \"    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\", \"    if(pairN) lengthSign = -lengthSign;\", \"    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat2 posB;\", \"    posB.x = posM.x;\", \"    posB.y = posM.y;\", \"    FxaaFloat2 offNP;\", \"    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\", \"    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\", \"    if(!horzSpan) posB.x += lengthSign * 0.5;\", \"    if( horzSpan) posB.y += lengthSign * 0.5;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat2 posN;\", \"    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\", \"    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\", \"    FxaaFloat2 posP;\", \"    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\", \"    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\", \"    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\", \"    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\", \"    FxaaFloat subpixE = subpixC * subpixC;\", \"    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\", \"/*--------------------------------------------------------------------------*/\", \"    if(!pairN) lumaNN = lumaSS;\", \"    FxaaFloat gradientScaled = gradient * 1.0/4.0;\", \"    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\", \"    FxaaFloat subpixF = subpixD * subpixE;\", \"    FxaaBool lumaMLTZero = lumaMM < 0.0;\", \"/*--------------------------------------------------------------------------*/\", \"    lumaEndN -= lumaNN * 0.5;\", \"    lumaEndP -= lumaNN * 0.5;\", \"    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\", \"    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\", \"    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\", \"    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\", \"    FxaaBool doneNP = (!doneN) || (!doneP);\", \"    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\", \"    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\", \"/*--------------------------------------------------------------------------*/\", \"    if(doneNP) {\", \"        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"        doneN = abs(lumaEndN) >= gradientScaled;\", \"        doneP = abs(lumaEndP) >= gradientScaled;\", \"        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\", \"        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\", \"        doneNP = (!doneN) || (!doneP);\", \"        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\", \"        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\", \"/*--------------------------------------------------------------------------*/\", \"        #if (FXAA_QUALITY_PS > 3)\", \"        if(doneNP) {\", \"            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"            doneN = abs(lumaEndN) >= gradientScaled;\", \"            doneP = abs(lumaEndP) >= gradientScaled;\", \"            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\", \"            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\", \"            doneNP = (!doneN) || (!doneP);\", \"            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\", \"            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\", \"/*--------------------------------------------------------------------------*/\", \"            #if (FXAA_QUALITY_PS > 4)\", \"            if(doneNP) {\", \"                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                doneN = abs(lumaEndN) >= gradientScaled;\", \"                doneP = abs(lumaEndP) >= gradientScaled;\", \"                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\", \"                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\", \"                doneNP = (!doneN) || (!doneP);\", \"                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\", \"                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\", \"/*--------------------------------------------------------------------------*/\", \"                #if (FXAA_QUALITY_PS > 5)\", \"                if(doneNP) {\", \"                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                    doneN = abs(lumaEndN) >= gradientScaled;\", \"                    doneP = abs(lumaEndP) >= gradientScaled;\", \"                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\", \"                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\", \"                    doneNP = (!doneN) || (!doneP);\", \"                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\", \"                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\", \"/*--------------------------------------------------------------------------*/\", \"                    #if (FXAA_QUALITY_PS > 6)\", \"                    if(doneNP) {\", \"                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                        doneN = abs(lumaEndN) >= gradientScaled;\", \"                        doneP = abs(lumaEndP) >= gradientScaled;\", \"                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\", \"                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\", \"                        doneNP = (!doneN) || (!doneP);\", \"                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\", \"                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\", \"/*--------------------------------------------------------------------------*/\", \"                        #if (FXAA_QUALITY_PS > 7)\", \"                        if(doneNP) {\", \"                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                            doneN = abs(lumaEndN) >= gradientScaled;\", \"                            doneP = abs(lumaEndP) >= gradientScaled;\", \"                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\", \"                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\", \"                            doneNP = (!doneN) || (!doneP);\", \"                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\", \"                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\", \"/*--------------------------------------------------------------------------*/\", \"    #if (FXAA_QUALITY_PS > 8)\", \"    if(doneNP) {\", \"        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"        doneN = abs(lumaEndN) >= gradientScaled;\", \"        doneP = abs(lumaEndP) >= gradientScaled;\", \"        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\", \"        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\", \"        doneNP = (!doneN) || (!doneP);\", \"        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\", \"        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\", \"/*--------------------------------------------------------------------------*/\", \"        #if (FXAA_QUALITY_PS > 9)\", \"        if(doneNP) {\", \"            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"            doneN = abs(lumaEndN) >= gradientScaled;\", \"            doneP = abs(lumaEndP) >= gradientScaled;\", \"            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\", \"            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\", \"            doneNP = (!doneN) || (!doneP);\", \"            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\", \"            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\", \"/*--------------------------------------------------------------------------*/\", \"            #if (FXAA_QUALITY_PS > 10)\", \"            if(doneNP) {\", \"                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                doneN = abs(lumaEndN) >= gradientScaled;\", \"                doneP = abs(lumaEndP) >= gradientScaled;\", \"                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\", \"                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\", \"                doneNP = (!doneN) || (!doneP);\", \"                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\", \"                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\", \"/*--------------------------------------------------------------------------*/\", \"                #if (FXAA_QUALITY_PS > 11)\", \"                if(doneNP) {\", \"                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                    doneN = abs(lumaEndN) >= gradientScaled;\", \"                    doneP = abs(lumaEndP) >= gradientScaled;\", \"                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\", \"                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\", \"                    doneNP = (!doneN) || (!doneP);\", \"                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\", \"                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\", \"/*--------------------------------------------------------------------------*/\", \"                    #if (FXAA_QUALITY_PS > 12)\", \"                    if(doneNP) {\", \"                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\", \"                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\", \"                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\", \"                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\", \"                        doneN = abs(lumaEndN) >= gradientScaled;\", \"                        doneP = abs(lumaEndP) >= gradientScaled;\", \"                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\", \"                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\", \"                        doneNP = (!doneN) || (!doneP);\", \"                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\", \"                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\", \"/*--------------------------------------------------------------------------*/\", \"                    }\", \"                    #endif\", \"/*--------------------------------------------------------------------------*/\", \"                }\", \"                #endif\", \"/*--------------------------------------------------------------------------*/\", \"            }\", \"            #endif\", \"/*--------------------------------------------------------------------------*/\", \"        }\", \"        #endif\", \"/*--------------------------------------------------------------------------*/\", \"    }\", \"    #endif\", \"/*--------------------------------------------------------------------------*/\", \"                        }\", \"                        #endif\", \"/*--------------------------------------------------------------------------*/\", \"                    }\", \"                    #endif\", \"/*--------------------------------------------------------------------------*/\", \"                }\", \"                #endif\", \"/*--------------------------------------------------------------------------*/\", \"            }\", \"            #endif\", \"/*--------------------------------------------------------------------------*/\", \"        }\", \"        #endif\", \"/*--------------------------------------------------------------------------*/\", \"    }\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat dstN = posM.x - posN.x;\", \"    FxaaFloat dstP = posP.x - posM.x;\", \"    if(!horzSpan) dstN = posM.y - posN.y;\", \"    if(!horzSpan) dstP = posP.y - posM.y;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\", \"    FxaaFloat spanLength = (dstP + dstN);\", \"    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\", \"    FxaaFloat spanLengthRcp = 1.0/spanLength;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaBool directionN = dstN < dstP;\", \"    FxaaFloat dst = min(dstN, dstP);\", \"    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\", \"    FxaaFloat subpixG = subpixF * subpixF;\", \"    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\", \"    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\", \"/*--------------------------------------------------------------------------*/\", \"    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\", \"    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\", \"    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\", \"    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\", \"    #if (FXAA_DISCARD == 1)\", \"        return FxaaTexTop(tex, posM);\", \"    #else\", \"        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\", \"    #endif\", \"}\", \"/*==========================================================================*/\", \"#endif\", \"\", \"void main() {\", \"  gl_FragColor = FxaaPixelShader(\", \"    vUv,\", \"    vec4(0.0),\", \"    tDiffuse,\", \"    tDiffuse,\", \"    tDiffuse,\", \"    resolution,\", \"    vec4(0.0),\", \"    vec4(0.0),\", \"    vec4(0.0),\", \"    0.75,\", \"    0.166,\", \"    0.0833,\", \"    0.0,\", \"    0.0,\", \"    0.0,\", \"    vec4(0.0)\", \"  );\", \"\", \"  // TODO avoid querying texture twice for same texel\", \"  gl_FragColor.a = texture2D(tDiffuse, vUv).a;\", \"}\"].join(\"\\n\")\n\n};\n\n//# sourceURL=webpack://CLM/./js/lib/glsl/FXAA.js?");

/***/ }),

/***/ "./js/lib/glsl/LuminosityHighPassShader.js":
/*!*************************************************!*\
  !*** ./js/lib/glsl/LuminosityHighPassShader.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author bhouston / http://clara.io/\r\n *\r\n * Luminosity\r\n * http://en.wikipedia.org/wiki/Luminosity\r\n */\n\nTHREE.LuminosityHighPassShader = {\n\n\t\tshaderID: \"luminosityHighPass\",\n\n\t\tuniforms: {\n\n\t\t\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\t\t\"luminosityThreshold\": { type: \"f\", value: 1.0 },\n\t\t\t\t\"smoothWidth\": { type: \"f\", value: 1.0 },\n\t\t\t\t\"defaultColor\": { type: \"c\", value: new THREE.Color(0x000000) },\n\t\t\t\t\"defaultOpacity\": { type: \"f\", value: 0.0 }\n\n\t\t},\n\n\t\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\t\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform vec3 defaultColor;\", \"uniform float defaultOpacity;\", \"uniform float luminosityThreshold;\", \"uniform float smoothWidth;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 texel = texture2D( tDiffuse, vUv );\", \"vec3 luma = vec3( 0.299, 0.587, 0.114 );\", \"float v = dot( texel.xyz, luma );\", \"vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\", \"float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\", \"gl_FragColor = mix( outputColor, texel, alpha );\", \"}\"].join(\"\\n\")\n\n};\n\n//# sourceURL=webpack://CLM/./js/lib/glsl/LuminosityHighPassShader.js?");

/***/ }),

/***/ "./js/lib/glsl/Poster.js":
/*!*******************************!*\
  !*** ./js/lib/glsl/Poster.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n  @author meatbags / https://github.com/meatbags\r\n  **/\n\nTHREE.PosterShader = {\n  uniforms: {\n    'tDiffuse': { value: null }\n  },\n  vertexShader: `\n    varying vec2 vUv;\n\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `,\n  fragmentShader: `\n    #define PI 3.14159\n    #define UV_SCALE 0.02\n    #define MAX_HEIGHT 0.5\n    varying vec2 vUv;\n    uniform sampler2D tDiffuse;\n\n    float posterise(float val, float amount) {\n      return floor(val * amount) / amount;\n    }\n\n    float posteriseCeil(float val, float amount) {\n      return ceil(val * amount) / amount;\n    }\n\n    void main() {\n      vec4 frag = texture2D(tDiffuse, vUv);\n      frag.r = posterise(frag.r, 16.0);\n      gl_FragColor = frag;\n    }\n  `\n};\n\n// render pass\nTHREE.PosterPass = function (size) {\n  THREE.Pass.call(this);\n  this.size = size;\n  this.shader = THREE.PosterShader;\n  this.material = new THREE.ShaderMaterial(this.shader);\n  this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n  this.scene = new THREE.Scene();\n  this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), this.material);\n  this.quad.frustumCulled = false;\n  this.scene.add(this.quad);\n  this.time = 0;\n};\n\nTHREE.PosterPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {\n  constructor: THREE.PosterPass,\n  render: function (renderer, writeBuffer, readBuffer, delta, maskActive) {\n    this.shader.uniforms['tDiffuse'].value = readBuffer.texture;\n    if (this.renderToScreen) {\n      renderer.render(this.scene, this.camera);\n    } else {\n      renderer.render(this.scene, this.camera, writeBuffer, this.clear);\n    }\n  }\n});\n\n//# sourceURL=webpack://CLM/./js/lib/glsl/Poster.js?");

/***/ }),

/***/ "./js/lib/glsl/RenderPass.js":
/*!***********************************!*\
  !*** ./js/lib/glsl/RenderPass.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\nTHREE.RenderPass = function (scene, camera, overrideMaterial, clearColor, clearAlpha) {\n\n\t\tTHREE.Pass.call(this);\n\n\t\tthis.scene = scene;\n\t\tthis.camera = camera;\n\n\t\tthis.overrideMaterial = overrideMaterial;\n\n\t\tthis.clearColor = clearColor;\n\t\tthis.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;\n\n\t\tthis.clear = true;\n\t\tthis.clearDepth = false;\n\t\tthis.needsSwap = false;\n};\n\nTHREE.RenderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {\n\n\t\tconstructor: THREE.RenderPass,\n\n\t\trender: function (renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\t\t\tvar oldAutoClear = renderer.autoClear;\n\t\t\t\trenderer.autoClear = false;\n\n\t\t\t\tthis.scene.overrideMaterial = this.overrideMaterial;\n\n\t\t\t\tvar oldClearColor, oldClearAlpha;\n\n\t\t\t\tif (this.clearColor) {\n\n\t\t\t\t\t\toldClearColor = renderer.getClearColor().getHex();\n\t\t\t\t\t\toldClearAlpha = renderer.getClearAlpha();\n\n\t\t\t\t\t\trenderer.setClearColor(this.clearColor, this.clearAlpha);\n\t\t\t\t}\n\n\t\t\t\tif (this.clearDepth) {\n\n\t\t\t\t\t\trenderer.clearDepth();\n\t\t\t\t}\n\n\t\t\t\trenderer.render(this.scene, this.camera, this.renderToScreen ? null : readBuffer, this.clear);\n\n\t\t\t\tif (this.clearColor) {\n\n\t\t\t\t\t\trenderer.setClearColor(oldClearColor, oldClearAlpha);\n\t\t\t\t}\n\n\t\t\t\tthis.scene.overrideMaterial = null;\n\t\t\t\trenderer.autoClear = oldAutoClear;\n\t\t}\n\n});\n\n//# sourceURL=webpack://CLM/./js/lib/glsl/RenderPass.js?");

/***/ }),

/***/ "./js/lib/glsl/ShaderPass.js":
/*!***********************************!*\
  !*** ./js/lib/glsl/ShaderPass.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\nTHREE.ShaderPass = function (shader, textureID) {\n\tTHREE.Pass.call(this);\n\n\tthis.textureID = textureID !== undefined ? textureID : \"tDiffuse\";\n\tif (shader instanceof THREE.ShaderMaterial) {\n\t\tthis.uniforms = shader.uniforms;\n\t\tthis.material = shader;\n\t} else if (shader) {\n\t\tthis.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n\t\tthis.material = new THREE.ShaderMaterial({\n\t\t\tdefines: shader.defines || {},\n\t\t\tuniforms: this.uniforms,\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader\n\t\t});\n\t}\n\n\tthis.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene = new THREE.Scene();\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\n\tthis.scene.add(this.quad);\n};\n\nTHREE.ShaderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {\n\tconstructor: THREE.ShaderPass,\n\trender: function (renderer, writeBuffer, readBuffer, delta, maskActive) {\n\t\tif (this.uniforms[this.textureID]) {\n\t\t\tthis.uniforms[this.textureID].value = readBuffer.texture;\n\t\t}\n\n\t\tthis.quad.material = this.material;\n\n\t\tif (this.renderToScreen) {\n\t\t\trenderer.render(this.scene, this.camera);\n\t\t} else {\n\t\t\trenderer.render(this.scene, this.camera, writeBuffer, this.clear);\n\t\t}\n\t}\n});\n\n//# sourceURL=webpack://CLM/./js/lib/glsl/ShaderPass.js?");

/***/ }),

/***/ "./js/lib/glsl/SkyShader.js":
/*!**********************************!*\
  !*** ./js/lib/glsl/SkyShader.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author zz85 / https://github.com/zz85\r\n *\r\n * Based on \"A Practical Analytic Model for Daylight\"\r\n * aka The Preetham Model, the de facto standard analytic skydome model\r\n * http://www.cs.utah.edu/~shirley/papers/sunsky/sunsky.pdf\r\n *\r\n * First implemented by Simon Wallner\r\n * http://www.simonwallner.at/projects/atmospheric-scattering\r\n *\r\n * Improved by Martin Upitis\r\n * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR\r\n *\r\n * Three.js integration by zz85 http://twitter.com/blurspline\r\n*/\n\nTHREE.Sky = function () {\n\t\tvar shader = THREE.Sky.SkyShader;\n\t\tvar material = new THREE.ShaderMaterial({\n\t\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\tuniforms: THREE.UniformsUtils.clone(shader.uniforms),\n\t\t\t\tside: THREE.BackSide\n\t\t});\n\t\tTHREE.Mesh.call(this, new THREE.BoxBufferGeometry(1, 1, 1), material);\n};\n\nTHREE.Sky.prototype = Object.create(THREE.Mesh.prototype);\nTHREE.Sky.SkyShader = {\n\t\tuniforms: {\n\t\t\t\tluminance: { value: 1 },\n\t\t\t\tturbidity: { value: 11.7 },\n\t\t\t\trayleigh: { value: 2 },\n\t\t\t\tmieCoefficient: { value: 0.005 },\n\t\t\t\tmieDirectionalG: { value: 0.8 },\n\t\t\t\tsunPosition: { value: new THREE.Vector3() }\n\t\t},\n\n\t\tvertexShader: ['uniform vec3 sunPosition;', 'uniform float rayleigh;', 'uniform float turbidity;', 'uniform float mieCoefficient;', 'varying vec3 vWorldPosition;', 'varying vec3 vSunDirection;', 'varying float vSunfade;', 'varying vec3 vBetaR;', 'varying vec3 vBetaM;', 'varying float vSunE;', 'const vec3 up = vec3( 0.0, 1.0, 0.0 );',\n\n\t\t// constants for atmospheric scattering\n\t\t'const float e = 2.71828182845904523536028747135266249775724709369995957;', 'const float pi = 3.141592653589793238462643383279502884197169;',\n\n\t\t// wavelength of used primaries, according to preetham\n\t\t'const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );',\n\t\t// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\n\t\t// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n\t\t'const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );',\n\n\t\t// mie stuff\n\t\t// K coefficient for the primaries\n\t\t'const float v = 4.0;', 'const vec3 K = vec3( 0.686, 0.678, 0.666 );',\n\t\t// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n\t\t'const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );',\n\n\t\t// earth shadow hack\n\t\t// cutoffAngle = pi / 1.95;\n\t\t'const float cutoffAngle = 1.6110731556870734;', 'const float steepness = 1.5;', 'const float EE = 1000.0;', 'float sunIntensity( float zenithAngleCos ) {', '\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );', '\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );', '}', 'vec3 totalMie( float T ) {', '\tfloat c = ( 0.2 * T ) * 10E-18;', '\treturn 0.434 * c * MieConst;', '}', 'void main() {', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tvWorldPosition = worldPosition.xyz;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '\tgl_Position.z = gl_Position.w;', // set z to camera.far\n\n\t\t'\tvSunDirection = normalize( sunPosition );', '\tvSunE = sunIntensity( dot( vSunDirection, up ) );', '\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );', '\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );',\n\n\t\t// extinction (absorbtion + out scattering)\n\t\t// rayleigh coefficients\n\t\t'\tvBetaR = totalRayleigh * rayleighCoefficient;',\n\n\t\t// mie coefficients\n\t\t'\tvBetaM = totalMie( turbidity ) * mieCoefficient;', '}'].join('\\n'),\n\n\t\tfragmentShader: ['varying vec3 vWorldPosition;', 'varying vec3 vSunDirection;', 'varying float vSunfade;', 'varying vec3 vBetaR;', 'varying vec3 vBetaM;', 'varying float vSunE;', 'uniform float luminance;', 'uniform float mieDirectionalG;', 'const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );',\n\n\t\t// constants for atmospheric scattering\n\t\t'const float pi = 3.141592653589793238462643383279502884197169;', 'const float n = 1.0003;', // refractive index of air\n\t\t'const float N = 2.545E25;', // number of molecules per unit volume for air at\n\t\t// 288.15K and 1013mb (sea level -45 celsius)\n\n\t\t// optical length at zenith for molecules\n\t\t'const float rayleighZenithLength = 8.4E3;', 'const float mieZenithLength = 1.25E3;', 'const vec3 up = vec3( 0.0, 1.0, 0.0 );',\n\t\t// 66 arc seconds -> degrees, and the cosine of that\n\t\t'const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;',\n\n\t\t// 3.0 / ( 16.0 * pi )\n\t\t'const float THREE_OVER_SIXTEENPI = 0.05968310365946075;',\n\t\t// 1.0 / ( 4.0 * pi )\n\t\t'const float ONE_OVER_FOURPI = 0.07957747154594767;', 'float rayleighPhase( float cosTheta ) {', '\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );', '}', 'float hgPhase( float cosTheta, float g ) {', '\tfloat g2 = pow( g, 2.0 );', '\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );', '\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );', '}',\n\n\t\t// Filmic ToneMapping http://filmicgames.com/archives/75\n\t\t'const float A = 0.15;', 'const float B = 0.50;', 'const float C = 0.10;', 'const float D = 0.20;', 'const float E = 0.02;', 'const float F = 0.30;', 'const float whiteScale = 1.0748724675633854;', // 1.0 / Uncharted2Tonemap(1000.0)\n\n\t\t'vec3 Uncharted2Tonemap( vec3 x ) {', '\treturn ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;', '}', 'void main() {',\n\t\t// optical length\n\t\t// cutoff angle at 90 to avoid singularity in next formula.\n\t\t'\tfloat zenithAngle = acos( max( 0.0, dot( up, normalize( vWorldPosition - cameraPos ) ) ) );', '\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );', '\tfloat sR = rayleighZenithLength * inverse;', '\tfloat sM = mieZenithLength * inverse;',\n\n\t\t// combined extinction factor\n\t\t'\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );',\n\n\t\t// in scattering\n\t\t'\tfloat cosTheta = dot( normalize( vWorldPosition - cameraPos ), vSunDirection );', '\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );', '\tvec3 betaRTheta = vBetaR * rPhase;', '\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );', '\tvec3 betaMTheta = vBetaM * mPhase;', '\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );', '\tLin *= mix(vec3(1.0), pow(vSunE * ((betaRTheta + betaMTheta) / (vBetaR + vBetaM)) * Fex, vec3(1.0 / 2.0)), clamp(pow(1.0 - dot(up, vSunDirection), 5.0), 0.0, 1.0));',\n\n\t\t// nightsky\n\t\t'\tvec3 direction = normalize( vWorldPosition - cameraPos );', '\tfloat theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]', '\tfloat phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]', '\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );', '\tvec3 L0 = vec3( 0.1 ) * Fex;',\n\n\t\t// composition + solar disc\n\t\t//'\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );',\n\t\t//'\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;',\n\n\t\t//'\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );',\n\t\t'\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );', '\tvec3 curr = Uncharted2Tonemap( ( log2( 2.0 / pow( luminance, 4.0 ) ) ) * texColor );', '\tvec3 color = curr * whiteScale;', '\tvec3 retColor = pow( color, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );', '\tgl_FragColor = vec4( retColor, 1.0 );', '}'].join('\\n')\n\n};\n\n//# sourceURL=webpack://CLM/./js/lib/glsl/SkyShader.js?");

/***/ }),

/***/ "./js/lib/glsl/UnrealBloomPass.js":
/*!****************************************!*\
  !*** ./js/lib/glsl/UnrealBloomPass.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author spidersharma / http://eduperiment.com/\r\n *\r\n * Inspired from Unreal Engine\r\n * https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\r\n */\nTHREE.UnrealBloomPass = function (resolution, strength, radius, threshold) {\n\n\tTHREE.Pass.call(this);\n\n\tthis.strength = strength !== undefined ? strength : 1;\n\tthis.radius = radius;\n\tthis.threshold = threshold;\n\tthis.resolution = resolution !== undefined ? new THREE.Vector2(resolution.x, resolution.y) : new THREE.Vector2(256, 256);\n\n\t// render targets\n\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };\n\tthis.renderTargetsHorizontal = [];\n\tthis.renderTargetsVertical = [];\n\tthis.nMips = 5;\n\tvar resx = Math.round(this.resolution.x / 2);\n\tvar resy = Math.round(this.resolution.y / 2);\n\n\tthis.renderTargetBright = new THREE.WebGLRenderTarget(resx, resy, pars);\n\tthis.renderTargetBright.texture.name = \"UnrealBloomPass.bright\";\n\tthis.renderTargetBright.texture.generateMipmaps = false;\n\n\tfor (var i = 0; i < this.nMips; i++) {\n\n\t\tvar renderTarget = new THREE.WebGLRenderTarget(resx, resy, pars);\n\n\t\trenderTarget.texture.name = \"UnrealBloomPass.h\" + i;\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetsHorizontal.push(renderTarget);\n\n\t\tvar renderTarget = new THREE.WebGLRenderTarget(resx, resy, pars);\n\n\t\trenderTarget.texture.name = \"UnrealBloomPass.v\" + i;\n\t\trenderTarget.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetsVertical.push(renderTarget);\n\n\t\tresx = Math.round(resx / 2);\n\n\t\tresy = Math.round(resy / 2);\n\t}\n\n\t// luminosity high pass material\n\n\tif (THREE.LuminosityHighPassShader === undefined) console.error(\"THREE.UnrealBloomPass relies on THREE.LuminosityHighPassShader\");\n\n\tvar highPassShader = THREE.LuminosityHighPassShader;\n\tthis.highPassUniforms = THREE.UniformsUtils.clone(highPassShader.uniforms);\n\n\tthis.highPassUniforms[\"luminosityThreshold\"].value = threshold;\n\tthis.highPassUniforms[\"smoothWidth\"].value = 0.01;\n\n\tthis.materialHighPassFilter = new THREE.ShaderMaterial({\n\t\tuniforms: this.highPassUniforms,\n\t\tvertexShader: highPassShader.vertexShader,\n\t\tfragmentShader: highPassShader.fragmentShader,\n\t\tdefines: {}\n\t});\n\n\t// Gaussian Blur Materials\n\tthis.separableBlurMaterials = [];\n\tvar kernelSizeArray = [3, 5, 7, 9, 11];\n\tvar resx = Math.round(this.resolution.x / 2);\n\tvar resy = Math.round(this.resolution.y / 2);\n\n\tfor (var i = 0; i < this.nMips; i++) {\n\n\t\tthis.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));\n\n\t\tthis.separableBlurMaterials[i].uniforms[\"texSize\"].value = new THREE.Vector2(resx, resy);\n\n\t\tresx = Math.round(resx / 2);\n\n\t\tresy = Math.round(resy / 2);\n\t}\n\n\t// Composite material\n\tthis.compositeMaterial = this.getCompositeMaterial(this.nMips);\n\tthis.compositeMaterial.uniforms[\"blurTexture1\"].value = this.renderTargetsVertical[0].texture;\n\tthis.compositeMaterial.uniforms[\"blurTexture2\"].value = this.renderTargetsVertical[1].texture;\n\tthis.compositeMaterial.uniforms[\"blurTexture3\"].value = this.renderTargetsVertical[2].texture;\n\tthis.compositeMaterial.uniforms[\"blurTexture4\"].value = this.renderTargetsVertical[3].texture;\n\tthis.compositeMaterial.uniforms[\"blurTexture5\"].value = this.renderTargetsVertical[4].texture;\n\tthis.compositeMaterial.uniforms[\"bloomStrength\"].value = strength;\n\tthis.compositeMaterial.uniforms[\"bloomRadius\"].value = 0.1;\n\tthis.compositeMaterial.needsUpdate = true;\n\n\tvar bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\n\tthis.compositeMaterial.uniforms[\"bloomFactors\"].value = bloomFactors;\n\tthis.bloomTintColors = [new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1)];\n\tthis.compositeMaterial.uniforms[\"bloomTintColors\"].value = this.bloomTintColors;\n\n\t// copy material\n\tif (THREE.CopyShader === undefined) {\n\n\t\tconsole.error(\"THREE.BloomPass relies on THREE.CopyShader\");\n\t}\n\n\tvar copyShader = THREE.CopyShader;\n\n\tthis.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);\n\tthis.copyUniforms[\"opacity\"].value = 1.0;\n\n\tthis.materialCopy = new THREE.ShaderMaterial({\n\t\tuniforms: this.copyUniforms,\n\t\tvertexShader: copyShader.vertexShader,\n\t\tfragmentShader: copyShader.fragmentShader,\n\t\tblending: THREE.AdditiveBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false,\n\t\ttransparent: true\n\t});\n\n\tthis.enabled = true;\n\tthis.needsSwap = false;\n\n\tthis.oldClearColor = new THREE.Color();\n\tthis.oldClearAlpha = 1;\n\n\tthis.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tthis.scene = new THREE.Scene();\n\n\tthis.basic = new THREE.MeshBasicMaterial();\n\n\tthis.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);\n\tthis.quad.frustumCulled = false; // Avoid getting clipped\n\tthis.scene.add(this.quad);\n};\n\nTHREE.UnrealBloomPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {\n\n\tconstructor: THREE.UnrealBloomPass,\n\n\tdispose: function () {\n\n\t\tfor (var i = 0; i < this.renderTargetsHorizontal.length; i++) {\n\n\t\t\tthis.renderTargetsHorizontal[i].dispose();\n\t\t}\n\n\t\tfor (var i = 0; i < this.renderTargetsVertical.length; i++) {\n\n\t\t\tthis.renderTargetsVertical[i].dispose();\n\t\t}\n\n\t\tthis.renderTargetBright.dispose();\n\t},\n\n\tsetSize: function (width, height) {\n\n\t\tvar resx = Math.round(width / 2);\n\t\tvar resy = Math.round(height / 2);\n\n\t\tthis.renderTargetBright.setSize(resx, resy);\n\n\t\tfor (var i = 0; i < this.nMips; i++) {\n\n\t\t\tthis.renderTargetsHorizontal[i].setSize(resx, resy);\n\t\t\tthis.renderTargetsVertical[i].setSize(resx, resy);\n\n\t\t\tthis.separableBlurMaterials[i].uniforms[\"texSize\"].value = new THREE.Vector2(resx, resy);\n\n\t\t\tresx = Math.round(resx / 2);\n\t\t\tresy = Math.round(resy / 2);\n\t\t}\n\t},\n\n\trender: function (renderer, writeBuffer, readBuffer, delta, maskActive) {\n\n\t\tthis.oldClearColor.copy(renderer.getClearColor());\n\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\tvar oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.setClearColor(new THREE.Color(0, 0, 0), 0);\n\n\t\tif (maskActive) renderer.context.disable(renderer.context.STENCIL_TEST);\n\n\t\t// Render input to screen\n\n\t\tif (this.renderToScreen) {\n\n\t\t\tthis.quad.material = this.basic;\n\t\t\tthis.basic.map = readBuffer.texture;\n\n\t\t\trenderer.render(this.scene, this.camera, undefined, true);\n\t\t}\n\n\t\t// 1. Extract Bright Areas\n\n\t\tthis.highPassUniforms[\"tDiffuse\"].value = readBuffer.texture;\n\t\tthis.highPassUniforms[\"luminosityThreshold\"].value = this.threshold;\n\t\tthis.quad.material = this.materialHighPassFilter;\n\n\t\trenderer.render(this.scene, this.camera, this.renderTargetBright, true);\n\n\t\t// 2. Blur All the mips progressively\n\n\t\tvar inputRenderTarget = this.renderTargetBright;\n\n\t\tfor (var i = 0; i < this.nMips; i++) {\n\n\t\t\tthis.quad.material = this.separableBlurMaterials[i];\n\n\t\t\tthis.separableBlurMaterials[i].uniforms[\"colorTexture\"].value = inputRenderTarget.texture;\n\t\t\tthis.separableBlurMaterials[i].uniforms[\"direction\"].value = THREE.UnrealBloomPass.BlurDirectionX;\n\t\t\trenderer.render(this.scene, this.camera, this.renderTargetsHorizontal[i], true);\n\n\t\t\tthis.separableBlurMaterials[i].uniforms[\"colorTexture\"].value = this.renderTargetsHorizontal[i].texture;\n\t\t\tthis.separableBlurMaterials[i].uniforms[\"direction\"].value = THREE.UnrealBloomPass.BlurDirectionY;\n\t\t\trenderer.render(this.scene, this.camera, this.renderTargetsVertical[i], true);\n\n\t\t\tinputRenderTarget = this.renderTargetsVertical[i];\n\t\t}\n\n\t\t// Composite All the mips\n\n\t\tthis.quad.material = this.compositeMaterial;\n\t\tthis.compositeMaterial.uniforms[\"bloomStrength\"].value = this.strength;\n\t\tthis.compositeMaterial.uniforms[\"bloomRadius\"].value = this.radius;\n\t\tthis.compositeMaterial.uniforms[\"bloomTintColors\"].value = this.bloomTintColors;\n\n\t\trenderer.render(this.scene, this.camera, this.renderTargetsHorizontal[0], true);\n\n\t\t// Blend it additively over the input texture\n\n\t\tthis.quad.material = this.materialCopy;\n\t\tthis.copyUniforms[\"tDiffuse\"].value = this.renderTargetsHorizontal[0].texture;\n\n\t\tif (maskActive) renderer.context.enable(renderer.context.STENCIL_TEST);\n\n\t\tif (this.renderToScreen) {\n\n\t\t\trenderer.render(this.scene, this.camera, undefined, false);\n\t\t} else {\n\n\t\t\trenderer.render(this.scene, this.camera, readBuffer, false);\n\t\t}\n\n\t\t// Restore renderer settings\n\n\t\trenderer.setClearColor(this.oldClearColor, this.oldClearAlpha);\n\t\trenderer.autoClear = oldAutoClear;\n\t},\n\n\tgetSeperableBlurMaterial: function (kernelRadius) {\n\n\t\treturn new THREE.ShaderMaterial({\n\n\t\t\tdefines: {\n\t\t\t\t\"KERNEL_RADIUS\": kernelRadius,\n\t\t\t\t\"SIGMA\": kernelRadius\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t\"colorTexture\": { value: null },\n\t\t\t\t\"texSize\": { value: new THREE.Vector2(0.5, 0.5) },\n\t\t\t\t\"direction\": { value: new THREE.Vector2(0.5, 0.5) }\n\t\t\t},\n\n\t\t\tvertexShader: \"varying vec2 vUv;\\n\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvUv = uv;\\n\\\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\r\n\t\t\t\t}\",\n\n\t\t\tfragmentShader: \"#include <common>\\\r\n\t\t\t\tvarying vec2 vUv;\\n\\\r\n\t\t\t\tuniform sampler2D colorTexture;\\n\\\r\n\t\t\t\tuniform vec2 texSize;\\\r\n\t\t\t\tuniform vec2 direction;\\\r\n\t\t\t\t\\\r\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\\\r\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\r\n\t\t\t\t}\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\r\n\t\t\t\t\tfloat fSigma = float(SIGMA);\\\r\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\\\r\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\\\r\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\\\r\n\t\t\t\t\t\tfloat x = float(i);\\\r\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\\\r\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\\\r\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\\\r\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\\\r\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\\\r\n\t\t\t\t\t\tweightSum += 2.0 * w;\\\r\n\t\t\t\t\t}\\\r\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\n\\\r\n\t\t\t\t}\"\n\t\t});\n\t},\n\n\tgetCompositeMaterial: function (nMips) {\n\n\t\treturn new THREE.ShaderMaterial({\n\n\t\t\tdefines: {\n\t\t\t\t\"NUM_MIPS\": nMips\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t\"blurTexture1\": { value: null },\n\t\t\t\t\"blurTexture2\": { value: null },\n\t\t\t\t\"blurTexture3\": { value: null },\n\t\t\t\t\"blurTexture4\": { value: null },\n\t\t\t\t\"blurTexture5\": { value: null },\n\t\t\t\t\"dirtTexture\": { value: null },\n\t\t\t\t\"bloomStrength\": { value: 1.0 },\n\t\t\t\t\"bloomFactors\": { value: null },\n\t\t\t\t\"bloomTintColors\": { value: null },\n\t\t\t\t\"bloomRadius\": { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader: \"varying vec2 vUv;\\n\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvUv = uv;\\n\\\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\r\n\t\t\t\t}\",\n\n\t\t\tfragmentShader: \"varying vec2 vUv;\\\r\n\t\t\t\tuniform sampler2D blurTexture1;\\\r\n\t\t\t\tuniform sampler2D blurTexture2;\\\r\n\t\t\t\tuniform sampler2D blurTexture3;\\\r\n\t\t\t\tuniform sampler2D blurTexture4;\\\r\n\t\t\t\tuniform sampler2D blurTexture5;\\\r\n\t\t\t\tuniform sampler2D dirtTexture;\\\r\n\t\t\t\tuniform float bloomStrength;\\\r\n\t\t\t\tuniform float bloomRadius;\\\r\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\\\r\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\\\r\n\t\t\t\t\\\r\n\t\t\t\tfloat lerpBloomFactor(const in float factor) { \\\r\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\\\r\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\\\r\n\t\t\t\t}\\\r\n\t\t\t\t\\\r\n\t\t\t\tvoid main() {\\\r\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\\\r\n\t\t\t\t}\"\n\t\t});\n\t}\n\n});\n\nTHREE.UnrealBloomPass.BlurDirectionX = new THREE.Vector2(1.0, 0.0);\nTHREE.UnrealBloomPass.BlurDirectionY = new THREE.Vector2(0.0, 1.0);\n\n//# sourceURL=webpack://CLM/./js/lib/glsl/UnrealBloomPass.js?");

/***/ }),

/***/ "./js/lib/glsl/index.js":
/*!******************************!*\
  !*** ./js/lib/glsl/index.js ***!
  \******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _CopyShader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CopyShader.js */ \"./js/lib/glsl/CopyShader.js\");\n/* harmony import */ var _CopyShader_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_CopyShader_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _EffectComposer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EffectComposer.js */ \"./js/lib/glsl/EffectComposer.js\");\n/* harmony import */ var _EffectComposer_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_EffectComposer_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _FXAA_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FXAA.js */ \"./js/lib/glsl/FXAA.js\");\n/* harmony import */ var _FXAA_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_FXAA_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _LuminosityHighPassShader_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./LuminosityHighPassShader.js */ \"./js/lib/glsl/LuminosityHighPassShader.js\");\n/* harmony import */ var _LuminosityHighPassShader_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_LuminosityHighPassShader_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _RenderPass_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RenderPass.js */ \"./js/lib/glsl/RenderPass.js\");\n/* harmony import */ var _RenderPass_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_RenderPass_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _ShaderPass_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ShaderPass.js */ \"./js/lib/glsl/ShaderPass.js\");\n/* harmony import */ var _ShaderPass_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_ShaderPass_js__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _UnrealBloomPass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./UnrealBloomPass.js */ \"./js/lib/glsl/UnrealBloomPass.js\");\n/* harmony import */ var _UnrealBloomPass_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_UnrealBloomPass_js__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _SkyShader_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./SkyShader.js */ \"./js/lib/glsl/SkyShader.js\");\n/* harmony import */ var _SkyShader_js__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_SkyShader_js__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _Poster_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Poster.js */ \"./js/lib/glsl/Poster.js\");\n/* harmony import */ var _Poster_js__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_Poster_js__WEBPACK_IMPORTED_MODULE_8__);\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://CLM/./js/lib/glsl/index.js?");

/***/ }),

/***/ "./js/lib/loaders/FBXLoader.js":
/*!*************************************!*\
  !*** ./js/lib/loaders/FBXLoader.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author Kyle-Larson https://github.com/Kyle-Larson\r\n * @author Takahiro https://github.com/takahirox\r\n *\r\n * Loader loads FBX file and generates Group representing FBX scene.\r\n * Requires FBX file to be >= 7.0 and in ASCII or to be any version in Binary format.\r\n *\r\n * Supports:\r\n * \tMesh Generation (Positional Data)\r\n * \tNormal Data (Per Vertex Drawing Instance)\r\n *\tUV Data (Per Vertex Drawing Instance)\r\n *\tSkinning\r\n *\tAnimation\r\n * \t- Separated Animations based on stacks.\r\n * \t- Skeletal & Non-Skeletal Animations\r\n *\tNURBS (Open, Closed and Periodic forms)\r\n *\r\n * Needs Support:\r\n * \tIndexed Buffers\r\n * \tPreRotation support.\r\n *\tEuler rotation order\r\n *\r\n * FBX format references:\r\n * \thttps://wiki.blender.org/index.php/User:Mont29/Foundation/FBX_File_Structure\r\n *\r\n * \tBinary format specification:\r\n *\t\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\r\n *\t\thttps://wiki.rogiken.org/specifications/file-format/fbx/ (more detail but Japanese)\r\n *\r\n * Modifications\r\n * @author github.com/meatbags\r\n * Added support for Maya 2018 Stingray PBR Shaders -> MeshStandardMaterial\r\n */\n\n(function () {\n\t\tTHREE.FBXLoader = function (manager) {\n\t\t\t\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\t\t};\n\n\t\tObject.assign(THREE.FBXLoader.prototype, {\n\t\t\t\tload: function (url, onLoad, onProgress, onError) {\n\t\t\t\t\t\tvar self = this;\n\t\t\t\t\t\tvar resourceDirectory = THREE.Loader.prototype.extractUrlBase(url); // THREE.LoaderUtils.extractUrlBase(url);\n\t\t\t\t\t\tvar loader = new THREE.FileLoader(this.manager);\n\t\t\t\t\t\tloader.setResponseType('arraybuffer');\n\t\t\t\t\t\tloader.load(url, function (buffer) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tvar scene = self.parse(buffer, resourceDirectory);\n\t\t\t\t\t\t\t\t\t\tonLoad(scene);\n\t\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\t\t\twindow.setTimeout(function () {\n\t\t\t\t\t\t\t\t\t\t\t\tif (onError) onError(error);\n\t\t\t\t\t\t\t\t\t\t\t\tself.manager.itemError(url);\n\t\t\t\t\t\t\t\t\t\t}, 0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, onProgress, onError);\n\t\t\t\t},\n\n\t\t\t\tparse: function (FBXBuffer, resourceDirectory) {\n\t\t\t\t\t\tvar FBXTree;\n\t\t\t\t\t\tif (isFbxFormatBinary(FBXBuffer)) {\n\t\t\t\t\t\t\t\tFBXTree = new BinaryParser().parse(FBXBuffer);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvar FBXText = convertArrayBufferToString(FBXBuffer);\n\t\t\t\t\t\t\t\tif (!isFbxFormatASCII(FBXText)) {\n\t\t\t\t\t\t\t\t\t\tthrow new Error('THREE.FBXLoader: Unknown format.');\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (getFbxVersion(FBXText) < 7000) {\n\t\t\t\t\t\t\t\t\t\tthrow new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion(FBXText));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tFBXTree = new TextParser().parse(FBXText);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar connections = parseConnections(FBXTree);\n\t\t\t\t\t\tvar images = parseImages(FBXTree);\n\t\t\t\t\t\tvar textures = parseTextures(FBXTree, new THREE.TextureLoader(this.manager).setPath(resourceDirectory), images, connections);\n\t\t\t\t\t\tvar materials = parseMaterials(FBXTree, textures, connections);\n\t\t\t\t\t\tvar deformers = parseDeformers(FBXTree, connections);\n\t\t\t\t\t\tvar geometryMap = parseGeometries(FBXTree, connections, deformers);\n\t\t\t\t\t\tvar sceneGraph = parseScene(FBXTree, connections, deformers, geometryMap, materials);\n\t\t\t\t\t\treturn sceneGraph;\n\t\t\t\t}\n\n\t\t});\n\n\t\t// Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n\t\t// and details the connection type\n\t\tfunction parseConnections(FBXTree) {\n\t\t\t\tvar connectionMap = new Map();\n\t\t\t\tif ('Connections' in FBXTree) {\n\t\t\t\t\t\tvar connectionArray = FBXTree.Connections.properties.connections;\n\t\t\t\t\t\tfor (var connectionArrayIndex = 0, connectionArrayLength = connectionArray.length; connectionArrayIndex < connectionArrayLength; ++connectionArrayIndex) {\n\t\t\t\t\t\t\t\tvar connection = connectionArray[connectionArrayIndex];\n\t\t\t\t\t\t\t\tif (!connectionMap.has(connection[0])) {\n\t\t\t\t\t\t\t\t\t\tconnectionMap.set(connection[0], {\n\t\t\t\t\t\t\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\t\t\t\t\t\t\tchildren: []\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tvar parentRelationship = { ID: connection[1], relationship: connection[2] };\n\t\t\t\t\t\t\t\tconnectionMap.get(connection[0]).parents.push(parentRelationship);\n\t\t\t\t\t\t\t\tif (!connectionMap.has(connection[1])) {\n\t\t\t\t\t\t\t\t\t\tconnectionMap.set(connection[1], {\n\t\t\t\t\t\t\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\t\t\t\t\t\t\tchildren: []\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tvar childRelationship = { ID: connection[0], relationship: connection[2] };\n\t\t\t\t\t\t\t\tconnectionMap.get(connection[1]).children.push(childRelationship);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn connectionMap;\n\t\t}\n\n\t\t// Parses map of images referenced in FBXTree.Objects.subNodes.Video\n\t\t// Images can either be referenced externally or embedded in the file\n\t\t// These images are connected to textures in FBXTree.Objects.subNodes.Textures\n\t\t// via FBXTree.Connections. Note that images can be duplicated here, in which case only one\n\t\t// will will have a .Content field\n\t\tfunction parseImages(FBXTree) {\n\n\t\t\t\tvar imageMap = new Map();\n\n\t\t\t\tif ('Video' in FBXTree.Objects.subNodes) {\n\n\t\t\t\t\t\tvar videoNodes = FBXTree.Objects.subNodes.Video;\n\n\t\t\t\t\t\tfor (var nodeID in videoNodes) {\n\n\t\t\t\t\t\t\t\tvar videoNode = videoNodes[nodeID];\n\n\t\t\t\t\t\t\t\t// raw image data is in videoNode.properties.Content\n\t\t\t\t\t\t\t\tif ('Content' in videoNode.properties) {\n\n\t\t\t\t\t\t\t\t\t\tvar image = parseImage(videoNodes[nodeID]);\n\t\t\t\t\t\t\t\t\t\timageMap.set(parseInt(nodeID), image);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn imageMap;\n\t\t}\n\n\t\t// Parse embedded image data in FBXTree.Video.properties.Content\n\t\tfunction parseImage(videoNode) {\n\n\t\t\t\tvar content = videoNode.properties.Content;\n\t\t\t\tvar fileName = videoNode.properties.RelativeFilename || videoNode.properties.Filename;\n\t\t\t\tvar extension = fileName.slice(fileName.lastIndexOf('.') + 1).toLowerCase();\n\n\t\t\t\tvar type;\n\n\t\t\t\tswitch (extension) {\n\n\t\t\t\t\t\tcase 'bmp':\n\n\t\t\t\t\t\t\t\ttype = 'image/bmp';\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'jpg':\n\t\t\t\t\t\tcase 'jpeg':\n\n\t\t\t\t\t\t\t\ttype = 'image/jpeg';\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'png':\n\n\t\t\t\t\t\t\t\ttype = 'image/png';\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'tif':\n\n\t\t\t\t\t\t\t\ttype = 'image/tiff';\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\tconsole.warn('FBXLoader: Image type \"' + extension + '\" is not supported.');\n\t\t\t\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tif (typeof content === 'string') {\n\n\t\t\t\t\t\treturn 'data:' + type + ';base64,' + content;\n\t\t\t\t} else {\n\n\t\t\t\t\t\tvar array = new Uint8Array(content);\n\t\t\t\t\t\treturn window.URL.createObjectURL(new Blob([array], { type: type }));\n\t\t\t\t}\n\t\t}\n\n\t\t// Parse nodes in FBXTree.Objects.subNodes.Texture\n\t\t// These contain details such as UV scaling, cropping, rotation etc and are connected\n\t\t// to images in FBXTree.Objects.subNodes.Video\n\t\tfunction parseTextures(FBXTree, loader, imageMap, connections) {\n\n\t\t\t\tvar textureMap = new Map();\n\t\t\t\tvar extensionWhitelist = ['jpg', 'jpeg', 'png', 'bmp'];\n\n\t\t\t\tif ('Texture' in FBXTree.Objects.subNodes) {\n\n\t\t\t\t\t\tvar textureNodes = FBXTree.Objects.subNodes.Texture;\n\n\t\t\t\t\t\tfor (var nodeID in textureNodes) {\n\t\t\t\t\t\t\t\tvar textureNode = textureNodes[nodeID];\n\t\t\t\t\t\t\t\tvar extension = textureNode.properties.FileName.slice(textureNode.properties.FileName.lastIndexOf('.') + 1).toLowerCase();\n\t\t\t\t\t\t\t\tif (extensionWhitelist.indexOf(extension) != -1) {\n\t\t\t\t\t\t\t\t\t\tvar texture = parseTexture(textureNode, loader, imageMap, connections);\n\t\t\t\t\t\t\t\t\t\ttextureMap.set(parseInt(nodeID), texture);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn textureMap;\n\t\t}\n\n\t\t// Parse individual node in FBXTree.Objects.subNodes.Texture\n\t\tfunction parseTexture(textureNode, loader, imageMap, connections) {\n\n\t\t\t\tvar FBX_ID = textureNode.id;\n\t\t\t\tvar name = textureNode.attrName;\n\t\t\t\tvar fileName;\n\t\t\t\tvar filePath = textureNode.properties.FileName;\n\n\t\t\t\tvar relativeFilePath = textureNode.properties.RelativeFilename;\n\t\t\t\tvar children = connections.get(FBX_ID).children;\n\n\t\t\t\tif (children !== undefined && children.length > 0 && imageMap.has(children[0].ID)) {\n\t\t\t\t\t\tfileName = imageMap.get(children[0].ID);\n\t\t\t\t} else if (relativeFilePath !== undefined && relativeFilePath[0] !== '/' && relativeFilePath.match(/^[a-zA-Z]:/) === null) {\n\n\t\t\t\t\t\t// use textureNode.properties.RelativeFilename\n\t\t\t\t\t\t// if it exists and it doesn't seem an absolute path\n\n\t\t\t\t\t\tfileName = relativeFilePath;\n\t\t\t\t} else {\n\n\t\t\t\t\t\tvar split = filePath.split(/[\\\\\\/]/);\n\n\t\t\t\t\t\tif (split.length > 0) {\n\n\t\t\t\t\t\t\t\tfileName = split[split.length - 1];\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tfileName = filePath;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar currentPath = loader.path;\n\n\t\t\t\tif (fileName.indexOf('blob:') === 0 || fileName.indexOf('data:') === 0) {\n\n\t\t\t\t\t\tloader.setPath(undefined);\n\t\t\t\t}\n\n\t\t\t\tvar texture = loader.load(fileName);\n\t\t\t\ttexture.name = name;\n\t\t\t\ttexture.FBX_ID = FBX_ID;\n\n\t\t\t\tvar wrapModeU = textureNode.properties.WrapModeU;\n\t\t\t\tvar wrapModeV = textureNode.properties.WrapModeV;\n\n\t\t\t\tvar valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\n\t\t\t\tvar valueV = wrapModeV !== undefined ? wrapModeV.value : 0;\n\n\t\t\t\t// http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n\t\t\t\t// 0: repeat(default), 1: clamp\n\n\t\t\t\ttexture.wrapS = valueU === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\t\t\t\ttexture.wrapT = valueV === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\n\t\t\t\tif ('Scaling' in textureNode.properties) {\n\n\t\t\t\t\t\tvar values = textureNode.properties.Scaling.value;\n\n\t\t\t\t\t\ttexture.repeat.x = values[0];\n\t\t\t\t\t\ttexture.repeat.y = values[1];\n\t\t\t\t}\n\n\t\t\t\tloader.setPath(currentPath);\n\n\t\t\t\treturn texture;\n\t\t}\n\n\t\t// Parse nodes in FBXTree.Objects.subNodes.Material\n\t\tfunction parseMaterials(FBXTree, textureMap, connections) {\n\t\t\t\tvar materialMap = new Map();\n\n\t\t\t\tif ('Material' in FBXTree.Objects.subNodes) {\n\n\t\t\t\t\t\tvar materialNodes = FBXTree.Objects.subNodes.Material;\n\t\t\t\t\t\tfor (var nodeID in materialNodes) {\n\n\t\t\t\t\t\t\t\tvar material = parseMaterial(materialNodes[nodeID], textureMap, connections);\n\t\t\t\t\t\t\t\tif (material !== null) materialMap.set(parseInt(nodeID), material);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn materialMap;\n\t\t}\n\n\t\t// Parse single node in FBXTree.Objects.subNodes.Material\n\t\t// Materials are connected to texture maps in FBXTree.Objects.subNodes.Textures\n\t\t// FBX format currently only supports Lambert and Phong shading models\n\t\tfunction parseMaterial(materialNode, textureMap, connections) {\n\n\t\t\t\t//console.log('NODE', materialNode, textureMap, connections);\n\n\t\t\t\tvar FBX_ID = materialNode.id;\n\t\t\t\tvar name = materialNode.attrName;\n\t\t\t\tvar type = materialNode.properties.ShadingModel;\n\n\t\t\t\t// Case where FBX wraps shading model in property object.\n\t\t\t\tif (typeof type === 'object') {\n\t\t\t\t\t\ttype = type.value;\n\t\t\t\t}\n\n\t\t\t\t// Ignore unused materials which don't have any connections.\n\t\t\t\tif (!connections.has(FBX_ID)) return null;\n\n\t\t\t\tvar children = connections.get(FBX_ID).children;\n\n\t\t\t\tvar parameters = parseParameters(materialNode.properties, textureMap, children);\n\t\t\t\tvar material;\n\n\t\t\t\tswitch (type.toLowerCase()) {\n\t\t\t\t\t\tcase 'phong':\n\t\t\t\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'lambert':\n\t\t\t\t\t\t\t\tmaterial = new THREE.MeshLambertMaterial();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'unknown':\n\t\t\t\t\t\t\t\tmaterial = new THREE.MeshStandardMaterial();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tconsole.warn('THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type);\n\t\t\t\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial({ color: 0x3300ff });\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tmaterial.setValues(parameters);\n\t\t\t\tmaterial.name = name;\n\n\t\t\t\treturn material;\n\t\t}\n\n\t\t// Parse FBX material and return parameters suitable for a three.js material\n\t\t// Also parse the texture map and return any textures associated with the material\n\t\tfunction parseParameters(properties, textureMap, childrenRelationships) {\n\t\t\t\tvar parameters = {};\n\n\t\t\t\tif (properties.BumpFactor) {\n\t\t\t\t\t\tparameters.bumpScale = properties.BumpFactor.value;\n\t\t\t\t}\n\t\t\t\tif (properties.Diffuse) {\n\t\t\t\t\t\tparameters.color = parseColor(properties.Diffuse);\n\t\t\t\t}\n\t\t\t\tif (properties.DisplacementFactor) {\n\t\t\t\t\t\tparameters.displacementScale = properties.DisplacementFactor.value;\n\t\t\t\t}\n\t\t\t\tif (properties.ReflectionFactor) {\n\t\t\t\t\t\tparameters.reflectivity = properties.ReflectionFactor.value;\n\t\t\t\t}\n\t\t\t\tif (properties.Specular) {\n\t\t\t\t\t\tparameters.specular = parseColor(properties.Specular);\n\t\t\t\t}\n\t\t\t\tif (properties.Shininess) {\n\t\t\t\t\t\tparameters.shininess = properties.Shininess.value;\n\t\t\t\t}\n\t\t\t\tif (properties.Emissive) {\n\t\t\t\t\t\tparameters.emissive = parseColor(properties.Emissive);\n\t\t\t\t}\n\t\t\t\tif (properties.EmissiveFactor) {\n\t\t\t\t\t\tparameters.emissiveIntensity = parseFloat(properties.EmissiveFactor.value);\n\t\t\t\t}\n\t\t\t\tif (properties.Opacity) {\n\t\t\t\t\t\tparameters.opacity = parseFloat(properties.Opacity.value);\n\t\t\t\t}\n\t\t\t\tif (parameters.opacity < 1.0) {\n\t\t\t\t\t\tparameters.transparent = true;\n\t\t\t\t}\n\n\t\t\t\t// Maya PBR export\n\t\t\t\t//console.log(properties);\n\n\t\t\t\tif (properties['Maya|base_color']) {\n\t\t\t\t\t\tvar c = properties['Maya|base_color'].value;\n\t\t\t\t\t\tparameters.color = new THREE.Color(c[0], c[1], c[2]);\n\t\t\t\t}\n\t\t\t\tif (properties['Maya|emissive']) {\n\t\t\t\t\t\tvar c = properties['Maya|emissive'];\n\t\t\t\t\t\tparameters.emissive = new THREE.Color(c[0], c[1], c[2]);\n\t\t\t\t}\n\t\t\t\tif (properties['Maya|emissive_intensity']) {\n\t\t\t\t\t\tparameters.emissiveIntensity = properties['Maya|emissive_intensity'].value;\n\t\t\t\t}\n\t\t\t\tif (properties['Maya|metallic']) {\n\t\t\t\t\t\tparameters.metalness = properties['Maya|metallic'].value;\n\t\t\t\t}\n\t\t\t\tif (properties['Maya|roughness']) {\n\t\t\t\t\t\tparameters.roughness = properties['Maya|roughness'].value;\n\t\t\t\t}\n\n\t\t\t\t// UV scale\n\t\t\t\tvar uvScale = 1;\n\t\t\t\tif (properties['Maya|uv_scale']) {\n\t\t\t\t\t\tvar uvScale = properties['Maya|uv_scale'].value;\n\t\t\t\t}\n\n\t\t\t\tfor (var childrenRelationshipsIndex = 0, childrenRelationshipsLength = childrenRelationships.length; childrenRelationshipsIndex < childrenRelationshipsLength; ++childrenRelationshipsIndex) {\n\t\t\t\t\t\tvar relationship = childrenRelationships[childrenRelationshipsIndex];\n\t\t\t\t\t\tvar type = relationship.relationship;\n\n\t\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\t\t\t// Maya PBR material exports\n\t\t\t\t\t\t\t\t//case 'Maya|base_color':\n\t\t\t\t\t\t\t\tcase 'Maya|TEX_color_map':\n\t\t\t\t\t\t\t\t\t\tvar prop = 'Maya|use_color_map';\n\t\t\t\t\t\t\t\t\t\tif (properties[prop] && properties[prop].value == 1) {\n\t\t\t\t\t\t\t\t\t\t\t\tparameters.map = textureMap.get(relationship.ID);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (uvScale != 1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.map.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.map.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.map.repeat.set(uvScale, uvScale);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'Maya|TEX_emissive_map':\n\t\t\t\t\t\t\t\t\t\tvar prop = 'Maya|use_emissive_map';\n\t\t\t\t\t\t\t\t\t\tif (properties[prop] && properties[prop].value == 1) {\n\t\t\t\t\t\t\t\t\t\t\t\tparameters.emissiveMap = textureMap.get(relationship.ID);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (uvScale != 1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.emissiveMap.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.emissiveMap.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.emissiveMap.repeat.set(uvScale, uvScale);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'Maya|TEX_roughness_map':\n\t\t\t\t\t\t\t\t\t\tvar prop = 'Maya|use_roughness_map';\n\t\t\t\t\t\t\t\t\t\tif (properties[prop] && properties[prop].value == 1) {\n\t\t\t\t\t\t\t\t\t\t\t\tparameters.roughnessMap = textureMap.get(relationship.ID);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (uvScale != 1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.roughnessMap.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.roughnessMap.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.roughnessMap.repeat.set(uvScale, uvScale);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'Maya|TEX_normal_map':\n\t\t\t\t\t\t\t\t\t\tvar prop = 'Maya|use_normal_map';\n\t\t\t\t\t\t\t\t\t\tif (properties[prop] && properties[prop].value == 1) {\n\t\t\t\t\t\t\t\t\t\t\t\tparameters.normalMap = textureMap.get(relationship.ID);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (uvScale != 1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.normalMap.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.normalMap.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.normalMap.repeat.set(uvScale, uvScale);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'Maya|TEX_metallic_map':\n\t\t\t\t\t\t\t\t\t\tvar prop = 'Maya|use_metallic_map';\n\t\t\t\t\t\t\t\t\t\tif (properties[prop] && properties[prop].value == 1) {\n\t\t\t\t\t\t\t\t\t\t\t\tparameters.metalnessMap = textureMap.get(relationship.ID);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (uvScale != 1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.metalnessMap.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.metalnessMap.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.metalnessMap.repeat.set(uvScale, uvScale);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'Maya|TEX_ao_map':\n\t\t\t\t\t\t\t\t\t\tvar prop = 'Maya|use_ao_map';\n\t\t\t\t\t\t\t\t\t\tif (properties[prop] && properties[prop].value == 1) {\n\t\t\t\t\t\t\t\t\t\t\t\tparameters.aoMap = textureMap.get(relationship.ID);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (uvScale != 1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.aoMap.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.aoMap.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.aoMap.repeat.set(uvScale, uvScale);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'Maya|TEX_brdf_lut':\n\t\t\t\t\t\t\t\tcase 'Maya|TEX_global_specular_cube':\n\t\t\t\t\t\t\t\tcase 'Maya|TEX_global_diffuse_cube':\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 'Bump':\n\t\t\t\t\t\t\t\t\t\tparameters.bumpMap = textureMap.get(relationship.ID);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'DiffuseColor':\n\t\t\t\t\t\t\t\t\t\tparameters.map = textureMap.get(relationship.ID);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'DisplacementColor':\n\t\t\t\t\t\t\t\t\t\tparameters.displacementMap = textureMap.get(relationship.ID);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'EmissiveColor':\n\t\t\t\t\t\t\t\t\t\tparameters.emissiveMap = textureMap.get(relationship.ID);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'NormalMap':\n\t\t\t\t\t\t\t\t\t\tparameters.normalMap = textureMap.get(relationship.ID);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'ReflectionColor':\n\t\t\t\t\t\t\t\t\t\tparameters.envMap = textureMap.get(relationship.ID);\n\t\t\t\t\t\t\t\t\t\tparameters.envMap.mapping = THREE.EquirectangularReflectionMapping;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'SpecularColor':\n\t\t\t\t\t\t\t\t\t\tparameters.specularMap = textureMap.get(relationship.ID);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'TransparentColor':\n\t\t\t\t\t\t\t\t\t\tparameters.alphaMap = textureMap.get(relationship.ID);\n\t\t\t\t\t\t\t\t\t\tparameters.transparent = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'AmbientColor':\n\t\t\t\t\t\t\t\tcase 'ShininessExponent': // AKA glossiness map\n\t\t\t\t\t\t\t\tcase 'SpecularFactor': // AKA specularLevel\n\t\t\t\t\t\t\t\tcase 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn parameters;\n\t\t}\n\n\t\t// Parse nodes in FBXTree.Objects.subNodes.Deformer\n\t\t// Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n\t\t// Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n\t\tfunction parseDeformers(FBXTree, connections) {\n\n\t\t\t\tvar deformers = {};\n\n\t\t\t\tif ('Deformer' in FBXTree.Objects.subNodes) {\n\n\t\t\t\t\t\tvar DeformerNodes = FBXTree.Objects.subNodes.Deformer;\n\n\t\t\t\t\t\tfor (var nodeID in DeformerNodes) {\n\n\t\t\t\t\t\t\t\tvar deformerNode = DeformerNodes[nodeID];\n\n\t\t\t\t\t\t\t\tif (deformerNode.attrType === 'Skin') {\n\n\t\t\t\t\t\t\t\t\t\tvar conns = connections.get(parseInt(nodeID));\n\t\t\t\t\t\t\t\t\t\tvar skeleton = parseSkeleton(conns, DeformerNodes);\n\t\t\t\t\t\t\t\t\t\tskeleton.FBX_ID = parseInt(nodeID);\n\n\t\t\t\t\t\t\t\t\t\tdeformers[nodeID] = skeleton;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn deformers;\n\t\t}\n\n\t\t// Parse single nodes in FBXTree.Objects.subNodes.Deformer\n\t\t// Generates a \"Skeleton Representation\" of FBX nodes based on an FBX Skin Deformer's connections\n\t\t// and an object containing SubDeformer nodes.\n\t\tfunction parseSkeleton(connections, DeformerNodes) {\n\n\t\t\t\tvar subDeformers = {};\n\t\t\t\tvar children = connections.children;\n\n\t\t\t\tfor (var i = 0, l = children.length; i < l; ++i) {\n\n\t\t\t\t\t\tvar child = children[i];\n\n\t\t\t\t\t\tvar subDeformerNode = DeformerNodes[child.ID];\n\n\t\t\t\t\t\tvar subDeformer = {\n\t\t\t\t\t\t\t\tFBX_ID: child.ID,\n\t\t\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\t\t\tindices: [],\n\t\t\t\t\t\t\t\tweights: [],\n\t\t\t\t\t\t\t\ttransform: new THREE.Matrix4().fromArray(subDeformerNode.subNodes.Transform.properties.a),\n\t\t\t\t\t\t\t\ttransformLink: new THREE.Matrix4().fromArray(subDeformerNode.subNodes.TransformLink.properties.a),\n\t\t\t\t\t\t\t\tlinkMode: subDeformerNode.properties.Mode\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tif ('Indexes' in subDeformerNode.subNodes) {\n\n\t\t\t\t\t\t\t\tsubDeformer.indices = subDeformerNode.subNodes.Indexes.properties.a;\n\t\t\t\t\t\t\t\tsubDeformer.weights = subDeformerNode.subNodes.Weights.properties.a;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsubDeformers[child.ID] = subDeformer;\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\t\tmap: subDeformers,\n\t\t\t\t\t\tbones: []\n\t\t\t\t};\n\t\t}\n\n\t\t// Parse nodes in FBXTree.Objects.subNodes.Geometry\n\t\tfunction parseGeometries(FBXTree, connections, deformers) {\n\n\t\t\t\tvar geometryMap = new Map();\n\n\t\t\t\tif ('Geometry' in FBXTree.Objects.subNodes) {\n\n\t\t\t\t\t\tvar geometryNodes = FBXTree.Objects.subNodes.Geometry;\n\n\t\t\t\t\t\tfor (var nodeID in geometryNodes) {\n\n\t\t\t\t\t\t\t\tvar relationships = connections.get(parseInt(nodeID));\n\t\t\t\t\t\t\t\tvar geo = parseGeometry(geometryNodes[nodeID], relationships, deformers);\n\t\t\t\t\t\t\t\tgeometryMap.set(parseInt(nodeID), geo);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn geometryMap;\n\t\t}\n\n\t\t// Parse single node in FBXTree.Objects.subNodes.Geometry\n\t\tfunction parseGeometry(geometryNode, relationships, deformers) {\n\n\t\t\t\tswitch (geometryNode.attrType) {\n\n\t\t\t\t\t\tcase 'Mesh':\n\t\t\t\t\t\t\t\treturn parseMeshGeometry(geometryNode, relationships, deformers);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'NurbsCurve':\n\t\t\t\t\t\t\t\treturn parseNurbsGeometry(geometryNode);\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t}\n\n\t\t// Parse single node mesh geometry in FBXTree.Objects.subNodes.Geometry\n\t\tfunction parseMeshGeometry(geometryNode, relationships, deformers) {\n\n\t\t\t\tfor (var i = 0; i < relationships.children.length; ++i) {\n\n\t\t\t\t\t\tvar deformer = deformers[relationships.children[i].ID];\n\t\t\t\t\t\tif (deformer !== undefined) break;\n\t\t\t\t}\n\n\t\t\t\treturn genGeometry(geometryNode, deformer);\n\t\t}\n\n\t\t// Generate a THREE.BufferGeometry from a node in FBXTree.Objects.subNodes.Geometry\n\t\tfunction genGeometry(geometryNode, deformer) {\n\n\t\t\t\tvar subNodes = geometryNode.subNodes;\n\n\t\t\t\tvar vertexPositions = subNodes.Vertices.properties.a;\n\t\t\t\tvar vertexIndices = subNodes.PolygonVertexIndex.properties.a;\n\n\t\t\t\t// create arrays to hold the final data used to build the buffergeometry\n\t\t\t\tvar vertexBuffer = [];\n\t\t\t\tvar normalBuffer = [];\n\t\t\t\tvar colorsBuffer = [];\n\t\t\t\tvar uvsBuffer = [];\n\t\t\t\tvar materialIndexBuffer = [];\n\t\t\t\tvar vertexWeightsBuffer = [];\n\t\t\t\tvar weightsIndicesBuffer = [];\n\n\t\t\t\tif (subNodes.LayerElementColor) {\n\n\t\t\t\t\t\tvar colorInfo = getColors(subNodes.LayerElementColor[0]);\n\t\t\t\t}\n\n\t\t\t\tif (subNodes.LayerElementMaterial) {\n\n\t\t\t\t\t\tvar materialInfo = getMaterials(subNodes.LayerElementMaterial[0]);\n\t\t\t\t}\n\n\t\t\t\tif (subNodes.LayerElementNormal) {\n\n\t\t\t\t\t\tvar normalInfo = getNormals(subNodes.LayerElementNormal[0]);\n\t\t\t\t}\n\n\t\t\t\tif (subNodes.LayerElementUV) {\n\n\t\t\t\t\t\tvar uvInfo = [];\n\t\t\t\t\t\tvar i = 0;\n\t\t\t\t\t\twhile (subNodes.LayerElementUV[i]) {\n\n\t\t\t\t\t\t\t\tuvInfo.push(getUVs(subNodes.LayerElementUV[i]));\n\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar weightTable = {};\n\n\t\t\t\tif (deformer) {\n\n\t\t\t\t\t\tvar subDeformers = deformer.map;\n\n\t\t\t\t\t\tfor (var key in subDeformers) {\n\n\t\t\t\t\t\t\t\tvar subDeformer = subDeformers[key];\n\t\t\t\t\t\t\t\tvar indices = subDeformer.indices;\n\n\t\t\t\t\t\t\t\tfor (var j = 0; j < indices.length; j++) {\n\n\t\t\t\t\t\t\t\t\t\tvar index = indices[j];\n\t\t\t\t\t\t\t\t\t\tvar weight = subDeformer.weights[j];\n\n\t\t\t\t\t\t\t\t\t\tif (weightTable[index] === undefined) weightTable[index] = [];\n\n\t\t\t\t\t\t\t\t\t\tweightTable[index].push({\n\t\t\t\t\t\t\t\t\t\t\t\tid: subDeformer.index,\n\t\t\t\t\t\t\t\t\t\t\t\tweight: weight\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar polygonIndex = 0;\n\t\t\t\tvar faceLength = 0;\n\t\t\t\tvar displayedWeightsWarning = false;\n\n\t\t\t\t// these will hold data for a single face\n\t\t\t\tvar vertexPositionIndexes = [];\n\t\t\t\tvar faceNormals = [];\n\t\t\t\tvar faceColors = [];\n\t\t\t\tvar faceUVs = [];\n\t\t\t\tvar faceWeights = [];\n\t\t\t\tvar faceWeightIndices = [];\n\n\t\t\t\tfor (var polygonVertexIndex = 0; polygonVertexIndex < vertexIndices.length; polygonVertexIndex++) {\n\n\t\t\t\t\t\tvar vertexIndex = vertexIndices[polygonVertexIndex];\n\n\t\t\t\t\t\tvar endOfFace = false;\n\n\t\t\t\t\t\t// Face index and vertex index arrays are combined in a single array\n\t\t\t\t\t\t// A cube with quad faces looks like this:\n\t\t\t\t\t\t// PolygonVertexIndex: *24 {\n\t\t\t\t\t\t//  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\n\t\t\t\t\t\t//  }\n\t\t\t\t\t\t// Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\n\t\t\t\t\t\t// to find index of last vertex multiply by -1 and subtract 1: -3 * - 1 - 1 = 2\n\t\t\t\t\t\tif (vertexIndex < 0) {\n\n\t\t\t\t\t\t\t\tvertexIndex = vertexIndex ^ -1; // equivalent to ( x * -1 ) - 1\n\t\t\t\t\t\t\t\tvertexIndices[polygonVertexIndex] = vertexIndex;\n\t\t\t\t\t\t\t\tendOfFace = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar weightIndices = [];\n\t\t\t\t\t\tvar weights = [];\n\n\t\t\t\t\t\tvertexPositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);\n\n\t\t\t\t\t\tif (colorInfo) {\n\n\t\t\t\t\t\t\t\tvar data = getData(polygonVertexIndex, polygonIndex, vertexIndex, colorInfo);\n\n\t\t\t\t\t\t\t\tfaceColors.push(data[0], data[1], data[2]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (deformer) {\n\n\t\t\t\t\t\t\t\tif (weightTable[vertexIndex] !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\tvar array = weightTable[vertexIndex];\n\n\t\t\t\t\t\t\t\t\t\tfor (var j = 0, jl = array.length; j < jl; j++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tweights.push(array[j].weight);\n\t\t\t\t\t\t\t\t\t\t\t\tweightIndices.push(array[j].id);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (weights.length > 4) {\n\n\t\t\t\t\t\t\t\t\t\tif (!displayedWeightsWarning) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.');\n\t\t\t\t\t\t\t\t\t\t\t\tdisplayedWeightsWarning = true;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tvar WIndex = [0, 0, 0, 0];\n\t\t\t\t\t\t\t\t\t\tvar Weight = [0, 0, 0, 0];\n\n\t\t\t\t\t\t\t\t\t\tweights.forEach(function (weight, weightIndex) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar currentWeight = weight;\n\t\t\t\t\t\t\t\t\t\t\t\tvar currentIndex = weightIndices[weightIndex];\n\n\t\t\t\t\t\t\t\t\t\t\t\tWeight.forEach(function (comparedWeight, comparedWeightIndex, comparedWeightArray) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (currentWeight > comparedWeight) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcomparedWeightArray[comparedWeightIndex] = currentWeight;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentWeight = comparedWeight;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar tmp = WIndex[comparedWeightIndex];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tWIndex[comparedWeightIndex] = currentIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentIndex = tmp;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\tweightIndices = WIndex;\n\t\t\t\t\t\t\t\t\t\tweights = Weight;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// if the weight array is shorter than 4 pad with 0s\n\t\t\t\t\t\t\t\tfor (var i = weights.length; i < 4; ++i) {\n\n\t\t\t\t\t\t\t\t\t\tweights[i] = 0;\n\t\t\t\t\t\t\t\t\t\tweightIndices[i] = 0;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tfor (var i = 0; i < 4; ++i) {\n\n\t\t\t\t\t\t\t\t\t\tfaceWeights.push(weights[i]);\n\t\t\t\t\t\t\t\t\t\tfaceWeightIndices.push(weightIndices[i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (normalInfo) {\n\n\t\t\t\t\t\t\t\tvar data = getData(polygonVertexIndex, polygonIndex, vertexIndex, normalInfo);\n\n\t\t\t\t\t\t\t\tfaceNormals.push(data[0], data[1], data[2]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (uvInfo) {\n\n\t\t\t\t\t\t\t\tfor (var i = 0; i < uvInfo.length; i++) {\n\n\t\t\t\t\t\t\t\t\t\tvar data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uvInfo[i]);\n\n\t\t\t\t\t\t\t\t\t\tif (faceUVs[i] === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tfaceUVs[i] = [];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tfaceUVs[i].push(data[0], data[1]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfaceLength++;\n\n\t\t\t\t\t\t// we have reached the end of a face - it may have 4 sides though\n\t\t\t\t\t\t// in which case the data is split into to represent 3 sides faces\n\t\t\t\t\t\tif (endOfFace) {\n\n\t\t\t\t\t\t\t\tfor (var i = 2; i < faceLength; i++) {\n\n\t\t\t\t\t\t\t\t\t\tvertexBuffer.push(vertexPositions[vertexPositionIndexes[0]]);\n\t\t\t\t\t\t\t\t\t\tvertexBuffer.push(vertexPositions[vertexPositionIndexes[1]]);\n\t\t\t\t\t\t\t\t\t\tvertexBuffer.push(vertexPositions[vertexPositionIndexes[2]]);\n\n\t\t\t\t\t\t\t\t\t\tvertexBuffer.push(vertexPositions[vertexPositionIndexes[(i - 1) * 3]]);\n\t\t\t\t\t\t\t\t\t\tvertexBuffer.push(vertexPositions[vertexPositionIndexes[(i - 1) * 3 + 1]]);\n\t\t\t\t\t\t\t\t\t\tvertexBuffer.push(vertexPositions[vertexPositionIndexes[(i - 1) * 3 + 2]]);\n\n\t\t\t\t\t\t\t\t\t\tvertexBuffer.push(vertexPositions[vertexPositionIndexes[i * 3]]);\n\t\t\t\t\t\t\t\t\t\tvertexBuffer.push(vertexPositions[vertexPositionIndexes[i * 3 + 1]]);\n\t\t\t\t\t\t\t\t\t\tvertexBuffer.push(vertexPositions[vertexPositionIndexes[i * 3 + 2]]);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (deformer) {\n\n\t\t\t\t\t\t\t\t\t\tfor (var i = 2; i < faceLength; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvertexWeightsBuffer.push(faceWeights[0]);\n\t\t\t\t\t\t\t\t\t\t\t\tvertexWeightsBuffer.push(faceWeights[1]);\n\t\t\t\t\t\t\t\t\t\t\t\tvertexWeightsBuffer.push(faceWeights[2]);\n\t\t\t\t\t\t\t\t\t\t\t\tvertexWeightsBuffer.push(faceWeights[3]);\n\n\t\t\t\t\t\t\t\t\t\t\t\tvertexWeightsBuffer.push(faceWeights[(i - 1) * 4]);\n\t\t\t\t\t\t\t\t\t\t\t\tvertexWeightsBuffer.push(faceWeights[(i - 1) * 4 + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\tvertexWeightsBuffer.push(faceWeights[(i - 1) * 4 + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\tvertexWeightsBuffer.push(faceWeights[(i - 1) * 4 + 3]);\n\n\t\t\t\t\t\t\t\t\t\t\t\tvertexWeightsBuffer.push(faceWeights[i * 4]);\n\t\t\t\t\t\t\t\t\t\t\t\tvertexWeightsBuffer.push(faceWeights[i * 4 + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\tvertexWeightsBuffer.push(faceWeights[i * 4 + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\tvertexWeightsBuffer.push(faceWeights[i * 4 + 3]);\n\n\t\t\t\t\t\t\t\t\t\t\t\tweightsIndicesBuffer.push(faceWeightIndices[0]);\n\t\t\t\t\t\t\t\t\t\t\t\tweightsIndicesBuffer.push(faceWeightIndices[1]);\n\t\t\t\t\t\t\t\t\t\t\t\tweightsIndicesBuffer.push(faceWeightIndices[2]);\n\t\t\t\t\t\t\t\t\t\t\t\tweightsIndicesBuffer.push(faceWeightIndices[3]);\n\n\t\t\t\t\t\t\t\t\t\t\t\tweightsIndicesBuffer.push(faceWeightIndices[(i - 1) * 4]);\n\t\t\t\t\t\t\t\t\t\t\t\tweightsIndicesBuffer.push(faceWeightIndices[(i - 1) * 4 + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\tweightsIndicesBuffer.push(faceWeightIndices[(i - 1) * 4 + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\tweightsIndicesBuffer.push(faceWeightIndices[(i - 1) * 4 + 3]);\n\n\t\t\t\t\t\t\t\t\t\t\t\tweightsIndicesBuffer.push(faceWeightIndices[i * 4]);\n\t\t\t\t\t\t\t\t\t\t\t\tweightsIndicesBuffer.push(faceWeightIndices[i * 4 + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\tweightsIndicesBuffer.push(faceWeightIndices[i * 4 + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\tweightsIndicesBuffer.push(faceWeightIndices[i * 4 + 3]);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (normalInfo) {\n\n\t\t\t\t\t\t\t\t\t\tfor (var i = 2; i < faceLength; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tnormalBuffer.push(faceNormals[0]);\n\t\t\t\t\t\t\t\t\t\t\t\tnormalBuffer.push(faceNormals[1]);\n\t\t\t\t\t\t\t\t\t\t\t\tnormalBuffer.push(faceNormals[2]);\n\n\t\t\t\t\t\t\t\t\t\t\t\tnormalBuffer.push(faceNormals[(i - 1) * 3]);\n\t\t\t\t\t\t\t\t\t\t\t\tnormalBuffer.push(faceNormals[(i - 1) * 3 + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\tnormalBuffer.push(faceNormals[(i - 1) * 3 + 2]);\n\n\t\t\t\t\t\t\t\t\t\t\t\tnormalBuffer.push(faceNormals[i * 3]);\n\t\t\t\t\t\t\t\t\t\t\t\tnormalBuffer.push(faceNormals[i * 3 + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\tnormalBuffer.push(faceNormals[i * 3 + 2]);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (uvInfo) {\n\n\t\t\t\t\t\t\t\t\t\tfor (var j = 0; j < uvInfo.length; j++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (uvsBuffer[j] === undefined) uvsBuffer[j] = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 2; i < faceLength; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tuvsBuffer[j].push(faceUVs[j][0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tuvsBuffer[j].push(faceUVs[j][1]);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tuvsBuffer[j].push(faceUVs[j][(i - 1) * 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tuvsBuffer[j].push(faceUVs[j][(i - 1) * 2 + 1]);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tuvsBuffer[j].push(faceUVs[j][i * 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tuvsBuffer[j].push(faceUVs[j][i * 2 + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (colorInfo) {\n\n\t\t\t\t\t\t\t\t\t\tfor (var i = 2; i < faceLength; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tcolorsBuffer.push(faceColors[0]);\n\t\t\t\t\t\t\t\t\t\t\t\tcolorsBuffer.push(faceColors[1]);\n\t\t\t\t\t\t\t\t\t\t\t\tcolorsBuffer.push(faceColors[2]);\n\n\t\t\t\t\t\t\t\t\t\t\t\tcolorsBuffer.push(faceColors[(i - 1) * 3]);\n\t\t\t\t\t\t\t\t\t\t\t\tcolorsBuffer.push(faceColors[(i - 1) * 3 + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\tcolorsBuffer.push(faceColors[(i - 1) * 3 + 2]);\n\n\t\t\t\t\t\t\t\t\t\t\t\tcolorsBuffer.push(faceColors[i * 3]);\n\t\t\t\t\t\t\t\t\t\t\t\tcolorsBuffer.push(faceColors[i * 3 + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\tcolorsBuffer.push(faceColors[i * 3 + 2]);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (materialInfo && materialInfo.mappingType !== 'AllSame') {\n\n\t\t\t\t\t\t\t\t\t\tvar materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, materialInfo)[0];\n\n\t\t\t\t\t\t\t\t\t\tfor (var i = 2; i < faceLength; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tmaterialIndexBuffer.push(materialIndex);\n\t\t\t\t\t\t\t\t\t\t\t\tmaterialIndexBuffer.push(materialIndex);\n\t\t\t\t\t\t\t\t\t\t\t\tmaterialIndexBuffer.push(materialIndex);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tpolygonIndex++;\n\n\t\t\t\t\t\t\t\tendOfFace = false;\n\t\t\t\t\t\t\t\tfaceLength = 0;\n\n\t\t\t\t\t\t\t\t// reset arrays for the next face\n\t\t\t\t\t\t\t\tvertexPositionIndexes = [];\n\t\t\t\t\t\t\t\tfaceNormals = [];\n\t\t\t\t\t\t\t\tfaceColors = [];\n\t\t\t\t\t\t\t\tfaceUVs = [];\n\t\t\t\t\t\t\t\tfaceWeights = [];\n\t\t\t\t\t\t\t\tfaceWeightIndices = [];\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar geo = new THREE.BufferGeometry();\n\t\t\t\tgeo.name = geometryNode.name;\n\n\t\t\t\tgeo.addAttribute('position', new THREE.Float32BufferAttribute(vertexBuffer, 3));\n\n\t\t\t\tif (colorsBuffer.length > 0) {\n\n\t\t\t\t\t\tgeo.addAttribute('color', new THREE.Float32BufferAttribute(colorsBuffer, 3));\n\t\t\t\t}\n\n\t\t\t\tif (deformer) {\n\n\t\t\t\t\t\tgeo.addAttribute('skinIndex', new THREE.Float32BufferAttribute(weightsIndicesBuffer, 4));\n\n\t\t\t\t\t\tgeo.addAttribute('skinWeight', new THREE.Float32BufferAttribute(vertexWeightsBuffer, 4));\n\n\t\t\t\t\t\t// used later to bind the skeleton to the model\n\t\t\t\t\t\tgeo.FBX_Deformer = deformer;\n\t\t\t\t}\n\n\t\t\t\tif (normalBuffer.length > 0) {\n\n\t\t\t\t\t\tgeo.addAttribute('normal', new THREE.Float32BufferAttribute(normalBuffer, 3));\n\t\t\t\t}\n\t\t\t\tif (uvsBuffer.length > 0) {\n\n\t\t\t\t\t\tfor (var i = 0; i < uvsBuffer.length; i++) {\n\n\t\t\t\t\t\t\t\tvar name = 'uv' + (i + 1).toString();\n\t\t\t\t\t\t\t\tif (i == 0) {\n\n\t\t\t\t\t\t\t\t\t\tname = 'uv';\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tgeo.addAttribute(name, new THREE.Float32BufferAttribute(uvsBuffer[i], 2));\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (materialInfo && materialInfo.mappingType !== 'AllSame') {\n\n\t\t\t\t\t\t// Convert the material indices of each vertex into rendering groups on the geometry.\n\t\t\t\t\t\tvar prevMaterialIndex = materialIndexBuffer[0];\n\t\t\t\t\t\tvar startIndex = 0;\n\n\t\t\t\t\t\tfor (var i = 0; i < materialIndexBuffer.length; ++i) {\n\n\t\t\t\t\t\t\t\tif (materialIndexBuffer[i] !== prevMaterialIndex) {\n\n\t\t\t\t\t\t\t\t\t\tgeo.addGroup(startIndex, i - startIndex, prevMaterialIndex);\n\n\t\t\t\t\t\t\t\t\t\tprevMaterialIndex = materialIndexBuffer[i];\n\t\t\t\t\t\t\t\t\t\tstartIndex = i;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// the loop above doesn't add the last group, do that here.\n\t\t\t\t\t\tif (geo.groups.length > 0) {\n\n\t\t\t\t\t\t\t\tvar lastGroup = geo.groups[geo.groups.length - 1];\n\t\t\t\t\t\t\t\tvar lastIndex = lastGroup.start + lastGroup.count;\n\n\t\t\t\t\t\t\t\tif (lastIndex !== materialIndexBuffer.length) {\n\n\t\t\t\t\t\t\t\t\t\tgeo.addGroup(lastIndex, materialIndexBuffer.length - lastIndex, prevMaterialIndex);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// case where there are multiple materials but the whole geometry is only\n\t\t\t\t\t\t// using one of them\n\t\t\t\t\t\tif (geo.groups.length === 0) {\n\n\t\t\t\t\t\t\t\tgeo.addGroup(0, materialIndexBuffer.length, materialIndexBuffer[0]);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn geo;\n\t\t}\n\n\t\t// Parse normal from FBXTree.Objects.subNodes.Geometry.subNodes.LayerElementNormal if it exists\n\t\tfunction getNormals(NormalNode) {\n\n\t\t\t\tvar mappingType = NormalNode.properties.MappingInformationType;\n\t\t\t\tvar referenceType = NormalNode.properties.ReferenceInformationType;\n\t\t\t\tvar buffer = NormalNode.subNodes.Normals.properties.a;\n\t\t\t\tvar indexBuffer = [];\n\t\t\t\tif (referenceType === 'IndexToDirect') {\n\n\t\t\t\t\t\tif ('NormalIndex' in NormalNode.subNodes) {\n\n\t\t\t\t\t\t\t\tindexBuffer = NormalNode.subNodes.NormalIndex.properties.a;\n\t\t\t\t\t\t} else if ('NormalsIndex' in NormalNode.subNodes) {\n\n\t\t\t\t\t\t\t\tindexBuffer = NormalNode.subNodes.NormalsIndex.properties.a;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\t\tdataSize: 3,\n\t\t\t\t\t\tbuffer: buffer,\n\t\t\t\t\t\tindices: indexBuffer,\n\t\t\t\t\t\tmappingType: mappingType,\n\t\t\t\t\t\treferenceType: referenceType\n\t\t\t\t};\n\t\t}\n\n\t\t// Parse UVs from FBXTree.Objects.subNodes.Geometry.subNodes.LayerElementUV if it exists\n\t\tfunction getUVs(UVNode) {\n\n\t\t\t\tvar mappingType = UVNode.properties.MappingInformationType;\n\t\t\t\tvar referenceType = UVNode.properties.ReferenceInformationType;\n\t\t\t\tvar buffer = UVNode.subNodes.UV.properties.a;\n\t\t\t\tvar indexBuffer = [];\n\t\t\t\tif (referenceType === 'IndexToDirect') {\n\n\t\t\t\t\t\tindexBuffer = UVNode.subNodes.UVIndex.properties.a;\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\t\tdataSize: 2,\n\t\t\t\t\t\tbuffer: buffer,\n\t\t\t\t\t\tindices: indexBuffer,\n\t\t\t\t\t\tmappingType: mappingType,\n\t\t\t\t\t\treferenceType: referenceType\n\t\t\t\t};\n\t\t}\n\n\t\t// Parse Vertex Colors from FBXTree.Objects.subNodes.Geometry.subNodes.LayerElementColor if it exists\n\t\tfunction getColors(ColorNode) {\n\n\t\t\t\tvar mappingType = ColorNode.properties.MappingInformationType;\n\t\t\t\tvar referenceType = ColorNode.properties.ReferenceInformationType;\n\t\t\t\tvar buffer = ColorNode.subNodes.Colors.properties.a;\n\t\t\t\tvar indexBuffer = [];\n\t\t\t\tif (referenceType === 'IndexToDirect') {\n\n\t\t\t\t\t\tindexBuffer = ColorNode.subNodes.ColorIndex.properties.a;\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\t\tdataSize: 4,\n\t\t\t\t\t\tbuffer: buffer,\n\t\t\t\t\t\tindices: indexBuffer,\n\t\t\t\t\t\tmappingType: mappingType,\n\t\t\t\t\t\treferenceType: referenceType\n\t\t\t\t};\n\t\t}\n\n\t\t// Parse mapping and material data in FBXTree.Objects.subNodes.Geometry.subNodes.LayerElementMaterial if it exists\n\t\tfunction getMaterials(MaterialNode) {\n\n\t\t\t\tvar mappingType = MaterialNode.properties.MappingInformationType;\n\t\t\t\tvar referenceType = MaterialNode.properties.ReferenceInformationType;\n\n\t\t\t\tif (mappingType === 'NoMappingInformation') {\n\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tdataSize: 1,\n\t\t\t\t\t\t\t\tbuffer: [0],\n\t\t\t\t\t\t\t\tindices: [0],\n\t\t\t\t\t\t\t\tmappingType: 'AllSame',\n\t\t\t\t\t\t\t\treferenceType: referenceType\n\t\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tvar materialIndexBuffer = MaterialNode.subNodes.Materials.properties.a;\n\n\t\t\t\t// Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n\t\t\t\t// we expect.So we create an intermediate buffer that points to the index in the buffer,\n\t\t\t\t// for conforming with the other functions we've written for other data.\n\t\t\t\tvar materialIndices = [];\n\n\t\t\t\tfor (var materialIndexBufferIndex = 0, materialIndexBufferLength = materialIndexBuffer.length; materialIndexBufferIndex < materialIndexBufferLength; ++materialIndexBufferIndex) {\n\n\t\t\t\t\t\tmaterialIndices.push(materialIndexBufferIndex);\n\t\t\t\t}\n\n\t\t\t\treturn {\n\t\t\t\t\t\tdataSize: 1,\n\t\t\t\t\t\tbuffer: materialIndexBuffer,\n\t\t\t\t\t\tindices: materialIndices,\n\t\t\t\t\t\tmappingType: mappingType,\n\t\t\t\t\t\treferenceType: referenceType\n\t\t\t\t};\n\t\t}\n\n\t\t// Functions use the infoObject and given indices to return value array of geometry.\n\t\t// infoObject can be materialInfo, normalInfo, UVInfo or colorInfo\n\t\t// polygonVertexIndex - Index of vertex in draw order (which index of the index buffer refers to this vertex).\n\t\t// polygonIndex - Index of polygon in geometry.\n\t\t// vertexIndex - Index of vertex inside vertex buffer (used because some data refers to old index buffer that we don't use anymore).\n\t\tvar dataArray = [];\n\n\t\tvar GetData = {\n\n\t\t\t\tByPolygonVertex: {\n\n\t\t\t\t\t\tDirect: function (polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n\n\t\t\t\t\t\t\t\tvar from = polygonVertexIndex * infoObject.dataSize;\n\t\t\t\t\t\t\t\tvar to = polygonVertexIndex * infoObject.dataSize + infoObject.dataSize;\n\n\t\t\t\t\t\t\t\t// return infoObject.buffer.slice( from, to );\n\t\t\t\t\t\t\t\treturn slice(dataArray, infoObject.buffer, from, to);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tIndexToDirect: function (polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n\n\t\t\t\t\t\t\t\tvar index = infoObject.indices[polygonVertexIndex];\n\t\t\t\t\t\t\t\tvar from = index * infoObject.dataSize;\n\t\t\t\t\t\t\t\tvar to = index * infoObject.dataSize + infoObject.dataSize;\n\n\t\t\t\t\t\t\t\t// return infoObject.buffer.slice( from, to );\n\t\t\t\t\t\t\t\treturn slice(dataArray, infoObject.buffer, from, to);\n\t\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tByPolygon: {\n\n\t\t\t\t\t\tDirect: function (polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n\n\t\t\t\t\t\t\t\tvar from = polygonIndex * infoObject.dataSize;\n\t\t\t\t\t\t\t\tvar to = polygonIndex * infoObject.dataSize + infoObject.dataSize;\n\n\t\t\t\t\t\t\t\t// return infoObject.buffer.slice( from, to );\n\t\t\t\t\t\t\t\treturn slice(dataArray, infoObject.buffer, from, to);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tIndexToDirect: function (polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n\n\t\t\t\t\t\t\t\tvar index = infoObject.indices[polygonIndex];\n\t\t\t\t\t\t\t\tvar from = index * infoObject.dataSize;\n\t\t\t\t\t\t\t\tvar to = index * infoObject.dataSize + infoObject.dataSize;\n\n\t\t\t\t\t\t\t\t// return infoObject.buffer.slice( from, to );\n\t\t\t\t\t\t\t\treturn slice(dataArray, infoObject.buffer, from, to);\n\t\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tByVertice: {\n\n\t\t\t\t\t\tDirect: function (polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n\n\t\t\t\t\t\t\t\tvar from = vertexIndex * infoObject.dataSize;\n\t\t\t\t\t\t\t\tvar to = vertexIndex * infoObject.dataSize + infoObject.dataSize;\n\n\t\t\t\t\t\t\t\t// return infoObject.buffer.slice( from, to );\n\t\t\t\t\t\t\t\treturn slice(dataArray, infoObject.buffer, from, to);\n\t\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tAllSame: {\n\n\t\t\t\t\t\tIndexToDirect: function (polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n\n\t\t\t\t\t\t\t\tvar from = infoObject.indices[0] * infoObject.dataSize;\n\t\t\t\t\t\t\t\tvar to = infoObject.indices[0] * infoObject.dataSize + infoObject.dataSize;\n\n\t\t\t\t\t\t\t\t// return infoObject.buffer.slice( from, to );\n\t\t\t\t\t\t\t\treturn slice(dataArray, infoObject.buffer, from, to);\n\t\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t};\n\n\t\tfunction getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n\n\t\t\t\treturn GetData[infoObject.mappingType][infoObject.referenceType](polygonVertexIndex, polygonIndex, vertexIndex, infoObject);\n\t\t}\n\n\t\t// Generate a NurbGeometry from a node in FBXTree.Objects.subNodes.Geometry\n\t\tfunction parseNurbsGeometry(geometryNode) {\n\n\t\t\t\tif (THREE.NURBSCurve === undefined) {\n\n\t\t\t\t\t\tconsole.error('THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.');\n\t\t\t\t\t\treturn new THREE.BufferGeometry();\n\t\t\t\t}\n\n\t\t\t\tvar order = parseInt(geometryNode.properties.Order);\n\n\t\t\t\tif (isNaN(order)) {\n\n\t\t\t\t\t\tconsole.error('THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geometryNode.properties.Order, geometryNode.id);\n\t\t\t\t\t\treturn new THREE.BufferGeometry();\n\t\t\t\t}\n\n\t\t\t\tvar degree = order - 1;\n\n\t\t\t\tvar knots = geometryNode.subNodes.KnotVector.properties.a;\n\t\t\t\tvar controlPoints = [];\n\t\t\t\tvar pointsValues = geometryNode.subNodes.Points.properties.a;\n\n\t\t\t\tfor (var i = 0, l = pointsValues.length; i < l; i += 4) {\n\n\t\t\t\t\t\tcontrolPoints.push(new THREE.Vector4().fromArray(pointsValues, i));\n\t\t\t\t}\n\n\t\t\t\tvar startKnot, endKnot;\n\n\t\t\t\tif (geometryNode.properties.Form === 'Closed') {\n\n\t\t\t\t\t\tcontrolPoints.push(controlPoints[0]);\n\t\t\t\t} else if (geometryNode.properties.Form === 'Periodic') {\n\n\t\t\t\t\t\tstartKnot = degree;\n\t\t\t\t\t\tendKnot = knots.length - 1 - startKnot;\n\n\t\t\t\t\t\tfor (var i = 0; i < degree; ++i) {\n\n\t\t\t\t\t\t\t\tcontrolPoints.push(controlPoints[i]);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar curve = new THREE.NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);\n\t\t\t\tvar vertices = curve.getPoints(controlPoints.length * 7);\n\n\t\t\t\tvar positions = new Float32Array(vertices.length * 3);\n\n\t\t\t\tfor (var i = 0, l = vertices.length; i < l; ++i) {\n\n\t\t\t\t\t\tvertices[i].toArray(positions, i * 3);\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\tgeometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));\n\n\t\t\t\treturn geometry;\n\t\t}\n\n\t\t// parse nodes in FBXTree.Objects.subNodes.Model and generate a THREE.Group\n\t\tfunction parseScene(FBXTree, connections, deformers, geometryMap, materialMap) {\n\n\t\t\t\tvar sceneGraph = new THREE.Group();\n\n\t\t\t\tvar ModelNode = FBXTree.Objects.subNodes.Model;\n\n\t\t\t\tvar modelArray = [];\n\n\t\t\t\tvar modelMap = new Map();\n\n\t\t\t\tfor (var nodeID in ModelNode) {\n\n\t\t\t\t\t\tvar id = parseInt(nodeID);\n\t\t\t\t\t\tvar node = ModelNode[nodeID];\n\t\t\t\t\t\tvar conns = connections.get(id);\n\t\t\t\t\t\tvar model = null;\n\n\t\t\t\t\t\tfor (var i = 0; i < conns.parents.length; ++i) {\n\n\t\t\t\t\t\t\t\tfor (var FBX_ID in deformers) {\n\n\t\t\t\t\t\t\t\t\t\tvar deformer = deformers[FBX_ID];\n\t\t\t\t\t\t\t\t\t\tvar subDeformers = deformer.map;\n\t\t\t\t\t\t\t\t\t\tvar subDeformer = subDeformers[conns.parents[i].ID];\n\n\t\t\t\t\t\t\t\t\t\tif (subDeformer) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar model2 = model;\n\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.Bone();\n\t\t\t\t\t\t\t\t\t\t\t\tdeformer.bones[subDeformer.index] = model;\n\n\t\t\t\t\t\t\t\t\t\t\t\t// seems like we need this not to make non-connected bone, maybe?\n\t\t\t\t\t\t\t\t\t\t\t\t// TODO: confirm\n\t\t\t\t\t\t\t\t\t\t\t\tif (model2 !== null) model.add(model2);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!model) {\n\n\t\t\t\t\t\t\t\tswitch (node.attrType) {\n\n\t\t\t\t\t\t\t\t\t\t// create a THREE.PerspectiveCamera or THREE.OrthographicCamera\n\t\t\t\t\t\t\t\t\t\tcase 'Camera':\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar cameraAttribute;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var childrenIndex = 0, childrenLength = conns.children.length; childrenIndex < childrenLength; ++childrenIndex) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar childID = conns.children[childrenIndex].ID;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar attr = FBXTree.Objects.subNodes.NodeAttribute[childID];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (attr !== undefined && attr.properties !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcameraAttribute = attr.properties;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (cameraAttribute === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.Object3D();\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar type = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar nearClippingPlane = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (cameraAttribute.NearPlane !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnearClippingPlane = cameraAttribute.NearPlane.value / 1000;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar farClippingPlane = 1000;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (cameraAttribute.FarPlane !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfarClippingPlane = cameraAttribute.FarPlane.value / 1000;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar width = window.innerWidth;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar height = window.innerHeight;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twidth = cameraAttribute.AspectWidth.value;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\theight = cameraAttribute.AspectHeight.value;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar aspect = width / height;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar fov = 45;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (cameraAttribute.FieldOfView !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfov = cameraAttribute.FieldOfView.value;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tswitch (type) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Perspective\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Orthographic\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.FBXLoader: Unknown camera type ' + type + '.');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.Object3D();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t// Create a THREE.DirectionalLight, THREE.PointLight or THREE.SpotLight\n\t\t\t\t\t\t\t\t\t\tcase 'Light':\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar lightAttribute;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var childrenIndex = 0, childrenLength = conns.children.length; childrenIndex < childrenLength; ++childrenIndex) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar childID = conns.children[childrenIndex].ID;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar attr = FBXTree.Objects.subNodes.NodeAttribute[childID];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (attr !== undefined && attr.properties !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlightAttribute = attr.properties;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (lightAttribute === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.Object3D();\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar type;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// LightType can be undefined for Point lights\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (lightAttribute.LightType === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype = lightAttribute.LightType.value;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar color = 0xffffff;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (lightAttribute.Color !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolor = parseColor(lightAttribute.Color.value);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar intensity = lightAttribute.Intensity === undefined ? 1 : lightAttribute.Intensity.value / 100;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// light disabled\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tintensity = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar distance = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (lightAttribute.FarAttenuationEnd !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdistance = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdistance = lightAttribute.FarAttenuationEnd.value / 1000;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar decay = 1;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tswitch (type) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Point\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.PointLight(color, intensity, distance, decay);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Directional\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.DirectionalLight(color, intensity);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Spot\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar angle = Math.PI / 3;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (lightAttribute.InnerAngle !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tangle = THREE.Math.degToRad(lightAttribute.InnerAngle.value);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar penumbra = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (lightAttribute.OuterAngle !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// TODO: this is not correct - FBX calculates outer and inner angle in degrees\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// with OuterAngle > InnerAngle && OuterAngle <= Math.PI\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// while three.js uses a penumbra between (0, 1) to attenuate the inner angle\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpenumbra = THREE.Math.degToRad(lightAttribute.OuterAngle.value);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpenumbra = Math.max(penumbra, 1);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.SpotLight(color, intensity, distance, angle, penumbra, decay);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a THREE.PointLight.');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.PointLight(color, intensity);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel.castShadow = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'Mesh':\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar geometry = null;\n\t\t\t\t\t\t\t\t\t\t\t\tvar material = null;\n\t\t\t\t\t\t\t\t\t\t\t\tvar materials = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var childrenIndex = 0, childrenLength = conns.children.length; childrenIndex < childrenLength; ++childrenIndex) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar child = conns.children[childrenIndex];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (geometryMap.has(child.ID)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgeometry = geometryMap.get(child.ID);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (materialMap.has(child.ID)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterials.push(materialMap.get(child.ID));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif (materials.length > 1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial = materials;\n\t\t\t\t\t\t\t\t\t\t\t\t} else if (materials.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial = materials[0];\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc });\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterials.push(material);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif ('color' in geometry.attributes) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var materialIndex = 0, numMaterials = materials.length; materialIndex < numMaterials; ++materialIndex) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterials[materialIndex].vertexColors = THREE.VertexColors;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif (geometry.FBX_Deformer) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var materialsIndex = 0, materialsLength = materials.length; materialsIndex < materialsLength; ++materialsIndex) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterials[materialsIndex].skinning = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.SkinnedMesh(geometry, material);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.Mesh(geometry, material);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'NurbsCurve':\n\t\t\t\t\t\t\t\t\t\t\t\tvar geometry = null;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var childrenIndex = 0, childrenLength = conns.children.length; childrenIndex < childrenLength; ++childrenIndex) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar child = conns.children[childrenIndex];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (geometryMap.has(child.ID)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgeometry = geometryMap.get(child.ID);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n\t\t\t\t\t\t\t\t\t\t\t\tmaterial = new THREE.LineBasicMaterial({ color: 0x3300ff, linewidth: 5 });\n\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.Line(geometry, material);\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.Group();\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmodel.name = THREE.PropertyBinding.sanitizeNodeName(node.attrName);\n\t\t\t\t\t\tmodel.FBX_ID = id;\n\n\t\t\t\t\t\tmodelArray.push(model);\n\t\t\t\t\t\tmodelMap.set(id, model);\n\t\t\t\t}\n\n\t\t\t\tfor (var modelArrayIndex = 0, modelArrayLength = modelArray.length; modelArrayIndex < modelArrayLength; ++modelArrayIndex) {\n\n\t\t\t\t\t\tvar model = modelArray[modelArrayIndex];\n\n\t\t\t\t\t\tvar node = ModelNode[model.FBX_ID];\n\n\t\t\t\t\t\tif ('Lcl_Translation' in node.properties) {\n\n\t\t\t\t\t\t\t\tmodel.position.fromArray(node.properties.Lcl_Translation.value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ('Lcl_Rotation' in node.properties) {\n\n\t\t\t\t\t\t\t\tvar rotation = node.properties.Lcl_Rotation.value.map(THREE.Math.degToRad);\n\t\t\t\t\t\t\t\trotation.push('ZYX');\n\t\t\t\t\t\t\t\tmodel.rotation.fromArray(rotation);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ('Lcl_Scaling' in node.properties) {\n\n\t\t\t\t\t\t\t\tmodel.scale.fromArray(node.properties.Lcl_Scaling.value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ('PreRotation' in node.properties) {\n\n\t\t\t\t\t\t\t\tvar array = node.properties.PreRotation.value.map(THREE.Math.degToRad);\n\t\t\t\t\t\t\t\tarray[3] = 'ZYX';\n\n\t\t\t\t\t\t\t\tvar preRotations = new THREE.Euler().fromArray(array);\n\n\t\t\t\t\t\t\t\tpreRotations = new THREE.Quaternion().setFromEuler(preRotations);\n\t\t\t\t\t\t\t\tvar currentRotation = new THREE.Quaternion().setFromEuler(model.rotation);\n\t\t\t\t\t\t\t\tpreRotations.multiply(currentRotation);\n\t\t\t\t\t\t\t\tmodel.rotation.setFromQuaternion(preRotations, 'ZYX');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// allow transformed pivots - see https://github.com/mrdoob/three.js/issues/11895\n\t\t\t\t\t\tif ('GeometricTranslation' in node.properties) {\n\n\t\t\t\t\t\t\t\tvar array = node.properties.GeometricTranslation.value;\n\n\t\t\t\t\t\t\t\tmodel.traverse(function (child) {\n\n\t\t\t\t\t\t\t\t\t\tif (child.geometry) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tchild.geometry.translate(array[0], array[1], array[2]);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ('LookAtProperty' in node.properties) {\n\n\t\t\t\t\t\t\t\tvar conns = connections.get(model.FBX_ID);\n\n\t\t\t\t\t\t\t\tfor (var childrenIndex = 0, childrenLength = conns.children.length; childrenIndex < childrenLength; ++childrenIndex) {\n\n\t\t\t\t\t\t\t\t\t\tvar child = conns.children[childrenIndex];\n\n\t\t\t\t\t\t\t\t\t\tif (child.relationship === 'LookAtProperty') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar lookAtTarget = FBXTree.Objects.subNodes.Model[child.ID];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ('Lcl_Translation' in lookAtTarget.properties) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar pos = lookAtTarget.properties.Lcl_Translation.value;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// DirectionalLight, SpotLight\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (model.target !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel.target.position.set(pos[0], pos[1], pos[2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsceneGraph.add(model.target);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Cameras and other Object3Ds\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel.lookAt(new THREE.Vector3(pos[0], pos[1], pos[2]));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar conns = connections.get(model.FBX_ID);\n\t\t\t\t\t\tfor (var parentIndex = 0; parentIndex < conns.parents.length; parentIndex++) {\n\n\t\t\t\t\t\t\t\tvar pIndex = findIndex(modelArray, function (mod) {\n\n\t\t\t\t\t\t\t\t\t\treturn mod.FBX_ID === conns.parents[parentIndex].ID;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tif (pIndex > -1) {\n\n\t\t\t\t\t\t\t\t\t\tmodelArray[pIndex].add(model);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (model.parent === null) {\n\n\t\t\t\t\t\t\t\tsceneGraph.add(model);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Now with the bones created, we can update the skeletons and bind them to the skinned meshes.\n\t\t\t\tsceneGraph.updateMatrixWorld(true);\n\n\t\t\t\tvar worldMatrices = new Map();\n\n\t\t\t\t// Put skeleton into bind pose.\n\t\t\t\tif ('Pose' in FBXTree.Objects.subNodes) {\n\n\t\t\t\t\t\tvar BindPoseNode = FBXTree.Objects.subNodes.Pose;\n\t\t\t\t\t\tfor (var nodeID in BindPoseNode) {\n\n\t\t\t\t\t\t\t\tif (BindPoseNode[nodeID].attrType === 'BindPose') {\n\n\t\t\t\t\t\t\t\t\t\tBindPoseNode = BindPoseNode[nodeID];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar PoseNode = BindPoseNode.subNodes.PoseNode;\n\n\t\t\t\t\t\tfor (var PoseNodeIndex = 0, PoseNodeLength = PoseNode.length; PoseNodeIndex < PoseNodeLength; ++PoseNodeIndex) {\n\n\t\t\t\t\t\t\t\tvar node = PoseNode[PoseNodeIndex];\n\n\t\t\t\t\t\t\t\tvar rawMatWrd = new THREE.Matrix4().fromArray(node.subNodes.Matrix.properties.a);\n\n\t\t\t\t\t\t\t\tworldMatrices.set(parseInt(node.properties.Node), rawMatWrd);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (var FBX_ID in deformers) {\n\n\t\t\t\t\t\tvar deformer = deformers[FBX_ID];\n\t\t\t\t\t\tvar subDeformers = deformer.map;\n\n\t\t\t\t\t\tfor (var key in subDeformers) {\n\n\t\t\t\t\t\t\t\tvar subDeformer = subDeformers[key];\n\t\t\t\t\t\t\t\tvar subDeformerIndex = subDeformer.index;\n\n\t\t\t\t\t\t\t\tvar bone = deformer.bones[subDeformerIndex];\n\t\t\t\t\t\t\t\tif (!worldMatrices.has(bone.FBX_ID)) {\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tvar mat = worldMatrices.get(bone.FBX_ID);\n\t\t\t\t\t\t\t\tbone.matrixWorld.copy(mat);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Now that skeleton is in bind pose, bind to model.\n\t\t\t\t\t\tdeformer.skeleton = new THREE.Skeleton(deformer.bones);\n\n\t\t\t\t\t\tvar conns = connections.get(deformer.FBX_ID);\n\t\t\t\t\t\tvar parents = conns.parents;\n\n\t\t\t\t\t\tfor (var parentsIndex = 0, parentsLength = parents.length; parentsIndex < parentsLength; ++parentsIndex) {\n\n\t\t\t\t\t\t\t\tvar parent = parents[parentsIndex];\n\n\t\t\t\t\t\t\t\tif (geometryMap.has(parent.ID)) {\n\n\t\t\t\t\t\t\t\t\t\tvar geoID = parent.ID;\n\t\t\t\t\t\t\t\t\t\tvar geoConns = connections.get(geoID);\n\n\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < geoConns.parents.length; ++i) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (modelMap.has(geoConns.parents[i].ID)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar model = modelMap.get(geoConns.parents[i].ID);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel.bind(deformer.skeleton, model.matrixWorld);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//Skeleton is now bound, return objects to starting world positions.\n\t\t\t\tsceneGraph.updateMatrixWorld(true);\n\n\t\t\t\t// Silly hack with the animation parsing. We're gonna pretend the scene graph has a skeleton\n\t\t\t\t// to attach animations to, since FBX treats animations as animations for the entire scene,\n\t\t\t\t// not just for individual objects.\n\t\t\t\tsceneGraph.skeleton = {\n\t\t\t\t\t\tbones: modelArray\n\t\t\t\t};\n\n\t\t\t\tvar animations = parseAnimations(FBXTree, connections, sceneGraph);\n\n\t\t\t\taddAnimations(sceneGraph, animations);\n\n\t\t\t\t// Parse ambient color - if it's not set to black (default), create an ambient light\n\t\t\t\tif ('GlobalSettings' in FBXTree && 'AmbientColor' in FBXTree.GlobalSettings.properties) {\n\n\t\t\t\t\t\tvar ambientColor = FBXTree.GlobalSettings.properties.AmbientColor.value;\n\t\t\t\t\t\tvar r = ambientColor[0];\n\t\t\t\t\t\tvar g = ambientColor[1];\n\t\t\t\t\t\tvar b = ambientColor[2];\n\n\t\t\t\t\t\tif (r !== 0 || g !== 0 || b !== 0) {\n\n\t\t\t\t\t\t\t\tvar color = new THREE.Color(r, g, b);\n\t\t\t\t\t\t\t\tsceneGraph.add(new THREE.AmbientLight(color, 1));\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn sceneGraph;\n\t\t}\n\n\t\t// Parses animation information from nodes in\n\t\t// FBXTree.Objects.subNodes.AnimationCurve ( connected to AnimationCurveNode )\n\t\t// FBXTree.Objects.subNodes.AnimationCurveNode ( connected to AnimationLayer and an animated property in some other node )\n\t\t// FBXTree.Objects.subNodes.AnimationLayer ( connected to AnimationStack )\n\t\t// FBXTree.Objects.subNodes.AnimationStack\n\t\tfunction parseAnimations(FBXTree, connections, sceneGraph) {\n\n\t\t\t\tvar rawNodes = FBXTree.Objects.subNodes.AnimationCurveNode;\n\t\t\t\tvar rawCurves = FBXTree.Objects.subNodes.AnimationCurve;\n\t\t\t\tvar rawLayers = FBXTree.Objects.subNodes.AnimationLayer;\n\t\t\t\tvar rawStacks = FBXTree.Objects.subNodes.AnimationStack;\n\n\t\t\t\tvar fps = 30; // default framerate\n\n\t\t\t\tif ('GlobalSettings' in FBXTree && 'TimeMode' in FBXTree.GlobalSettings.properties) {\n\n\t\t\t\t\t\t/* Autodesk time mode documentation can be found here:\r\n      *\thttp://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/class_fbx_time.html,topicNumber=cpp_ref_class_fbx_time_html\r\n      */\n\t\t\t\t\t\tvar timeModeEnum = [30, // 0: eDefaultMode\n\t\t\t\t\t\t120, // 1: eFrames120\n\t\t\t\t\t\t100, // 2: eFrames100\n\t\t\t\t\t\t60, // 3: eFrames60\n\t\t\t\t\t\t50, // 4: eFrames50\n\t\t\t\t\t\t48, // 5: eFrames48\n\t\t\t\t\t\t30, // 6: eFrames30 (black and white NTSC )\n\t\t\t\t\t\t30, // 7: eFrames30Drop\n\t\t\t\t\t\t29.97, // 8: eNTSCDropFrame\n\t\t\t\t\t\t29.97, // 90: eNTSCFullFrame\n\t\t\t\t\t\t25, // 10: ePal ( PAL/SECAM )\n\t\t\t\t\t\t24, // 11: eFrames24 (Film/Cinema)\n\t\t\t\t\t\t1, // 12: eFrames1000 (use for date time))\n\t\t\t\t\t\t23.976, // 13: eFilmFullFrame\n\t\t\t\t\t\t30, // 14: eCustom: use GlobalSettings.properties.CustomFrameRate.value\n\t\t\t\t\t\t96, // 15: eFrames96\n\t\t\t\t\t\t72, // 16: eFrames72\n\t\t\t\t\t\t59.94];\n\n\t\t\t\t\t\tvar eMode = FBXTree.GlobalSettings.properties.TimeMode.value;\n\n\t\t\t\t\t\tif (eMode === 14) {\n\n\t\t\t\t\t\t\t\tif ('CustomFrameRate' in FBXTree.GlobalSettings.properties) {\n\n\t\t\t\t\t\t\t\t\t\tfps = FBXTree.GlobalSettings.properties.CustomFrameRate.value;\n\n\t\t\t\t\t\t\t\t\t\tfps = fps === -1 ? 30 : fps;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (eMode <= 17) {\n\t\t\t\t\t\t\t\t// for future proofing - if more eModes get added, they will default to 30fps\n\n\t\t\t\t\t\t\t\tfps = timeModeEnum[eMode];\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar returnObject = {\n\t\t\t\t\t\tcurves: new Map(),\n\t\t\t\t\t\tlayers: {},\n\t\t\t\t\t\tstacks: {},\n\t\t\t\t\t\tlength: 0,\n\t\t\t\t\t\tfps: fps,\n\t\t\t\t\t\tframes: 0\n\t\t\t\t};\n\n\t\t\t\tvar animationCurveNodes = [];\n\t\t\t\tfor (var nodeID in rawNodes) {\n\n\t\t\t\t\t\tif (nodeID.match(/\\d+/)) {\n\n\t\t\t\t\t\t\t\tvar animationNode = parseAnimationNode(FBXTree, rawNodes[nodeID], connections, sceneGraph);\n\t\t\t\t\t\t\t\tanimationCurveNodes.push(animationNode);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar tmpMap = new Map();\n\t\t\t\tfor (var animationCurveNodeIndex = 0; animationCurveNodeIndex < animationCurveNodes.length; ++animationCurveNodeIndex) {\n\n\t\t\t\t\t\tif (animationCurveNodes[animationCurveNodeIndex] === null) {\n\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttmpMap.set(animationCurveNodes[animationCurveNodeIndex].id, animationCurveNodes[animationCurveNodeIndex]);\n\t\t\t\t}\n\n\t\t\t\tvar animationCurves = [];\n\t\t\t\tfor (nodeID in rawCurves) {\n\n\t\t\t\t\t\tif (nodeID.match(/\\d+/)) {\n\n\t\t\t\t\t\t\t\tvar animationCurve = parseAnimationCurve(rawCurves[nodeID]);\n\n\t\t\t\t\t\t\t\t// seems like this check would be necessary?\n\t\t\t\t\t\t\t\tif (!connections.has(animationCurve.id)) continue;\n\n\t\t\t\t\t\t\t\tanimationCurves.push(animationCurve);\n\n\t\t\t\t\t\t\t\tvar firstParentConn = connections.get(animationCurve.id).parents[0];\n\t\t\t\t\t\t\t\tvar firstParentID = firstParentConn.ID;\n\t\t\t\t\t\t\t\tvar firstParentRelationship = firstParentConn.relationship;\n\t\t\t\t\t\t\t\tvar axis = '';\n\n\t\t\t\t\t\t\t\tif (firstParentRelationship.match(/X/)) {\n\n\t\t\t\t\t\t\t\t\t\taxis = 'x';\n\t\t\t\t\t\t\t\t} else if (firstParentRelationship.match(/Y/)) {\n\n\t\t\t\t\t\t\t\t\t\taxis = 'y';\n\t\t\t\t\t\t\t\t} else if (firstParentRelationship.match(/Z/)) {\n\n\t\t\t\t\t\t\t\t\t\taxis = 'z';\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\ttmpMap.get(firstParentID).curves[axis] = animationCurve;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttmpMap.forEach(function (curveNode) {\n\n\t\t\t\t\t\tvar id = curveNode.containerBoneID;\n\t\t\t\t\t\tif (!returnObject.curves.has(id)) {\n\n\t\t\t\t\t\t\t\treturnObject.curves.set(id, { T: null, R: null, S: null });\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturnObject.curves.get(id)[curveNode.attr] = curveNode;\n\n\t\t\t\t\t\tif (curveNode.attr === 'R') {\n\n\t\t\t\t\t\t\t\tvar curves = curveNode.curves;\n\n\t\t\t\t\t\t\t\t// Some FBX files have an AnimationCurveNode\n\t\t\t\t\t\t\t\t// which isn't any connected to any AnimationCurve.\n\t\t\t\t\t\t\t\t// Setting animation parameter for them here.\n\n\t\t\t\t\t\t\t\tif (curves.x === null) {\n\n\t\t\t\t\t\t\t\t\t\tcurves.x = {\n\t\t\t\t\t\t\t\t\t\t\t\tversion: null,\n\t\t\t\t\t\t\t\t\t\t\t\ttimes: [0.0],\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: [0.0]\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (curves.y === null) {\n\n\t\t\t\t\t\t\t\t\t\tcurves.y = {\n\t\t\t\t\t\t\t\t\t\t\t\tversion: null,\n\t\t\t\t\t\t\t\t\t\t\t\ttimes: [0.0],\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: [0.0]\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (curves.z === null) {\n\n\t\t\t\t\t\t\t\t\t\tcurves.z = {\n\t\t\t\t\t\t\t\t\t\t\t\tversion: null,\n\t\t\t\t\t\t\t\t\t\t\t\ttimes: [0.0],\n\t\t\t\t\t\t\t\t\t\t\t\tvalues: [0.0]\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcurves.x.values = curves.x.values.map(THREE.Math.degToRad);\n\t\t\t\t\t\t\t\tcurves.y.values = curves.y.values.map(THREE.Math.degToRad);\n\t\t\t\t\t\t\t\tcurves.z.values = curves.z.values.map(THREE.Math.degToRad);\n\n\t\t\t\t\t\t\t\tif (curveNode.preRotations !== null) {\n\n\t\t\t\t\t\t\t\t\t\tvar preRotations = new THREE.Euler().setFromVector3(curveNode.preRotations, 'ZYX');\n\t\t\t\t\t\t\t\t\t\tpreRotations = new THREE.Quaternion().setFromEuler(preRotations);\n\t\t\t\t\t\t\t\t\t\tvar frameRotation = new THREE.Euler();\n\t\t\t\t\t\t\t\t\t\tvar frameRotationQuaternion = new THREE.Quaternion();\n\t\t\t\t\t\t\t\t\t\tfor (var frame = 0; frame < curves.x.times.length; ++frame) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tframeRotation.set(curves.x.values[frame], curves.y.values[frame], curves.z.values[frame], 'ZYX');\n\t\t\t\t\t\t\t\t\t\t\t\tframeRotationQuaternion.setFromEuler(frameRotation).premultiply(preRotations);\n\t\t\t\t\t\t\t\t\t\t\t\tframeRotation.setFromQuaternion(frameRotationQuaternion, 'ZYX');\n\t\t\t\t\t\t\t\t\t\t\t\tcurves.x.values[frame] = frameRotation.x;\n\t\t\t\t\t\t\t\t\t\t\t\tcurves.y.values[frame] = frameRotation.y;\n\t\t\t\t\t\t\t\t\t\t\t\tcurves.z.values[frame] = frameRotation.z;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tfor (var nodeID in rawLayers) {\n\n\t\t\t\t\t\tvar layer = [];\n\t\t\t\t\t\tvar children = connections.get(parseInt(nodeID)).children;\n\n\t\t\t\t\t\tfor (var childIndex = 0; childIndex < children.length; childIndex++) {\n\n\t\t\t\t\t\t\t\t// Skip lockInfluenceWeights\n\t\t\t\t\t\t\t\tif (tmpMap.has(children[childIndex].ID)) {\n\n\t\t\t\t\t\t\t\t\t\tvar curveNode = tmpMap.get(children[childIndex].ID);\n\t\t\t\t\t\t\t\t\t\tvar boneID = curveNode.containerBoneID;\n\t\t\t\t\t\t\t\t\t\tif (layer[boneID] === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tlayer[boneID] = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tT: null,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tR: null,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tS: null\n\t\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tlayer[boneID][curveNode.attr] = curveNode;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturnObject.layers[nodeID] = layer;\n\t\t\t\t}\n\n\t\t\t\tfor (var nodeID in rawStacks) {\n\n\t\t\t\t\t\tvar layers = [];\n\t\t\t\t\t\tvar children = connections.get(parseInt(nodeID)).children;\n\t\t\t\t\t\tvar timestamps = { max: 0, min: Number.MAX_VALUE };\n\n\t\t\t\t\t\tfor (var childIndex = 0; childIndex < children.length; ++childIndex) {\n\n\t\t\t\t\t\t\t\tvar currentLayer = returnObject.layers[children[childIndex].ID];\n\n\t\t\t\t\t\t\t\tif (currentLayer !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\tlayers.push(currentLayer);\n\n\t\t\t\t\t\t\t\t\t\tfor (var currentLayerIndex = 0, currentLayerLength = currentLayer.length; currentLayerIndex < currentLayerLength; ++currentLayerIndex) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar layer = currentLayer[currentLayerIndex];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (layer) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tgetCurveNodeMaxMinTimeStamps(layer, timestamps);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Do we have an animation clip with actual length?\n\t\t\t\t\t\tif (timestamps.max > timestamps.min) {\n\n\t\t\t\t\t\t\t\treturnObject.stacks[nodeID] = {\n\t\t\t\t\t\t\t\t\t\tname: rawStacks[nodeID].attrName,\n\t\t\t\t\t\t\t\t\t\tlayers: layers,\n\t\t\t\t\t\t\t\t\t\tlength: timestamps.max - timestamps.min,\n\t\t\t\t\t\t\t\t\t\tframes: (timestamps.max - timestamps.min) * returnObject.fps\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn returnObject;\n\t\t}\n\n\t\tfunction parseAnimationNode(FBXTree, animationCurveNode, connections, sceneGraph) {\n\n\t\t\t\tvar rawModels = FBXTree.Objects.subNodes.Model;\n\n\t\t\t\tvar returnObject = {\n\n\t\t\t\t\t\tid: animationCurveNode.id,\n\t\t\t\t\t\tattr: animationCurveNode.attrName,\n\t\t\t\t\t\tinternalID: animationCurveNode.id,\n\t\t\t\t\t\tattrX: false,\n\t\t\t\t\t\tattrY: false,\n\t\t\t\t\t\tattrZ: false,\n\t\t\t\t\t\tcontainerBoneID: -1,\n\t\t\t\t\t\tcontainerID: -1,\n\t\t\t\t\t\tcurves: {\n\t\t\t\t\t\t\t\tx: null,\n\t\t\t\t\t\t\t\ty: null,\n\t\t\t\t\t\t\t\tz: null\n\t\t\t\t\t\t},\n\t\t\t\t\t\tpreRotations: null\n\n\t\t\t\t};\n\n\t\t\t\tif (returnObject.attr.match(/S|R|T/)) {\n\n\t\t\t\t\t\tfor (var attributeKey in animationCurveNode.properties) {\n\n\t\t\t\t\t\t\t\tif (attributeKey.match(/X/)) {\n\n\t\t\t\t\t\t\t\t\t\treturnObject.attrX = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (attributeKey.match(/Y/)) {\n\n\t\t\t\t\t\t\t\t\t\treturnObject.attrY = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (attributeKey.match(/Z/)) {\n\n\t\t\t\t\t\t\t\t\t\treturnObject.attrZ = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t} else {\n\n\t\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tvar conns = connections.get(returnObject.id);\n\t\t\t\tvar containerIndices = conns.parents;\n\n\t\t\t\tfor (var containerIndicesIndex = containerIndices.length - 1; containerIndicesIndex >= 0; --containerIndicesIndex) {\n\n\t\t\t\t\t\tvar boneID = findIndex(sceneGraph.skeleton.bones, function (bone) {\n\n\t\t\t\t\t\t\t\treturn bone.FBX_ID === containerIndices[containerIndicesIndex].ID;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (boneID > -1) {\n\n\t\t\t\t\t\t\t\treturnObject.containerBoneID = boneID;\n\t\t\t\t\t\t\t\treturnObject.containerID = containerIndices[containerIndicesIndex].ID;\n\t\t\t\t\t\t\t\tvar model = rawModels[returnObject.containerID.toString()];\n\t\t\t\t\t\t\t\tif ('PreRotation' in model.properties) {\n\n\t\t\t\t\t\t\t\t\t\treturnObject.preRotations = parseVector3(model.properties.PreRotation).multiplyScalar(Math.PI / 180);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn returnObject;\n\t\t}\n\n\t\tfunction parseAnimationCurve(animationCurve) {\n\n\t\t\t\treturn {\n\t\t\t\t\t\tversion: null,\n\t\t\t\t\t\tid: animationCurve.id,\n\t\t\t\t\t\tinternalID: animationCurve.id,\n\t\t\t\t\t\ttimes: animationCurve.subNodes.KeyTime.properties.a.map(convertFBXTimeToSeconds),\n\t\t\t\t\t\tvalues: animationCurve.subNodes.KeyValueFloat.properties.a,\n\n\t\t\t\t\t\tattrFlag: animationCurve.subNodes.KeyAttrFlags.properties.a,\n\t\t\t\t\t\tattrData: animationCurve.subNodes.KeyAttrDataFloat.properties.a\n\t\t\t\t};\n\t\t}\n\n\t\t// Sets the maxTimeStamp and minTimeStamp variables if it has timeStamps that are either larger or smaller\n\t\t// than the max or min respectively.\n\t\tfunction getCurveNodeMaxMinTimeStamps(layer, timestamps) {\n\n\t\t\t\tif (layer.R) {\n\n\t\t\t\t\t\tgetCurveMaxMinTimeStamp(layer.R.curves, timestamps);\n\t\t\t\t}\n\t\t\t\tif (layer.S) {\n\n\t\t\t\t\t\tgetCurveMaxMinTimeStamp(layer.S.curves, timestamps);\n\t\t\t\t}\n\t\t\t\tif (layer.T) {\n\n\t\t\t\t\t\tgetCurveMaxMinTimeStamp(layer.T.curves, timestamps);\n\t\t\t\t}\n\t\t}\n\n\t\t// Sets the maxTimeStamp and minTimeStamp if one of the curve's time stamps\n\t\t// exceeds the maximum or minimum.\n\t\tfunction getCurveMaxMinTimeStamp(curve, timestamps) {\n\n\t\t\t\tif (curve.x) {\n\n\t\t\t\t\t\tgetCurveAxisMaxMinTimeStamps(curve.x, timestamps);\n\t\t\t\t}\n\t\t\t\tif (curve.y) {\n\n\t\t\t\t\t\tgetCurveAxisMaxMinTimeStamps(curve.y, timestamps);\n\t\t\t\t}\n\t\t\t\tif (curve.z) {\n\n\t\t\t\t\t\tgetCurveAxisMaxMinTimeStamps(curve.z, timestamps);\n\t\t\t\t}\n\t\t}\n\n\t\t// Sets the maxTimeStamp and minTimeStamp if one of its timestamps exceeds the maximum or minimum.\n\t\tfunction getCurveAxisMaxMinTimeStamps(axis, timestamps) {\n\n\t\t\t\ttimestamps.max = axis.times[axis.times.length - 1] > timestamps.max ? axis.times[axis.times.length - 1] : timestamps.max;\n\t\t\t\ttimestamps.min = axis.times[0] < timestamps.min ? axis.times[0] : timestamps.min;\n\t\t}\n\n\t\tfunction addAnimations(group, animations) {\n\n\t\t\t\tif (group.animations === undefined) {\n\n\t\t\t\t\t\tgroup.animations = [];\n\t\t\t\t}\n\n\t\t\t\tvar stacks = animations.stacks;\n\n\t\t\t\tfor (var key in stacks) {\n\n\t\t\t\t\t\tvar stack = stacks[key];\n\n\t\t\t\t\t\tvar animationData = {\n\t\t\t\t\t\t\t\tname: stack.name,\n\t\t\t\t\t\t\t\tfps: animations.fps,\n\t\t\t\t\t\t\t\tlength: stack.length,\n\t\t\t\t\t\t\t\thierarchy: []\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tvar bones = group.skeleton.bones;\n\n\t\t\t\t\t\tfor (var bonesIndex = 0, bonesLength = bones.length; bonesIndex < bonesLength; ++bonesIndex) {\n\n\t\t\t\t\t\t\t\tvar bone = bones[bonesIndex];\n\n\t\t\t\t\t\t\t\tvar name = bone.name.replace(/.*:/, '');\n\t\t\t\t\t\t\t\tvar parentIndex = findIndex(bones, function (parentBone) {\n\n\t\t\t\t\t\t\t\t\t\treturn bone.parent === parentBone;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tanimationData.hierarchy.push({ parent: parentIndex, name: name, keys: [] });\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (var frame = 0; frame <= stack.frames; frame++) {\n\n\t\t\t\t\t\t\t\tfor (var bonesIndex = 0, bonesLength = bones.length; bonesIndex < bonesLength; ++bonesIndex) {\n\n\t\t\t\t\t\t\t\t\t\tvar bone = bones[bonesIndex];\n\t\t\t\t\t\t\t\t\t\tvar boneIndex = bonesIndex;\n\n\t\t\t\t\t\t\t\t\t\tvar animationNode = stack.layers[0][boneIndex];\n\n\t\t\t\t\t\t\t\t\t\tfor (var hierarchyIndex = 0, hierarchyLength = animationData.hierarchy.length; hierarchyIndex < hierarchyLength; ++hierarchyIndex) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar node = animationData.hierarchy[hierarchyIndex];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (node.name === bone.name) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tnode.keys.push(generateKey(animations, animationNode, bone, frame));\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgroup.animations.push(THREE.AnimationClip.parseAnimation(animationData, bones));\n\t\t\t\t}\n\t\t}\n\n\t\tvar euler = new THREE.Euler();\n\t\tvar quaternion = new THREE.Quaternion();\n\n\t\tfunction generateKey(animations, animationNode, bone, frame) {\n\n\t\t\t\tvar key = {\n\t\t\t\t\t\ttime: frame / animations.fps,\n\t\t\t\t\t\tpos: bone.position.toArray(),\n\t\t\t\t\t\trot: bone.quaternion.toArray(),\n\t\t\t\t\t\tscl: bone.scale.toArray()\n\t\t\t\t};\n\n\t\t\t\tif (animationNode === undefined) return key;\n\n\t\t\t\teuler.setFromQuaternion(bone.quaternion, 'ZYX', false);\n\n\t\t\t\ttry {\n\n\t\t\t\t\t\tif (hasCurve(animationNode, 'T') && hasKeyOnFrame(animationNode.T, frame)) {\n\n\t\t\t\t\t\t\t\tif (animationNode.T.curves.x.values[frame]) {\n\n\t\t\t\t\t\t\t\t\t\tkey.pos[0] = animationNode.T.curves.x.values[frame];\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (animationNode.T.curves.y.values[frame]) {\n\n\t\t\t\t\t\t\t\t\t\tkey.pos[1] = animationNode.T.curves.y.values[frame];\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (animationNode.T.curves.z.values[frame]) {\n\n\t\t\t\t\t\t\t\t\t\tkey.pos[2] = animationNode.T.curves.z.values[frame];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (hasCurve(animationNode, 'R') && hasKeyOnFrame(animationNode.R, frame)) {\n\n\t\t\t\t\t\t\t\t// Only update the euler's values if rotation is defined for the axis on this frame\n\t\t\t\t\t\t\t\tif (animationNode.R.curves.x.values[frame]) {\n\n\t\t\t\t\t\t\t\t\t\teuler.x = animationNode.R.curves.x.values[frame];\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (animationNode.R.curves.y.values[frame]) {\n\n\t\t\t\t\t\t\t\t\t\teuler.y = animationNode.R.curves.y.values[frame];\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (animationNode.R.curves.z.values[frame]) {\n\n\t\t\t\t\t\t\t\t\t\teuler.z = animationNode.R.curves.z.values[frame];\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tquaternion.setFromEuler(euler);\n\t\t\t\t\t\t\t\tkey.rot = quaternion.toArray();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (hasCurve(animationNode, 'S') && hasKeyOnFrame(animationNode.S, frame)) {\n\n\t\t\t\t\t\t\t\tif (animationNode.T.curves.x.values[frame]) {\n\n\t\t\t\t\t\t\t\t\t\tkey.scl[0] = animationNode.S.curves.x.values[frame];\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (animationNode.T.curves.y.values[frame]) {\n\n\t\t\t\t\t\t\t\t\t\tkey.scl[1] = animationNode.S.curves.y.values[frame];\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (animationNode.T.curves.z.values[frame]) {\n\n\t\t\t\t\t\t\t\t\t\tkey.scl[2] = animationNode.S.curves.z.values[frame];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\n\t\t\t\t\t\t// Curve is not fully plotted.\n\t\t\t\t\t\tconsole.log('THREE.FBXLoader: ', bone);\n\t\t\t\t\t\tconsole.log('THREE.FBXLoader: ', error);\n\t\t\t\t}\n\n\t\t\t\treturn key;\n\t\t}\n\n\t\tvar AXES = ['x', 'y', 'z'];\n\n\t\tfunction hasCurve(animationNode, attribute) {\n\n\t\t\t\tif (animationNode === undefined) {\n\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tvar attributeNode = animationNode[attribute];\n\n\t\t\t\tif (!attributeNode) {\n\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn AXES.every(function (key) {\n\n\t\t\t\t\t\treturn attributeNode.curves[key] !== null;\n\t\t\t\t});\n\t\t}\n\n\t\tfunction hasKeyOnFrame(attributeNode, frame) {\n\n\t\t\t\treturn AXES.every(function (key) {\n\n\t\t\t\t\t\treturn isKeyExistOnFrame(attributeNode.curves[key], frame);\n\t\t\t\t});\n\t\t}\n\n\t\tfunction isKeyExistOnFrame(curve, frame) {\n\n\t\t\t\treturn curve.values[frame] !== undefined;\n\t\t}\n\n\t\t// parse an FBX file in ASCII format\n\t\tfunction TextParser() {}\n\n\t\tObject.assign(TextParser.prototype, {\n\n\t\t\t\tgetPrevNode: function () {\n\n\t\t\t\t\t\treturn this.nodeStack[this.currentIndent - 2];\n\t\t\t\t},\n\n\t\t\t\tgetCurrentNode: function () {\n\n\t\t\t\t\t\treturn this.nodeStack[this.currentIndent - 1];\n\t\t\t\t},\n\n\t\t\t\tgetCurrentProp: function () {\n\n\t\t\t\t\t\treturn this.currentProp;\n\t\t\t\t},\n\n\t\t\t\tpushStack: function (node) {\n\n\t\t\t\t\t\tthis.nodeStack.push(node);\n\t\t\t\t\t\tthis.currentIndent += 1;\n\t\t\t\t},\n\n\t\t\t\tpopStack: function () {\n\n\t\t\t\t\t\tthis.nodeStack.pop();\n\t\t\t\t\t\tthis.currentIndent -= 1;\n\t\t\t\t},\n\n\t\t\t\tsetCurrentProp: function (val, name) {\n\n\t\t\t\t\t\tthis.currentProp = val;\n\t\t\t\t\t\tthis.currentPropName = name;\n\t\t\t\t},\n\n\t\t\t\tparse: function (text) {\n\n\t\t\t\t\t\tthis.currentIndent = 0;\n\t\t\t\t\t\tthis.allNodes = new FBXTree();\n\t\t\t\t\t\tthis.nodeStack = [];\n\t\t\t\t\t\tthis.currentProp = [];\n\t\t\t\t\t\tthis.currentPropName = '';\n\n\t\t\t\t\t\tvar split = text.split('\\n');\n\n\t\t\t\t\t\tfor (var lineNum = 0, lineLength = split.length; lineNum < lineLength; lineNum++) {\n\n\t\t\t\t\t\t\t\tvar l = split[lineNum];\n\n\t\t\t\t\t\t\t\t// skip comment line\n\t\t\t\t\t\t\t\tif (l.match(/^[\\s\\t]*;/)) {\n\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// skip empty line\n\t\t\t\t\t\t\t\tif (l.match(/^[\\s\\t]*$/)) {\n\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// beginning of node\n\t\t\t\t\t\t\t\tvar beginningOfNodeExp = new RegExp('^\\\\t{' + this.currentIndent + '}(\\\\w+):(.*){', '');\n\t\t\t\t\t\t\t\tvar match = l.match(beginningOfNodeExp);\n\n\t\t\t\t\t\t\t\tif (match) {\n\n\t\t\t\t\t\t\t\t\t\tvar nodeName = match[1].trim().replace(/^\"/, '').replace(/\"$/, '');\n\t\t\t\t\t\t\t\t\t\tvar nodeAttrs = match[2].split(',');\n\n\t\t\t\t\t\t\t\t\t\tfor (var i = 0, l = nodeAttrs.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tnodeAttrs[i] = nodeAttrs[i].trim().replace(/^\"/, '').replace(/\"$/, '');\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tthis.parseNodeBegin(l, nodeName, nodeAttrs || null);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// node's property\n\t\t\t\t\t\t\t\tvar propExp = new RegExp('^\\\\t{' + this.currentIndent + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)');\n\t\t\t\t\t\t\t\tvar match = l.match(propExp);\n\n\t\t\t\t\t\t\t\tif (match) {\n\n\t\t\t\t\t\t\t\t\t\tvar propName = match[1].replace(/^\"/, '').replace(/\"$/, '').trim();\n\t\t\t\t\t\t\t\t\t\tvar propValue = match[2].replace(/^\"/, '').replace(/\"$/, '').trim();\n\n\t\t\t\t\t\t\t\t\t\t// for special case: base64 image data follows \"Content: ,\" line\n\t\t\t\t\t\t\t\t\t\t//\tContent: ,\n\t\t\t\t\t\t\t\t\t\t//\t \"iVB...\"\n\t\t\t\t\t\t\t\t\t\tif (propName === 'Content' && propValue === ',') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tpropValue = split[++lineNum].replace(/\"/g, '').replace(/,$/, '').trim();\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tthis.parseNodeProperty(l, propName, propValue);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// end of node\n\t\t\t\t\t\t\t\tvar endOfNodeExp = new RegExp('^\\\\t{' + (this.currentIndent - 1) + '}}');\n\n\t\t\t\t\t\t\t\tif (l.match(endOfNodeExp)) {\n\n\t\t\t\t\t\t\t\t\t\tthis.nodeEnd();\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// large arrays are split over multiple lines terminated with a ',' character\n\t\t\t\t\t\t\t\t// if this is encountered the line needs to be joined to the previous line\n\t\t\t\t\t\t\t\tif (l.match(/^[^\\s\\t}]/)) {\n\n\t\t\t\t\t\t\t\t\t\tthis.parseNodePropertyContinued(l);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn this.allNodes;\n\t\t\t\t},\n\n\t\t\t\tparseNodeBegin: function (line, nodeName, nodeAttrs) {\n\n\t\t\t\t\t\tvar node = { 'name': nodeName, properties: {}, 'subNodes': {} };\n\t\t\t\t\t\tvar attrs = this.parseNodeAttr(nodeAttrs);\n\t\t\t\t\t\tvar currentNode = this.getCurrentNode();\n\n\t\t\t\t\t\t// a top node\n\t\t\t\t\t\tif (this.currentIndent === 0) {\n\t\t\t\t\t\t\t\tthis.allNodes.add(nodeName, node);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// a subnode\n\n\t\t\t\t\t\t\t\t// if the subnode already exists, append it\n\t\t\t\t\t\t\t\tif (nodeName in currentNode.subNodes) {\n\n\t\t\t\t\t\t\t\t\t\tvar tmp = currentNode.subNodes[nodeName];\n\n\t\t\t\t\t\t\t\t\t\tif (this.isFlattenNode(currentNode.subNodes[nodeName])) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (attrs.id === '') {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentNode.subNodes[nodeName] = [];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentNode.subNodes[nodeName].push(tmp);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentNode.subNodes[nodeName] = {};\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentNode.subNodes[nodeName][tmp.id] = tmp;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (attrs.id === '') {\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentNode.subNodes[nodeName].push(node);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentNode.subNodes[nodeName][attrs.id] = node;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (typeof attrs.id === 'number' || attrs.id.match(/^\\d+$/)) {\n\t\t\t\t\t\t\t\t\t\tcurrentNode.subNodes[nodeName] = {};\n\t\t\t\t\t\t\t\t\t\tcurrentNode.subNodes[nodeName][attrs.id] = node;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tcurrentNode.subNodes[nodeName] = node;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// for this\t\n\t\t\t\t\t\t// NodeAttribute: 1001463072, \"NodeAttribute::\", \"LimbNode\" {\n\t\t\t\t\t\tif (nodeAttrs) {\n\t\t\t\t\t\t\t\tnode.id = attrs.id;\n\t\t\t\t\t\t\t\tnode.attrName = attrs.name;\n\t\t\t\t\t\t\t\tnode.attrType = attrs.type;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.pushStack(node);\n\t\t\t\t},\n\n\t\t\t\tparseNodeAttr: function (attrs) {\n\t\t\t\t\t\tvar id = attrs[0];\n\n\t\t\t\t\t\tif (attrs[0] !== '') {\n\t\t\t\t\t\t\t\tid = parseInt(attrs[0]);\n\n\t\t\t\t\t\t\t\tif (isNaN(id)) {\n\t\t\t\t\t\t\t\t\t\tid = attrs[0];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar name = '',\n\t\t\t\t\t\t    type = '';\n\n\t\t\t\t\t\tif (attrs.length > 1) {\n\t\t\t\t\t\t\t\tname = attrs[1].replace(/^(\\w+)::/, '');\n\t\t\t\t\t\t\t\ttype = attrs[2];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn { id: id, name: name, type: type };\n\t\t\t\t},\n\n\t\t\t\tparseNodeProperty: function (line, propName, propValue) {\n\t\t\t\t\t\tvar currentNode = this.getCurrentNode();\n\t\t\t\t\t\tvar parentName = currentNode.name;\n\n\t\t\t\t\t\t// special case where the parent node is something like \"Properties70\"\n\t\t\t\t\t\t// these children nodes must treated carefully\n\t\t\t\t\t\tif (parentName !== undefined) {\n\t\t\t\t\t\t\t\tvar propMatch = parentName.match(/Properties(\\d)+/);\n\t\t\t\t\t\t\t\tif (propMatch) {\n\t\t\t\t\t\t\t\t\t\tthis.parseNodeSpecialProperty(line, propName, propValue);\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Connections\n\t\t\t\t\t\tif (propName === 'C') {\n\n\t\t\t\t\t\t\t\tvar connProps = propValue.split(',').slice(1);\n\t\t\t\t\t\t\t\tvar from = parseInt(connProps[0]);\n\t\t\t\t\t\t\t\tvar to = parseInt(connProps[1]);\n\t\t\t\t\t\t\t\tvar rest = propValue.split(',').slice(3);\n\n\t\t\t\t\t\t\t\trest = rest.map(function (elem) {\n\t\t\t\t\t\t\t\t\t\treturn elem.trim().replace(/^\"/, '');\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tpropName = 'connections';\n\t\t\t\t\t\t\t\tpropValue = [from, to];\n\t\t\t\t\t\t\t\tappend(propValue, rest);\n\n\t\t\t\t\t\t\t\tif (currentNode.properties[propName] === undefined) {\n\t\t\t\t\t\t\t\t\t\tcurrentNode.properties[propName] = [];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Node\n\t\t\t\t\t\tif (propName === 'Node') {\n\t\t\t\t\t\t\t\tvar id = parseInt(propValue);\n\t\t\t\t\t\t\t\tcurrentNode.properties.id = id;\n\t\t\t\t\t\t\t\tcurrentNode.id = id;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// already exists in properties, then append this\n\t\t\t\t\t\tif (propName in currentNode.properties) {\n\t\t\t\t\t\t\t\tif (Array.isArray(currentNode.properties[propName])) {\n\t\t\t\t\t\t\t\t\t\tcurrentNode.properties[propName].push(propValue);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tcurrentNode.properties[propName] += propValue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (Array.isArray(currentNode.properties[propName])) {\n\t\t\t\t\t\t\t\t\t\tcurrentNode.properties[propName].push(propValue);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tcurrentNode.properties[propName] = propValue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis.setCurrentProp(currentNode.properties, propName);\n\n\t\t\t\t\t\t// convert string to array, unless it ends in ',' in which case more will be added to it\n\t\t\t\t\t\tif (propName === 'a' && propValue.slice(-1) !== ',') {\n\t\t\t\t\t\t\t\tcurrentNode.properties.a = parseNumberArray(propValue);\n\t\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tparseNodePropertyContinued: function (line) {\n\t\t\t\t\t\tthis.currentProp[this.currentPropName] += line;\n\n\t\t\t\t\t\t// if the line doesn't end in ',' we have reached the end of the property value\n\t\t\t\t\t\t// so convert the string to an array\n\t\t\t\t\t\tif (line.slice(-1) !== ',') {\n\t\t\t\t\t\t\t\tvar currentNode = this.getCurrentNode();\n\t\t\t\t\t\t\t\tcurrentNode.properties.a = parseNumberArray(currentNode.properties.a);\n\t\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tparseNodeSpecialProperty: function (line, propName, propValue) {\n\t\t\t\t\t\t// split this\n\t\t\t\t\t\t// P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n\t\t\t\t\t\t// into array like below\n\t\t\t\t\t\t// [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n\t\t\t\t\t\tvar props = propValue.split('\",');\n\n\t\t\t\t\t\tfor (var i = 0, l = props.length; i < l; i++) {\n\t\t\t\t\t\t\t\tprops[i] = props[i].trim().replace(/^\\\"/, '').replace(/\\s/, '_');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar innerPropName = props[0];\n\t\t\t\t\t\tvar innerPropType1 = props[1];\n\t\t\t\t\t\tvar innerPropType2 = props[2];\n\t\t\t\t\t\tvar innerPropFlag = props[3];\n\t\t\t\t\t\tvar innerPropValue = props[4];\n\n\t\t\t\t\t\t// cast value to its type\n\t\t\t\t\t\tswitch (innerPropType1) {\n\t\t\t\t\t\t\t\tcase 'int':\n\t\t\t\t\t\t\t\tcase 'enum':\n\t\t\t\t\t\t\t\tcase 'bool':\n\t\t\t\t\t\t\t\tcase 'ULongLong':\n\t\t\t\t\t\t\t\t\t\tinnerPropValue = parseInt(innerPropValue);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'double':\n\t\t\t\t\t\t\t\tcase 'Number':\n\t\t\t\t\t\t\t\tcase 'FieldOfView':\n\t\t\t\t\t\t\t\t\t\tinnerPropValue = parseFloat(innerPropValue);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'ColorRGB':\n\t\t\t\t\t\t\t\tcase 'Vector3D':\n\t\t\t\t\t\t\t\tcase 'Lcl_Translation':\n\t\t\t\t\t\t\t\tcase 'Lcl_Rotation':\n\t\t\t\t\t\t\t\tcase 'Lcl_Scaling':\n\t\t\t\t\t\t\t\t\t\tinnerPropValue = parseNumberArray(innerPropValue);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// CAUTION: these props must append to parent's parent\n\t\t\t\t\t\tthis.getPrevNode().properties[innerPropName] = {\n\t\t\t\t\t\t\t\t'type': innerPropType1,\n\t\t\t\t\t\t\t\t'type2': innerPropType2,\n\t\t\t\t\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t\t\t\t\t'value': innerPropValue\n\t\t\t\t\t\t};\n\t\t\t\t\t\tthis.setCurrentProp(this.getPrevNode().properties, innerPropName);\n\t\t\t\t},\n\n\t\t\t\tnodeEnd: function () {\n\t\t\t\t\t\tthis.popStack();\n\t\t\t\t},\n\n\t\t\t\tisFlattenNode: function (node) {\n\t\t\t\t\t\treturn 'subNodes' in node && 'properties' in node ? true : false;\n\t\t\t\t}\n\t\t});\n\n\t\t// Parse an FBX file in Binary format\n\t\tfunction BinaryParser() {}\n\n\t\tObject.assign(BinaryParser.prototype, {\n\t\t\t\tparse: function (buffer) {\n\t\t\t\t\t\tvar reader = new BinaryReader(buffer);\n\t\t\t\t\t\treader.skip(23); // skip magic 23 bytes\n\t\t\t\t\t\tvar version = reader.getUint32();\n\n\t\t\t\t\t\t//console.log( 'THREE.FBXLoader: FBX binary version: ' + version );\n\t\t\t\t\t\tvar allNodes = new FBXTree();\n\t\t\t\t\t\tvar count = 0;\n\n\t\t\t\t\t\twhile (!this.endOfContent(reader)) {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tvar node = this.parseNode(reader, version);\n\t\t\t\t\t\t\t\t\t\tif (node !== null) {\n\t\t\t\t\t\t\t\t\t\t\t\tallNodes.add(node.name, node);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t\t\tconsole.log(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn allNodes;\n\t\t\t\t},\n\n\t\t\t\t// Check if reader has reached the end of content.\n\t\t\t\tendOfContent: function (reader) {\n\n\t\t\t\t\t\t// footer size: 160bytes + 16-byte alignment padding\n\t\t\t\t\t\t// - 16bytes: magic\n\t\t\t\t\t\t// - padding til 16-byte alignment (at least 1byte?)\n\t\t\t\t\t\t//\t(seems like some exporters embed fixed 15 or 16bytes?)\n\t\t\t\t\t\t// - 4bytes: magic\n\t\t\t\t\t\t// - 4bytes: version\n\t\t\t\t\t\t// - 120bytes: zero\n\t\t\t\t\t\t// - 16bytes: magic\n\t\t\t\t\t\tif (reader.size() % 16 === 0) {\n\t\t\t\t\t\t\t\treturn (reader.getOffset() + 160 + 16 & ~0xf) >= reader.size();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn reader.getOffset() + 160 + 16 >= reader.size();\n\t\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\tparseNode: function (reader, version) {\n\t\t\t\t\t\t// The first three data sizes depends on version.\n\t\t\t\t\t\tvar endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();\n\t\t\t\t\t\tvar numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();\n\n\t\t\t\t\t\t// note: do not remove this even if you get a linter warning as it moves the buffer forward\n\t\t\t\t\t\tvar propertyListLen = version >= 7500 ? reader.getUint64() : reader.getUint32();\n\n\t\t\t\t\t\tvar nameLen = reader.getUint8();\n\t\t\t\t\t\tvar name = reader.getString(nameLen);\n\n\t\t\t\t\t\t// Regards this node as NULL-record if endOffset is zero\n\t\t\t\t\t\tif (endOffset === 0) return null;\n\n\t\t\t\t\t\tvar propertyList = [];\n\n\t\t\t\t\t\tfor (var i = 0; i < numProperties; i++) {\n\t\t\t\t\t\t\t\tpropertyList.push(this.parseProperty(reader));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Regards the first three elements in propertyList as id, attrName, and attrType\n\t\t\t\t\t\tvar id = propertyList.length > 0 ? propertyList[0] : '';\n\t\t\t\t\t\tvar attrName = propertyList.length > 1 ? propertyList[1] : '';\n\t\t\t\t\t\tvar attrType = propertyList.length > 2 ? propertyList[2] : '';\n\n\t\t\t\t\t\tvar subNodes = {};\n\t\t\t\t\t\tvar properties = {};\n\n\t\t\t\t\t\tvar isSingleProperty = false;\n\n\t\t\t\t\t\t// check if this node represents just a single property\n\t\t\t\t\t\t// like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n\t\t\t\t\t\tif (numProperties === 1 && reader.getOffset() === endOffset) {\n\n\t\t\t\t\t\t\t\tisSingleProperty = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twhile (endOffset > reader.getOffset()) {\n\n\t\t\t\t\t\t\t\tvar node = this.parseNode(reader, version);\n\n\t\t\t\t\t\t\t\tif (node === null) continue;\n\n\t\t\t\t\t\t\t\t// special case: child node is single property\n\t\t\t\t\t\t\t\tif (node.singleProperty === true) {\n\n\t\t\t\t\t\t\t\t\t\tvar value = node.propertyList[0];\n\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(value)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tsubNodes[node.name] = node;\n\n\t\t\t\t\t\t\t\t\t\t\t\tnode.properties.a = value;\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tproperties[node.name] = value;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// parse connections\n\t\t\t\t\t\t\t\tif (name === 'Connections' && node.name === 'C') {\n\n\t\t\t\t\t\t\t\t\t\tvar array = [];\n\n\t\t\t\t\t\t\t\t\t\tfor (var i = 1, il = node.propertyList.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tarray[i - 1] = node.propertyList[i];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (properties.connections === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tproperties.connections = [];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tproperties.connections.push(array);\n\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// special case: child node is Properties\\d+\n\t\t\t\t\t\t\t\t// move child node's properties to this node.\n\t\t\t\t\t\t\t\tif (node.name.match(/^Properties\\d+$/)) {\n\n\t\t\t\t\t\t\t\t\t\tvar keys = Object.keys(node.properties);\n\n\t\t\t\t\t\t\t\t\t\tfor (var i = 0, il = keys.length; i < il; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar key = keys[i];\n\t\t\t\t\t\t\t\t\t\t\t\tproperties[key] = node.properties[key];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// parse 'properties70'\n\t\t\t\t\t\t\t\tif (name.match(/^Properties\\d+$/) && node.name === 'P') {\n\n\t\t\t\t\t\t\t\t\t\tvar innerPropName = node.propertyList[0];\n\t\t\t\t\t\t\t\t\t\tvar innerPropType1 = node.propertyList[1];\n\t\t\t\t\t\t\t\t\t\tvar innerPropType2 = node.propertyList[2];\n\t\t\t\t\t\t\t\t\t\tvar innerPropFlag = node.propertyList[3];\n\t\t\t\t\t\t\t\t\t\tvar innerPropValue;\n\n\t\t\t\t\t\t\t\t\t\tif (innerPropName.indexOf('Lcl ') === 0) innerPropName = innerPropName.replace('Lcl ', 'Lcl_');\n\t\t\t\t\t\t\t\t\t\tif (innerPropType1.indexOf('Lcl ') === 0) innerPropType1 = innerPropType1.replace('Lcl ', 'Lcl_');\n\n\t\t\t\t\t\t\t\t\t\tif (innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf('Lcl_') === 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tinnerPropValue = [node.propertyList[4], node.propertyList[5], node.propertyList[6]];\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tinnerPropValue = node.propertyList[4];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// this will be copied to parent, see above\n\t\t\t\t\t\t\t\t\t\tproperties[innerPropName] = {\n\n\t\t\t\t\t\t\t\t\t\t\t\t'type': innerPropType1,\n\t\t\t\t\t\t\t\t\t\t\t\t'type2': innerPropType2,\n\t\t\t\t\t\t\t\t\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t\t\t\t\t\t\t\t\t'value': innerPropValue\n\n\t\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (subNodes[node.name] === undefined) {\n\n\t\t\t\t\t\t\t\t\t\tif (typeof node.id === 'number') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tsubNodes[node.name] = {};\n\t\t\t\t\t\t\t\t\t\t\t\tsubNodes[node.name][node.id] = node;\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tsubNodes[node.name] = node;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tif (node.id === '') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (!Array.isArray(subNodes[node.name])) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsubNodes[node.name] = [subNodes[node.name]];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tsubNodes[node.name].push(node);\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (subNodes[node.name][node.id] === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsubNodes[node.name][node.id] = node;\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// conflict id. irregular?\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (!Array.isArray(subNodes[node.name][node.id])) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsubNodes[node.name][node.id] = [subNodes[node.name][node.id]];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsubNodes[node.name][node.id].push(node);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn {\n\n\t\t\t\t\t\t\t\tsingleProperty: isSingleProperty,\n\t\t\t\t\t\t\t\tid: id,\n\t\t\t\t\t\t\t\tattrName: attrName,\n\t\t\t\t\t\t\t\tattrType: attrType,\n\t\t\t\t\t\t\t\tname: name,\n\t\t\t\t\t\t\t\tproperties: properties,\n\t\t\t\t\t\t\t\tpropertyList: propertyList, // raw property list used by parent\n\t\t\t\t\t\t\t\tsubNodes: subNodes\n\n\t\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\tparseProperty: function (reader) {\n\n\t\t\t\t\t\tvar type = reader.getChar();\n\n\t\t\t\t\t\tswitch (type) {\n\n\t\t\t\t\t\t\t\tcase 'C':\n\t\t\t\t\t\t\t\t\t\treturn reader.getBoolean();\n\n\t\t\t\t\t\t\t\tcase 'D':\n\t\t\t\t\t\t\t\t\t\treturn reader.getFloat64();\n\n\t\t\t\t\t\t\t\tcase 'F':\n\t\t\t\t\t\t\t\t\t\treturn reader.getFloat32();\n\n\t\t\t\t\t\t\t\tcase 'I':\n\t\t\t\t\t\t\t\t\t\treturn reader.getInt32();\n\n\t\t\t\t\t\t\t\tcase 'L':\n\t\t\t\t\t\t\t\t\t\treturn reader.getInt64();\n\n\t\t\t\t\t\t\t\tcase 'R':\n\t\t\t\t\t\t\t\t\t\tvar length = reader.getUint32();\n\t\t\t\t\t\t\t\t\t\treturn reader.getArrayBuffer(length);\n\n\t\t\t\t\t\t\t\tcase 'S':\n\t\t\t\t\t\t\t\t\t\tvar length = reader.getUint32();\n\t\t\t\t\t\t\t\t\t\treturn reader.getString(length);\n\n\t\t\t\t\t\t\t\tcase 'Y':\n\t\t\t\t\t\t\t\t\t\treturn reader.getInt16();\n\n\t\t\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\t\t\t\tvar arrayLength = reader.getUint32();\n\t\t\t\t\t\t\t\t\t\tvar encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\n\t\t\t\t\t\t\t\t\t\tvar compressedLength = reader.getUint32();\n\n\t\t\t\t\t\t\t\t\t\tif (encoding === 0) {\n\t\t\t\t\t\t\t\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader.getBooleanArray(arrayLength);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader.getFloat64Array(arrayLength);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader.getFloat32Array(arrayLength);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader.getInt32Array(arrayLength);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader.getInt64Array(arrayLength);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (window.Zlib === undefined) {\n\t\t\t\t\t\t\t\t\t\t\t\tthrow new Error('THREE.FBXLoader: External library Inflate.min.js required, obtain or import from https://github.com/imaya/zlib.js');\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tvar inflate = new Zlib.Inflate(new Uint8Array(reader.getArrayBuffer(compressedLength))); // eslint-disable-line no-undef\n\t\t\t\t\t\t\t\t\t\tvar reader2 = new BinaryReader(inflate.decompress().buffer);\n\n\t\t\t\t\t\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader2.getBooleanArray(arrayLength);\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader2.getFloat64Array(arrayLength);\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader2.getFloat32Array(arrayLength);\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader2.getInt32Array(arrayLength);\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader2.getInt64Array(arrayLength);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tthrow new Error('THREE.FBXLoader: Unknown property type ' + type);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t});\n\n\t\tfunction BinaryReader(buffer, littleEndian) {\n\n\t\t\t\tthis.dv = new DataView(buffer);\n\t\t\t\tthis.offset = 0;\n\t\t\t\tthis.littleEndian = littleEndian !== undefined ? littleEndian : true;\n\t\t}\n\n\t\tObject.assign(BinaryReader.prototype, {\n\n\t\t\t\tgetOffset: function () {\n\n\t\t\t\t\t\treturn this.offset;\n\t\t\t\t},\n\n\t\t\t\tsize: function () {\n\n\t\t\t\t\t\treturn this.dv.buffer.byteLength;\n\t\t\t\t},\n\n\t\t\t\tskip: function (length) {\n\n\t\t\t\t\t\tthis.offset += length;\n\t\t\t\t},\n\n\t\t\t\t// seems like true/false representation depends on exporter.\n\t\t\t\t// true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n\t\t\t\t// then sees LSB.\n\t\t\t\tgetBoolean: function () {\n\n\t\t\t\t\t\treturn (this.getUint8() & 1) === 1;\n\t\t\t\t},\n\n\t\t\t\tgetBooleanArray: function (size) {\n\n\t\t\t\t\t\tvar a = [];\n\n\t\t\t\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\t\t\t\t\ta.push(this.getBoolean());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn a;\n\t\t\t\t},\n\n\t\t\t\tgetInt8: function () {\n\n\t\t\t\t\t\tvar value = this.dv.getInt8(this.offset);\n\t\t\t\t\t\tthis.offset += 1;\n\t\t\t\t\t\treturn value;\n\t\t\t\t},\n\n\t\t\t\tgetInt8Array: function (size) {\n\n\t\t\t\t\t\tvar a = [];\n\n\t\t\t\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\t\t\t\t\ta.push(this.getInt8());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn a;\n\t\t\t\t},\n\n\t\t\t\tgetUint8: function () {\n\n\t\t\t\t\t\tvar value = this.dv.getUint8(this.offset);\n\t\t\t\t\t\tthis.offset += 1;\n\t\t\t\t\t\treturn value;\n\t\t\t\t},\n\n\t\t\t\tgetUint8Array: function (size) {\n\n\t\t\t\t\t\tvar a = [];\n\n\t\t\t\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\t\t\t\t\ta.push(this.getUint8());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn a;\n\t\t\t\t},\n\n\t\t\t\tgetInt16: function () {\n\n\t\t\t\t\t\tvar value = this.dv.getInt16(this.offset, this.littleEndian);\n\t\t\t\t\t\tthis.offset += 2;\n\t\t\t\t\t\treturn value;\n\t\t\t\t},\n\n\t\t\t\tgetInt16Array: function (size) {\n\n\t\t\t\t\t\tvar a = [];\n\n\t\t\t\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\t\t\t\t\ta.push(this.getInt16());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn a;\n\t\t\t\t},\n\n\t\t\t\tgetUint16: function () {\n\n\t\t\t\t\t\tvar value = this.dv.getUint16(this.offset, this.littleEndian);\n\t\t\t\t\t\tthis.offset += 2;\n\t\t\t\t\t\treturn value;\n\t\t\t\t},\n\n\t\t\t\tgetUint16Array: function (size) {\n\n\t\t\t\t\t\tvar a = [];\n\n\t\t\t\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\t\t\t\t\ta.push(this.getUint16());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn a;\n\t\t\t\t},\n\n\t\t\t\tgetInt32: function () {\n\n\t\t\t\t\t\tvar value = this.dv.getInt32(this.offset, this.littleEndian);\n\t\t\t\t\t\tthis.offset += 4;\n\t\t\t\t\t\treturn value;\n\t\t\t\t},\n\n\t\t\t\tgetInt32Array: function (size) {\n\n\t\t\t\t\t\tvar a = [];\n\n\t\t\t\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\t\t\t\t\ta.push(this.getInt32());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn a;\n\t\t\t\t},\n\n\t\t\t\tgetUint32: function () {\n\n\t\t\t\t\t\tvar value = this.dv.getUint32(this.offset, this.littleEndian);\n\t\t\t\t\t\tthis.offset += 4;\n\t\t\t\t\t\treturn value;\n\t\t\t\t},\n\n\t\t\t\tgetUint32Array: function (size) {\n\n\t\t\t\t\t\tvar a = [];\n\n\t\t\t\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\t\t\t\t\ta.push(this.getUint32());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn a;\n\t\t\t\t},\n\n\t\t\t\t// JavaScript doesn't support 64-bit integer so calculate this here\n\t\t\t\t// 1 << 32 will return 1 so using multiply operation instead here.\n\t\t\t\t// There's a possibility that this method returns wrong value if the value\n\t\t\t\t// is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n\t\t\t\t// TODO: safely handle 64-bit integer\n\t\t\t\tgetInt64: function () {\n\n\t\t\t\t\t\tvar low, high;\n\n\t\t\t\t\t\tif (this.littleEndian) {\n\n\t\t\t\t\t\t\t\tlow = this.getUint32();\n\t\t\t\t\t\t\t\thigh = this.getUint32();\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\thigh = this.getUint32();\n\t\t\t\t\t\t\t\tlow = this.getUint32();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// calculate negative value\n\t\t\t\t\t\tif (high & 0x80000000) {\n\n\t\t\t\t\t\t\t\thigh = ~high & 0xFFFFFFFF;\n\t\t\t\t\t\t\t\tlow = ~low & 0xFFFFFFFF;\n\n\t\t\t\t\t\t\t\tif (low === 0xFFFFFFFF) high = high + 1 & 0xFFFFFFFF;\n\n\t\t\t\t\t\t\t\tlow = low + 1 & 0xFFFFFFFF;\n\n\t\t\t\t\t\t\t\treturn -(high * 0x100000000 + low);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn high * 0x100000000 + low;\n\t\t\t\t},\n\n\t\t\t\tgetInt64Array: function (size) {\n\n\t\t\t\t\t\tvar a = [];\n\n\t\t\t\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\t\t\t\t\ta.push(this.getInt64());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn a;\n\t\t\t\t},\n\n\t\t\t\t// Note: see getInt64() comment\n\t\t\t\tgetUint64: function () {\n\n\t\t\t\t\t\tvar low, high;\n\n\t\t\t\t\t\tif (this.littleEndian) {\n\n\t\t\t\t\t\t\t\tlow = this.getUint32();\n\t\t\t\t\t\t\t\thigh = this.getUint32();\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\thigh = this.getUint32();\n\t\t\t\t\t\t\t\tlow = this.getUint32();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn high * 0x100000000 + low;\n\t\t\t\t},\n\n\t\t\t\tgetUint64Array: function (size) {\n\n\t\t\t\t\t\tvar a = [];\n\n\t\t\t\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\t\t\t\t\ta.push(this.getUint64());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn a;\n\t\t\t\t},\n\n\t\t\t\tgetFloat32: function () {\n\n\t\t\t\t\t\tvar value = this.dv.getFloat32(this.offset, this.littleEndian);\n\t\t\t\t\t\tthis.offset += 4;\n\t\t\t\t\t\treturn value;\n\t\t\t\t},\n\n\t\t\t\tgetFloat32Array: function (size) {\n\n\t\t\t\t\t\tvar a = [];\n\n\t\t\t\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\t\t\t\t\ta.push(this.getFloat32());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn a;\n\t\t\t\t},\n\n\t\t\t\tgetFloat64: function () {\n\n\t\t\t\t\t\tvar value = this.dv.getFloat64(this.offset, this.littleEndian);\n\t\t\t\t\t\tthis.offset += 8;\n\t\t\t\t\t\treturn value;\n\t\t\t\t},\n\n\t\t\t\tgetFloat64Array: function (size) {\n\n\t\t\t\t\t\tvar a = [];\n\n\t\t\t\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\t\t\t\t\ta.push(this.getFloat64());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn a;\n\t\t\t\t},\n\n\t\t\t\tgetArrayBuffer: function (size) {\n\n\t\t\t\t\t\tvar value = this.dv.buffer.slice(this.offset, this.offset + size);\n\t\t\t\t\t\tthis.offset += size;\n\t\t\t\t\t\treturn value;\n\t\t\t\t},\n\n\t\t\t\tgetChar: function () {\n\n\t\t\t\t\t\treturn String.fromCharCode(this.getUint8());\n\t\t\t\t},\n\n\t\t\t\tgetString: function (size) {\n\n\t\t\t\t\t\tvar s = '';\n\n\t\t\t\t\t\twhile (size > 0) {\n\n\t\t\t\t\t\t\t\tvar value = this.getUint8();\n\t\t\t\t\t\t\t\tsize--;\n\n\t\t\t\t\t\t\t\tif (value === 0) break;\n\n\t\t\t\t\t\t\t\ts += String.fromCharCode(value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Manage UTF8 encoding\n\t\t\t\t\t\ts = decodeURIComponent(escape(s));\n\n\t\t\t\t\t\tthis.skip(size);\n\n\t\t\t\t\t\treturn s;\n\t\t\t\t}\n\n\t\t});\n\n\t\t// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\n\t\t// and BinaryParser( FBX Binary format)\n\t\tfunction FBXTree() {}\n\n\t\tObject.assign(FBXTree.prototype, {\n\n\t\t\t\tadd: function (key, val) {\n\n\t\t\t\t\t\tthis[key] = val;\n\t\t\t\t}\n\n\t\t});\n\n\t\tfunction isFbxFormatBinary(buffer) {\n\n\t\t\t\tvar CORRECT = 'Kaydara FBX Binary  \\0';\n\n\t\t\t\treturn buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);\n\t\t}\n\n\t\tfunction isFbxFormatASCII(text) {\n\n\t\t\t\tvar CORRECT = ['K', 'a', 'y', 'd', 'a', 'r', 'a', '\\\\', 'F', 'B', 'X', '\\\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\\\', '\\\\'];\n\n\t\t\t\tvar cursor = 0;\n\n\t\t\t\tfunction read(offset) {\n\n\t\t\t\t\t\tvar result = text[offset - 1];\n\t\t\t\t\t\ttext = text.slice(cursor + offset);\n\t\t\t\t\t\tcursor++;\n\t\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0; i < CORRECT.length; ++i) {\n\n\t\t\t\t\t\tvar num = read(1);\n\t\t\t\t\t\tif (num === CORRECT[i]) {\n\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t}\n\n\t\tfunction getFbxVersion(text) {\n\n\t\t\t\tvar versionRegExp = /FBXVersion: (\\d+)/;\n\t\t\t\tvar match = text.match(versionRegExp);\n\t\t\t\tif (match) {\n\n\t\t\t\t\t\tvar version = parseInt(match[1]);\n\t\t\t\t\t\treturn version;\n\t\t\t\t}\n\t\t\t\tthrow new Error('THREE.FBXLoader: Cannot find the version number for the file given.');\n\t\t}\n\n\t\t// Converts FBX ticks into real time seconds.\n\t\tfunction convertFBXTimeToSeconds(time) {\n\n\t\t\t\treturn time / 46186158000;\n\t\t}\n\n\t\t// Parses comma separated list of numbers and returns them an array.\n\t\t// Used internally by the TextParser\n\t\tfunction parseNumberArray(value) {\n\n\t\t\t\tvar array = value.split(',');\n\n\t\t\t\tfor (var i = 0, l = array.length; i < l; i++) {\n\n\t\t\t\t\t\tarray[i] = parseFloat(array[i]);\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\t\t}\n\n\t\tfunction parseVector3(property) {\n\n\t\t\t\treturn new THREE.Vector3().fromArray(property.value);\n\t\t}\n\n\t\tfunction parseColor(property) {\n\n\t\t\t\treturn new THREE.Color().fromArray(property.value);\n\t\t}\n\n\t\t// Converts ArrayBuffer to String.\n\t\tfunction convertArrayBufferToString(buffer, from, to) {\n\n\t\t\t\tif (from === undefined) from = 0;\n\t\t\t\tif (to === undefined) to = buffer.byteLength;\n\n\t\t\t\tvar array = new Uint8Array(buffer, from, to);\n\n\t\t\t\tif (window.TextDecoder !== undefined) {\n\n\t\t\t\t\t\treturn new TextDecoder().decode(array);\n\t\t\t\t}\n\n\t\t\t\tvar s = '';\n\n\t\t\t\tfor (var i = 0, il = array.length; i < il; i++) {\n\t\t\t\t\t\ts += String.fromCharCode(array[i]);\n\t\t\t\t}\n\n\t\t\t\treturn s;\n\t\t}\n\n\t\tfunction findIndex(array, func) {\n\t\t\t\tfor (var i = 0, l = array.length; i < l; i++) {\n\t\t\t\t\t\tif (func(array[i])) return i;\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tfunction append(a, b) {\n\t\t\t\tfor (var i = 0, j = a.length, l = b.length; i < l; i++, j++) {\n\t\t\t\t\t\ta[j] = b[i];\n\t\t\t\t}\n\t\t}\n\n\t\tfunction slice(a, b, from, to) {\n\t\t\t\tfor (var i = from, j = 0; i < to; i++, j++) {\n\t\t\t\t\t\ta[j] = b[i];\n\t\t\t\t}\n\n\t\t\t\treturn a;\n\t\t}\n})();\n\n//# sourceURL=webpack://CLM/./js/lib/loaders/FBXLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/MTLLoader.js":
/*!*************************************!*\
  !*** ./js/lib/loaders/MTLLoader.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * Loads a Wavefront .mtl file specifying materials\r\n *\r\n * @author angelxuanchang\r\n */\n\nTHREE.MTLLoader = function (manager) {\n\n\t\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n};\n\nTHREE.MTLLoader.prototype = {\n\n\t\tconstructor: THREE.MTLLoader,\n\n\t\t/**\r\n   * Loads and parses a MTL asset from a URL.\r\n   *\r\n   * @param {String} url - URL to the MTL file.\r\n   * @param {Function} [onLoad] - Callback invoked with the loaded object.\r\n   * @param {Function} [onProgress] - Callback for download progress.\r\n   * @param {Function} [onError] - Callback for download errors.\r\n   *\r\n   * @see setPath setTexturePath\r\n   *\r\n   * @note In order for relative texture references to resolve correctly\r\n   * you must call setPath and/or setTexturePath explicitly prior to load.\r\n   */\n\t\tload: function (url, onLoad, onProgress, onError) {\n\n\t\t\t\tvar scope = this;\n\n\t\t\t\tvar loader = new THREE.FileLoader(this.manager);\n\t\t\t\tloader.setPath(this.path);\n\t\t\t\tloader.load(url, function (text) {\n\n\t\t\t\t\t\tonLoad(scope.parse(text));\n\t\t\t\t}, onProgress, onError);\n\t\t},\n\n\t\t/**\r\n   * Set base path for resolving references.\r\n   * If set this path will be prepended to each loaded and found reference.\r\n   *\r\n   * @see setTexturePath\r\n   * @param {String} path\r\n   *\r\n   * @example\r\n   *     mtlLoader.setPath( 'assets/obj/' );\r\n   *     mtlLoader.load( 'my.mtl', ... );\r\n   */\n\t\tsetPath: function (path) {\n\n\t\t\t\tthis.path = path;\n\t\t},\n\n\t\t/**\r\n   * Set base path for resolving texture references.\r\n   * If set this path will be prepended found texture reference.\r\n   * If not set and setPath is, it will be used as texture base path.\r\n   *\r\n   * @see setPath\r\n   * @param {String} path\r\n   *\r\n   * @example\r\n   *     mtlLoader.setPath( 'assets/obj/' );\r\n   *     mtlLoader.setTexturePath( 'assets/textures/' );\r\n   *     mtlLoader.load( 'my.mtl', ... );\r\n   */\n\t\tsetTexturePath: function (path) {\n\n\t\t\t\tthis.texturePath = path;\n\t\t},\n\n\t\tsetBaseUrl: function (path) {\n\n\t\t\t\tconsole.warn('THREE.MTLLoader: .setBaseUrl() is deprecated. Use .setTexturePath( path ) for texture path or .setPath( path ) for general base path instead.');\n\n\t\t\t\tthis.setTexturePath(path);\n\t\t},\n\n\t\tsetCrossOrigin: function (value) {\n\n\t\t\t\tthis.crossOrigin = value;\n\t\t},\n\n\t\tsetMaterialOptions: function (value) {\n\n\t\t\t\tthis.materialOptions = value;\n\t\t},\n\n\t\t/**\r\n   * Parses a MTL file.\r\n   *\r\n   * @param {String} text - Content of MTL file\r\n   * @return {THREE.MTLLoader.MaterialCreator}\r\n   *\r\n   * @see setPath setTexturePath\r\n   *\r\n   * @note In order for relative texture references to resolve correctly\r\n   * you must call setPath and/or setTexturePath explicitly prior to parse.\r\n   */\n\t\tparse: function (text) {\n\n\t\t\t\tvar lines = text.split('\\n');\n\t\t\t\tvar info = {};\n\t\t\t\tvar delimiter_pattern = /\\s+/;\n\t\t\t\tvar materialsInfo = {};\n\n\t\t\t\tfor (var i = 0; i < lines.length; i++) {\n\n\t\t\t\t\t\tvar line = lines[i];\n\t\t\t\t\t\tline = line.trim();\n\n\t\t\t\t\t\tif (line.length === 0 || line.charAt(0) === '#') {\n\n\t\t\t\t\t\t\t\t// Blank line or comment ignore\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar pos = line.indexOf(' ');\n\n\t\t\t\t\t\tvar key = pos >= 0 ? line.substring(0, pos) : line;\n\t\t\t\t\t\tkey = key.toLowerCase();\n\n\t\t\t\t\t\tvar value = pos >= 0 ? line.substring(pos + 1) : '';\n\t\t\t\t\t\tvalue = value.trim();\n\n\t\t\t\t\t\tif (key === 'newmtl') {\n\n\t\t\t\t\t\t\t\t// New material\n\n\t\t\t\t\t\t\t\tinfo = { name: value };\n\t\t\t\t\t\t\t\tmaterialsInfo[value] = info;\n\t\t\t\t\t\t} else if (info) {\n\n\t\t\t\t\t\t\t\tif (key === 'ka' || key === 'kd' || key === 'ks') {\n\n\t\t\t\t\t\t\t\t\t\tvar ss = value.split(delimiter_pattern, 3);\n\t\t\t\t\t\t\t\t\t\tinfo[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tinfo[key] = value;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar materialCreator = new THREE.MTLLoader.MaterialCreator(this.texturePath || this.path, this.materialOptions);\n\t\t\t\tmaterialCreator.setCrossOrigin(this.crossOrigin);\n\t\t\t\tmaterialCreator.setManager(this.manager);\n\t\t\t\tmaterialCreator.setMaterials(materialsInfo);\n\t\t\t\treturn materialCreator;\n\t\t}\n\n};\n\n/**\r\n * Create a new THREE-MTLLoader.MaterialCreator\r\n * @param baseUrl - Url relative to which textures are loaded\r\n * @param options - Set of options on how to construct the materials\r\n *                  side: Which side to apply the material\r\n *                        THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide\r\n *                  wrap: What type of wrapping to apply for textures\r\n *                        THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\r\n *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\r\n *                                Default: false, assumed to be already normalized\r\n *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\r\n *                                  Default: false\r\n * @constructor\r\n */\n\nTHREE.MTLLoader.MaterialCreator = function (baseUrl, options) {\n\n\t\tthis.baseUrl = baseUrl || '';\n\t\tthis.options = options;\n\t\tthis.materialsInfo = {};\n\t\tthis.materials = {};\n\t\tthis.materialsArray = [];\n\t\tthis.nameLookup = {};\n\n\t\tthis.side = this.options && this.options.side ? this.options.side : THREE.FrontSide;\n\t\tthis.wrap = this.options && this.options.wrap ? this.options.wrap : THREE.RepeatWrapping;\n};\n\nTHREE.MTLLoader.MaterialCreator.prototype = {\n\n\t\tconstructor: THREE.MTLLoader.MaterialCreator,\n\n\t\tcrossOrigin: 'Anonymous',\n\n\t\tsetCrossOrigin: function (value) {\n\n\t\t\t\tthis.crossOrigin = value;\n\t\t},\n\n\t\tsetManager: function (value) {\n\n\t\t\t\tthis.manager = value;\n\t\t},\n\n\t\tsetMaterials: function (materialsInfo) {\n\n\t\t\t\tthis.materialsInfo = this.convert(materialsInfo);\n\t\t\t\tthis.materials = {};\n\t\t\t\tthis.materialsArray = [];\n\t\t\t\tthis.nameLookup = {};\n\t\t},\n\n\t\tconvert: function (materialsInfo) {\n\n\t\t\t\tif (!this.options) return materialsInfo;\n\n\t\t\t\tvar converted = {};\n\n\t\t\t\tfor (var mn in materialsInfo) {\n\n\t\t\t\t\t\t// Convert materials info into normalized form based on options\n\n\t\t\t\t\t\tvar mat = materialsInfo[mn];\n\n\t\t\t\t\t\tvar covmat = {};\n\n\t\t\t\t\t\tconverted[mn] = covmat;\n\n\t\t\t\t\t\tfor (var prop in mat) {\n\n\t\t\t\t\t\t\t\tvar save = true;\n\t\t\t\t\t\t\t\tvar value = mat[prop];\n\t\t\t\t\t\t\t\tvar lprop = prop.toLowerCase();\n\n\t\t\t\t\t\t\t\tswitch (lprop) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'kd':\n\t\t\t\t\t\t\t\t\t\tcase 'ka':\n\t\t\t\t\t\t\t\t\t\tcase 'ks':\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (this.options && this.options.normalizeRGB) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue = [value[0] / 255, value[1] / 255, value[2] / 255];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (this.options && this.options.ignoreZeroRGBs) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (value[0] === 0 && value[1] === 0 && value[2] === 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ignore\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsave = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (save) {\n\n\t\t\t\t\t\t\t\t\t\tcovmat[lprop] = value;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn converted;\n\t\t},\n\n\t\tpreload: function () {\n\n\t\t\t\tfor (var mn in this.materialsInfo) {\n\n\t\t\t\t\t\tthis.create(mn);\n\t\t\t\t}\n\t\t},\n\n\t\tgetIndex: function (materialName) {\n\n\t\t\t\treturn this.nameLookup[materialName];\n\t\t},\n\n\t\tgetAsArray: function () {\n\n\t\t\t\tvar index = 0;\n\n\t\t\t\tfor (var mn in this.materialsInfo) {\n\n\t\t\t\t\t\tthis.materialsArray[index] = this.create(mn);\n\t\t\t\t\t\tthis.nameLookup[mn] = index;\n\t\t\t\t\t\tindex++;\n\t\t\t\t}\n\n\t\t\t\treturn this.materialsArray;\n\t\t},\n\n\t\tcreate: function (materialName) {\n\n\t\t\t\tif (this.materials[materialName] === undefined) {\n\n\t\t\t\t\t\tthis.createMaterial_(materialName);\n\t\t\t\t}\n\n\t\t\t\treturn this.materials[materialName];\n\t\t},\n\n\t\tcreateMaterial_: function (materialName) {\n\n\t\t\t\t// Create material\n\n\t\t\t\tvar scope = this;\n\t\t\t\tvar mat = this.materialsInfo[materialName];\n\t\t\t\tvar params = {\n\n\t\t\t\t\t\tname: materialName,\n\t\t\t\t\t\tside: this.side\n\n\t\t\t\t};\n\n\t\t\t\tfunction resolveURL(baseUrl, url) {\n\n\t\t\t\t\t\tif (typeof url !== 'string' || url === '') return '';\n\n\t\t\t\t\t\t// Absolute URL\n\t\t\t\t\t\tif (/^https?:\\/\\//i.test(url)) return url;\n\n\t\t\t\t\t\treturn baseUrl + url;\n\t\t\t\t}\n\n\t\t\t\tfunction setMapForType(mapType, value) {\n\n\t\t\t\t\t\tif (params[mapType]) return; // Keep the first encountered texture\n\n\t\t\t\t\t\tvar texParams = scope.getTextureParams(value, params);\n\t\t\t\t\t\tvar map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));\n\n\t\t\t\t\t\tmap.repeat.copy(texParams.scale);\n\t\t\t\t\t\tmap.offset.copy(texParams.offset);\n\n\t\t\t\t\t\tmap.wrapS = scope.wrap;\n\t\t\t\t\t\tmap.wrapT = scope.wrap;\n\n\t\t\t\t\t\tparams[mapType] = map;\n\t\t\t\t}\n\n\t\t\t\tfor (var prop in mat) {\n\n\t\t\t\t\t\tvar value = mat[prop];\n\t\t\t\t\t\tvar n;\n\n\t\t\t\t\t\tif (value === '') continue;\n\n\t\t\t\t\t\tswitch (prop.toLowerCase()) {\n\n\t\t\t\t\t\t\t\t// Ns is material specular exponent\n\n\t\t\t\t\t\t\t\tcase 'kd':\n\n\t\t\t\t\t\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\t\t\t\t\t\tparams.color = new THREE.Color().fromArray(value);\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 'ks':\n\n\t\t\t\t\t\t\t\t\t\t// Specular color (color when light is reflected from shiny surface) using RGB values\n\t\t\t\t\t\t\t\t\t\tparams.specular = new THREE.Color().fromArray(value);\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 'map_kd':\n\n\t\t\t\t\t\t\t\t\t\t// Diffuse texture map\n\n\t\t\t\t\t\t\t\t\t\tsetMapForType(\"map\", value);\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 'map_ks':\n\n\t\t\t\t\t\t\t\t\t\t// Specular map\n\n\t\t\t\t\t\t\t\t\t\tsetMapForType(\"specularMap\", value);\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 'norm':\n\n\t\t\t\t\t\t\t\t\t\tsetMapForType(\"normalMap\", value);\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 'map_bump':\n\t\t\t\t\t\t\t\tcase 'bump':\n\n\t\t\t\t\t\t\t\t\t\t// Bump texture map\n\n\t\t\t\t\t\t\t\t\t\tsetMapForType(\"bumpMap\", value);\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 'ns':\n\n\t\t\t\t\t\t\t\t\t\t// The specular exponent (defines the focus of the specular highlight)\n\t\t\t\t\t\t\t\t\t\t// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n\n\t\t\t\t\t\t\t\t\t\tparams.shininess = parseFloat(value);\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\t\t\t\tn = parseFloat(value);\n\n\t\t\t\t\t\t\t\t\t\tif (n < 1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tparams.opacity = n;\n\t\t\t\t\t\t\t\t\t\t\t\tparams.transparent = true;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 'tr':\n\t\t\t\t\t\t\t\t\t\tn = parseFloat(value);\n\n\t\t\t\t\t\t\t\t\t\tif (n > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tparams.opacity = 1 - n;\n\t\t\t\t\t\t\t\t\t\t\t\tparams.transparent = true;\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.materials[materialName] = new THREE.MeshPhongMaterial(params);\n\t\t\t\treturn this.materials[materialName];\n\t\t},\n\n\t\tgetTextureParams: function (value, matParams) {\n\n\t\t\t\tvar texParams = {\n\n\t\t\t\t\t\tscale: new THREE.Vector2(1, 1),\n\t\t\t\t\t\toffset: new THREE.Vector2(0, 0)\n\n\t\t\t\t};\n\n\t\t\t\tvar items = value.split(/\\s+/);\n\t\t\t\tvar pos;\n\n\t\t\t\tpos = items.indexOf('-bm');\n\n\t\t\t\tif (pos >= 0) {\n\n\t\t\t\t\t\tmatParams.bumpScale = parseFloat(items[pos + 1]);\n\t\t\t\t\t\titems.splice(pos, 2);\n\t\t\t\t}\n\n\t\t\t\tpos = items.indexOf('-s');\n\n\t\t\t\tif (pos >= 0) {\n\n\t\t\t\t\t\ttexParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n\t\t\t\t\t\titems.splice(pos, 4); // we expect 3 parameters here!\n\t\t\t\t}\n\n\t\t\t\tpos = items.indexOf('-o');\n\n\t\t\t\tif (pos >= 0) {\n\n\t\t\t\t\t\ttexParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));\n\t\t\t\t\t\titems.splice(pos, 4); // we expect 3 parameters here!\n\t\t\t\t}\n\n\t\t\t\ttexParams.url = items.join(' ').trim();\n\t\t\t\treturn texParams;\n\t\t},\n\n\t\tloadTexture: function (url, mapping, onLoad, onProgress, onError) {\n\n\t\t\t\tvar texture;\n\t\t\t\tvar loader = THREE.Loader.Handlers.get(url);\n\t\t\t\tvar manager = this.manager !== undefined ? this.manager : THREE.DefaultLoadingManager;\n\n\t\t\t\tif (loader === null) {\n\n\t\t\t\t\t\tloader = new THREE.TextureLoader(manager);\n\t\t\t\t}\n\n\t\t\t\tif (loader.setCrossOrigin) loader.setCrossOrigin(this.crossOrigin);\n\t\t\t\ttexture = loader.load(url, onLoad, onProgress, onError);\n\n\t\t\t\tif (mapping !== undefined) texture.mapping = mapping;\n\n\t\t\t\treturn texture;\n\t\t}\n\n};\n\n//# sourceURL=webpack://CLM/./js/lib/loaders/MTLLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/OBJLoader.js":
/*!*************************************!*\
  !*** ./js/lib/loaders/OBJLoader.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\nTHREE.OBJLoader = function () {\n\n\t\t\t\t// o object_name | g group_name\n\t\t\t\tvar object_pattern = /^[og]\\s*(.+)?/;\n\t\t\t\t// mtllib file_reference\n\t\t\t\tvar material_library_pattern = /^mtllib /;\n\t\t\t\t// usemtl material_name\n\t\t\t\tvar material_use_pattern = /^usemtl /;\n\n\t\t\t\tfunction ParserState() {\n\n\t\t\t\t\t\t\t\tvar state = {\n\t\t\t\t\t\t\t\t\t\t\t\tobjects: [],\n\t\t\t\t\t\t\t\t\t\t\t\tobject: {},\n\n\t\t\t\t\t\t\t\t\t\t\t\tvertices: [],\n\t\t\t\t\t\t\t\t\t\t\t\tnormals: [],\n\t\t\t\t\t\t\t\t\t\t\t\tcolors: [],\n\t\t\t\t\t\t\t\t\t\t\t\tuvs: [],\n\n\t\t\t\t\t\t\t\t\t\t\t\tmaterialLibraries: [],\n\n\t\t\t\t\t\t\t\t\t\t\t\tstartObject: function (name, fromDeclaration) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// If the current object (initial from reset) is not from a g/o declaration in the parsed\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// file. We need to use it for the first parsed g/o to keep things in sync.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (this.object && this.object.fromDeclaration === false) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.object.name = name;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.object.fromDeclaration = fromDeclaration !== false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (this.object && typeof this.object._finalize === 'function') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.object._finalize(true);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.object = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tname: name || '',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfromDeclaration: fromDeclaration !== false,\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvertices: [],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormals: [],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolors: [],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tuvs: []\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterials: [],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsmooth: true,\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstartMaterial: function (name, libraries) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar previous = this._finalize(false);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// New usemtl declaration overwrites an inherited material, except if faces were declared\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// after the material, then it must be preserved for proper MultiMaterial continuation.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (previous && (previous.inherited || previous.groupCount <= 0)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.materials.splice(previous.index, 1);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar material = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindex: this.materials.length,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tname: name || '',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsmooth: previous !== undefined ? previous.smooth : this.smooth,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgroupStart: previous !== undefined ? previous.groupEnd : 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgroupEnd: -1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgroupCount: -1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinherited: false,\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tclone: function (index) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar cloned = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindex: typeof index === 'number' ? index : this.index,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tname: this.name,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmtllib: this.mtllib,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsmooth: this.smooth,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgroupStart: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgroupEnd: -1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgroupCount: -1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinherited: false\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcloned.clone = this.clone.bind(cloned);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn cloned;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.materials.push(material);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn material;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentMaterial: function () {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (this.materials.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.materials[this.materials.length - 1];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t_finalize: function (end) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar lastMultiMaterial = this.currentMaterial();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlastMultiMaterial.inherited = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Ignore objects tail materials if no face declarations followed them before a new o/g started.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (end && this.materials.length > 1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var mi = this.materials.length - 1; mi >= 0; mi--) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (this.materials[mi].groupCount <= 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.materials.splice(mi, 1);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Guarantee at least one empty material, this makes the creation later more straight forward.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (end && this.materials.length === 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.materials.push({\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tname: '',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsmooth: this.smooth\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn lastMultiMaterial;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Inherit previous objects material.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Spec tells us that a declared material must be set to all objects until a new material is declared.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// If a usemtl declaration is encountered while this new object is being parsed, it will\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// overwrite the inherited material. Exception being that there was already face declarations\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar declared = previousMaterial.clone(0);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdeclared.inherited = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.object.materials.push(declared);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.objects.push(this.object);\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\tfinalize: function () {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (this.object && typeof this.object._finalize === 'function') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.object._finalize(true);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\tparseVertexIndex: function (value, len) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar index = parseInt(value, 10);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn (index >= 0 ? index - 1 : index + len / 3) * 3;\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\tparseNormalIndex: function (value, len) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar index = parseInt(value, 10);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn (index >= 0 ? index - 1 : index + len / 3) * 3;\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\tparseUVIndex: function (value, len) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar index = parseInt(value, 10);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn (index >= 0 ? index - 1 : index + len / 2) * 2;\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\taddVertex: function (a, b, c) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar src = this.vertices;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[a + 0], src[a + 1], src[a + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[b + 0], src[b + 1], src[b + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[c + 0], src[c + 1], src[c + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\taddVertexPoint: function (a) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar src = this.vertices;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[a + 0], src[a + 1], src[a + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\taddVertexLine: function (a) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar src = this.vertices;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[a + 0], src[a + 1], src[a + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\taddNormal: function (a, b, c) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar src = this.normals;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar dst = this.object.geometry.normals;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[a + 0], src[a + 1], src[a + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[b + 0], src[b + 1], src[b + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[c + 0], src[c + 1], src[c + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\taddColor: function (a, b, c) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar src = this.colors;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar dst = this.object.geometry.colors;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[a + 0], src[a + 1], src[a + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[b + 0], src[b + 1], src[b + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[c + 0], src[c + 1], src[c + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\taddUV: function (a, b, c) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar src = this.uvs;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar dst = this.object.geometry.uvs;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[a + 0], src[a + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[b + 0], src[b + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[c + 0], src[c + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\taddUVLine: function (a) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar src = this.uvs;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar dst = this.object.geometry.uvs;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[a + 0], src[a + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\taddFace: function (a, b, c, ua, ub, uc, na, nb, nc) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar vLen = this.vertices.length;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar ia = this.parseVertexIndex(a, vLen);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar ib = this.parseVertexIndex(b, vLen);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar ic = this.parseVertexIndex(c, vLen);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.addVertex(ia, ib, ic);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (ua !== undefined && ua !== '') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar uvLen = this.uvs.length;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tia = this.parseUVIndex(ua, uvLen);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tib = this.parseUVIndex(ub, uvLen);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tic = this.parseUVIndex(uc, uvLen);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.addUV(ia, ib, ic);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (na !== undefined && na !== '') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Normals are many times the same. If so, skip function call and parseInt.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar nLen = this.normals.length;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tia = this.parseNormalIndex(na, nLen);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tib = na === nb ? ia : this.parseNormalIndex(nb, nLen);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tic = na === nc ? ia : this.parseNormalIndex(nc, nLen);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.addNormal(ia, ib, ic);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (this.colors.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.addColor(ia, ib, ic);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\taddPointGeometry: function (vertices) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.object.geometry.type = 'Points';\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar vLen = this.vertices.length;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var vi = 0, l = vertices.length; vi < l; vi++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.addVertexPoint(this.parseVertexIndex(vertices[vi], vLen));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\taddLineGeometry: function (vertices, uvs) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.object.geometry.type = 'Line';\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar vLen = this.vertices.length;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar uvLen = this.uvs.length;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var vi = 0, l = vertices.length; vi < l; vi++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var uvi = 0, l = uvs.length; uvi < l; uvi++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tstate.startObject('', false);\n\n\t\t\t\t\t\t\t\treturn state;\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tfunction OBJLoader(manager) {\n\n\t\t\t\t\t\t\t\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\n\t\t\t\t\t\t\t\tthis.materials = null;\n\t\t\t\t}\n\n\t\t\t\tOBJLoader.prototype = {\n\n\t\t\t\t\t\t\t\tconstructor: OBJLoader,\n\n\t\t\t\t\t\t\t\tload: function (url, onLoad, onProgress, onError) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar scope = this;\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\t\t\t\t\t\t\t\t\t\t\tloader.setPath(this.path);\n\t\t\t\t\t\t\t\t\t\t\t\tloader.load(url, function (text) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tonLoad(scope.parse(text));\n\t\t\t\t\t\t\t\t\t\t\t\t}, onProgress, onError);\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\tsetPath: function (value) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.path = value;\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\tsetMaterials: function (materials) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.materials = materials;\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\tparse: function (text) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.time('OBJLoader');\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar state = new ParserState();\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (text.indexOf('\\r\\n') !== -1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// This is faster than String.split with regex that splits on both\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttext = text.replace(/\\r\\n/g, '\\n');\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (text.indexOf('\\\\\\n') !== -1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// join lines separated by a line continuation character (\\)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttext = text.replace(/\\\\\\n/g, '');\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar lines = text.split('\\n');\n\t\t\t\t\t\t\t\t\t\t\t\tvar line = '',\n\t\t\t\t\t\t\t\t\t\t\t\t    lineFirstChar = '';\n\t\t\t\t\t\t\t\t\t\t\t\tvar lineLength = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tvar result = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Faster to just trim left side of the line. Use if available.\n\t\t\t\t\t\t\t\t\t\t\t\tvar trimLeft = typeof ''.trimLeft === 'function';\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0, l = lines.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tline = lines[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tline = trimLeft ? line.trimLeft() : line.trim();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlineLength = line.length;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (lineLength === 0) continue;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlineFirstChar = line.charAt(0);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// @todo invoke passed in handler if any\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (lineFirstChar === '#') continue;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (lineFirstChar === 'v') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar data = line.split(/\\s+/);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tswitch (data[0]) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'v':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (data.length === 8) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'vn':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'vt':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate.uvs.push(parseFloat(data[1]), parseFloat(data[2]));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (lineFirstChar === 'f') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar lineData = line.substr(1).trim();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar vertexData = lineData.split(/\\s+/);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar faceVertices = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Parse the face vertex data into an easy to work with format\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var j = 0, jl = vertexData.length; j < jl; j++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar vertex = vertexData[j];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (vertex.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar vertexParts = vertex.split('/');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaceVertices.push(vertexParts);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Draw an edge between the first vertex and all subsequent vertices to form an n-gon\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar v1 = faceVertices[0];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var j = 1, jl = faceVertices.length - 1; j < jl; j++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar v2 = faceVertices[j];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar v3 = faceVertices[j + 1];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (lineFirstChar === 'l') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar lineParts = line.substring(1).trim().split(\" \");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar lineVertices = [],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    lineUVs = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (line.indexOf(\"/\") === -1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlineVertices = lineParts;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var li = 0, llen = lineParts.length; li < llen; li++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar parts = lineParts[li].split(\"/\");\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (parts[0] !== \"\") lineVertices.push(parts[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (parts[1] !== \"\") lineUVs.push(parts[1]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate.addLineGeometry(lineVertices, lineUVs);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (lineFirstChar === 'p') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar lineData = line.substr(1).trim();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar pointData = lineData.split(\" \");\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate.addPointGeometry(pointData);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if ((result = object_pattern.exec(line)) !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// o object_name\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// or\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// g group_name\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// var name = result[ 0 ].substr( 1 ).trim();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar name = (\" \" + result[0].substr(1).trim()).substr(1);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate.startObject(name);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (material_use_pattern.test(line)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// material\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate.object.startMaterial(line.substring(7).trim(), state.materialLibraries);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (material_library_pattern.test(line)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// mtl file\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate.materialLibraries.push(line.substring(7).trim());\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (lineFirstChar === 's') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tresult = line.split(' ');\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// smooth shading\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// but does not define a usemtl for each face set.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// where explicit usemtl defines geometry groups.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/*\r\n                     * http://paulbourke.net/dataformats/obj/\r\n                     * or\r\n                     * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf\r\n                     *\r\n                     * From chapter \"Grouping\" Syntax explanation \"s group_number\":\r\n                     * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.\r\n                     * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form\r\n                     * surfaces, smoothing groups are either turned on or off; there is no difference between values greater\r\n                     * than 0.\"\r\n                     */\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (result.length > 1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar value = result[1].trim().toLowerCase();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate.object.smooth = value !== '0' && value !== 'off';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ZBrush can produce \"s\" lines #11707\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate.object.smooth = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar material = state.object.currentMaterial();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (material) material.smooth = state.object.smooth;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Handle null terminated files without exception\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (line === '\\0') continue;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new Error('THREE.OBJLoader: Unexpected line: \"' + line + '\"');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tstate.finalize();\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar container = new THREE.Group();\n\t\t\t\t\t\t\t\t\t\t\t\tcontainer.materialLibraries = [].concat(state.materialLibraries);\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0, l = state.objects.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar object = state.objects[i];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar geometry = object.geometry;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar materials = object.materials;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar isLine = geometry.type === 'Line';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar isPoints = geometry.type === 'Points';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar hasVertexColors = false;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Skip o/g line declarations that did not follow with any faces\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (geometry.vertices.length === 0) continue;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar buffergeometry = new THREE.BufferGeometry();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffergeometry.addAttribute('position', new THREE.Float32BufferAttribute(geometry.vertices, 3));\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (geometry.normals.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffergeometry.addAttribute('normal', new THREE.Float32BufferAttribute(geometry.normals, 3));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffergeometry.computeVertexNormals();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (geometry.colors.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thasVertexColors = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffergeometry.addAttribute('color', new THREE.Float32BufferAttribute(geometry.colors, 3));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (geometry.uvs.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffergeometry.addAttribute('uv', new THREE.Float32BufferAttribute(geometry.uvs, 2));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Create materials\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar createdMaterials = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var mi = 0, miLen = materials.length; mi < miLen; mi++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar sourceMaterial = materials[mi];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar material = undefined;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (this.materials !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial = this.materials.create(sourceMaterial.name);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (isLine && material && !(material instanceof THREE.LineBasicMaterial)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar materialLine = new THREE.LineBasicMaterial();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterialLine.copy(material);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterialLine.lights = false; // TOFIX\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial = materialLine;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (isPoints && material && !(material instanceof THREE.PointsMaterial)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar materialPoints = new THREE.PointsMaterial({ size: 10, sizeAttenuation: false });\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterialLine.copy(material);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial = materialPoints;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (!material) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (isLine) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial = new THREE.LineBasicMaterial();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (isPoints) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial = new THREE.PointsMaterial({ size: 1, sizeAttenuation: false });\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial.name = sourceMaterial.name;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial.flatShading = sourceMaterial.smooth ? false : true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial.vertexColors = hasVertexColors ? THREE.VertexColors : THREE.NoColors;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcreatedMaterials.push(material);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Create mesh\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar mesh;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (createdMaterials.length > 1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var mi = 0, miLen = materials.length; mi < miLen; mi++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar sourceMaterial = materials[mi];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (isLine) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmesh = new THREE.LineSegments(buffergeometry, createdMaterials);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (isPoints) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmesh = new THREE.Points(buffergeometry, createdMaterials);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmesh = new THREE.Mesh(buffergeometry, createdMaterials);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (isLine) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmesh = new THREE.LineSegments(buffergeometry, createdMaterials[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (isPoints) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmesh = new THREE.Points(buffergeometry, createdMaterials[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmesh = new THREE.Mesh(buffergeometry, createdMaterials[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmesh.name = object.name;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontainer.add(mesh);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.timeEnd('OBJLoader');\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn container;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\treturn OBJLoader;\n}();\n\n//# sourceURL=webpack://CLM/./js/lib/loaders/OBJLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/index.js":
/*!*********************************!*\
  !*** ./js/lib/loaders/index.js ***!
  \*********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _MTLLoader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MTLLoader.js */ \"./js/lib/loaders/MTLLoader.js\");\n/* harmony import */ var _MTLLoader_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_MTLLoader_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _FBXLoader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FBXLoader.js */ \"./js/lib/loaders/FBXLoader.js\");\n/* harmony import */ var _FBXLoader_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_FBXLoader_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _OBJLoader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OBJLoader.js */ \"./js/lib/loaders/OBJLoader.js\");\n/* harmony import */ var _OBJLoader_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_OBJLoader_js__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\n//# sourceURL=webpack://CLM/./js/lib/loaders/index.js?");

/***/ }),

/***/ "./js/main.js":
/*!********************!*\
  !*** ./js/main.js ***!
  \********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules */ \"./js/modules/index.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./js/utils/index.js\");\n/**\r\n * App entry point.\r\n **/\n\n\n\n\nclass App {\n  constructor() {\n    this.active = false;\n    this.isMobile = Object(_utils__WEBPACK_IMPORTED_MODULE_1__[\"detectMobileAndTablet\"])();\n    this.scene = new _modules__WEBPACK_IMPORTED_MODULE_0__[\"Scene\"]();\n    this.renderer = new _modules__WEBPACK_IMPORTED_MODULE_0__[\"Renderer\"](this.scene);\n    this.surface = new _modules__WEBPACK_IMPORTED_MODULE_0__[\"Surface\"](this.scene, this.renderer, this.isMobile);\n    this.menu = new _utils__WEBPACK_IMPORTED_MODULE_1__[\"Menu\"](this);\n    this.loop();\n  }\n\n  deactivate() {\n    this.active = false;\n  }\n\n  activate() {\n    this.active = true;\n    this.now = performance.now();\n  }\n\n  loop() {\n    requestAnimationFrame(() => {\n      this.loop();\n    });\n    if (this.active) {\n      const t = performance.now();\n      const delta = (t - this.now) / 1000;\n      this.now = t;\n      this.scene.update(delta);\n      this.surface.update(delta);\n      this.renderer.draw(delta);\n      this.surface.draw();\n    }\n  }\n}\n\nwindow.onload = () => {\n  const app = new App();\n};\n\n//# sourceURL=webpack://CLM/./js/main.js?");

/***/ }),

/***/ "./js/modules/index.js":
/*!*****************************!*\
  !*** ./js/modules/index.js ***!
  \*****************************/
/*! exports provided: Renderer, Scene, Surface */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./renderer */ \"./js/modules/renderer.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Renderer\", function() { return _renderer__WEBPACK_IMPORTED_MODULE_0__[\"Renderer\"]; });\n\n/* harmony import */ var _scene__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scene */ \"./js/modules/scene.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Scene\", function() { return _scene__WEBPACK_IMPORTED_MODULE_1__[\"Scene\"]; });\n\n/* harmony import */ var _surface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./surface */ \"./js/modules/surface.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Surface\", function() { return _surface__WEBPACK_IMPORTED_MODULE_2__[\"Surface\"]; });\n\n\n\n\n\n//# sourceURL=webpack://CLM/./js/modules/index.js?");

/***/ }),

/***/ "./js/modules/loaders/index.js":
/*!*************************************!*\
  !*** ./js/modules/loaders/index.js ***!
  \*************************************/
/*! exports provided: Loader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loader */ \"./js/modules/loaders/loader.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Loader\", function() { return _loader__WEBPACK_IMPORTED_MODULE_0__[\"Loader\"]; });\n\n\n\n//# sourceURL=webpack://CLM/./js/modules/loaders/index.js?");

/***/ }),

/***/ "./js/modules/loaders/loader.js":
/*!**************************************!*\
  !*** ./js/modules/loaders/loader.js ***!
  \**************************************/
/*! exports provided: Loader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Loader\", function() { return Loader; });\n/* harmony import */ var _lib_loaders__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/loaders */ \"./js/lib/loaders/index.js\");\n/**\r\n ** Load FBX & OBJ files.\r\n **/\n\n\n\nclass Loader {\n  constructor(path) {\n    this.path = `${APP_ROOT}/${path}/`;\n    this.materials = {};\n    this.images = {};\n    this.loaderFBX = new THREE.FBXLoader();\n    this.loaderOBJ = new THREE.OBJLoader();\n  }\n\n  loadFBX(file) {\n    return new Promise((resolve, reject) => {\n      try {\n        this.loaderFBX.load(this.path + file + '.fbx', model => {\n          resolve(model);\n        });\n      } catch (error) {\n        console.log(error);\n        reject(error);\n      }\n    });\n  }\n\n  loadOBJ(file) {\n    return new Promise((resolve, reject) => {\n      try {\n        this.loaderOBJ.load(this.path + file + '.obj', model => {\n          resolve(model);\n        });\n      } catch (error) {\n        console.log(error);\n        reject(error);\n      }\n    });\n  }\n}\n\n\n\n//# sourceURL=webpack://CLM/./js/modules/loaders/loader.js?");

/***/ }),

/***/ "./js/modules/maths/general.js":
/*!*************************************!*\
  !*** ./js/modules/maths/general.js ***!
  \*************************************/
/*! exports provided: Blend, Clamp, MinAngleBetween, Rand, TwoPI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Blend\", function() { return Blend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Clamp\", function() { return Clamp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MinAngleBetween\", function() { return MinAngleBetween; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Rand\", function() { return Rand; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TwoPI\", function() { return TwoPI; });\nconst Blend = (a, b, factor) => {\n  return (b - a) * factor + a;\n};\n\nconst MinAngleBetween = function (a1, a2) {\n  return Math.atan2(Math.sin(a2 - a1), Math.cos(a2 - a1));\n};\n\nconst Rand = n => {\n  return Math.random() * n - n / 2;\n};\n\nconst TwoPI = Math.PI * 2;\n\nconst Clamp = (value, min, max) => {\n  return Math.min(max, Math.max(min, value));\n};\n\n\n\n//# sourceURL=webpack://CLM/./js/modules/maths/general.js?");

/***/ }),

/***/ "./js/modules/maths/index.js":
/*!***********************************!*\
  !*** ./js/modules/maths/index.js ***!
  \***********************************/
/*! exports provided: Blend, Clamp, MinAngleBetween, Rand, TwoPI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _general__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./general */ \"./js/modules/maths/general.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Blend\", function() { return _general__WEBPACK_IMPORTED_MODULE_0__[\"Blend\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Clamp\", function() { return _general__WEBPACK_IMPORTED_MODULE_0__[\"Clamp\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MinAngleBetween\", function() { return _general__WEBPACK_IMPORTED_MODULE_0__[\"MinAngleBetween\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Rand\", function() { return _general__WEBPACK_IMPORTED_MODULE_0__[\"Rand\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TwoPI\", function() { return _general__WEBPACK_IMPORTED_MODULE_0__[\"TwoPI\"]; });\n\n\n\n//# sourceURL=webpack://CLM/./js/modules/maths/index.js?");

/***/ }),

/***/ "./js/modules/renderer.js":
/*!********************************!*\
  !*** ./js/modules/renderer.js ***!
  \********************************/
/*! exports provided: Renderer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Renderer\", function() { return Renderer; });\n/* harmony import */ var _lib_glsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/glsl */ \"./js/lib/glsl/index.js\");\n/**\r\n * Webgl renderer.\r\n **/\n\n\n\nclass Renderer {\n  constructor(scene) {\n    this.scene = scene.scene;\n    this.camera = scene.camera.camera;\n    this.renderer = new THREE.WebGLRenderer({});\n    this.renderer.setClearColor(0x444444, 1);\n    this.renderer.gammaInput = true;\n    this.renderer.gammaOutput = true;\n    this.padding = { x: 64, y: 96, minX: 768, minY: 480 };\n    this.setSize();\n\n    // render passes\n    const strength = 0.5;\n    const radius = 0.125;\n    const threshold = 0.96;\n    this.passRender = new THREE.RenderPass(this.scene, this.camera);\n    //this.passFXAA = new THREE.ShaderPass(THREE.FXAAShader);\n    //this.passFXAA.uniforms['resolution'].value.set(1/this.width, 1/this.height);\n    this.passPoster = new THREE.PosterPass(this.size);\n    this.passBloom = new THREE.UnrealBloomPass(this.size, strength, radius, threshold);\n    this.passBloom.renderToScreen = true;\n\n    // compose\n    this.composer = new THREE.EffectComposer(this.renderer);\n    this.composer.addPass(this.passRender);\n    //this.composer.addPass(this.passFXAA);\n    this.composer.addPass(this.passPoster);\n    this.composer.addPass(this.passBloom);\n\n    // events, doc\n    window.addEventListener('resize', () => {\n      this.resize();\n    });\n    window.addEventListener('orientationchange', () => {\n      setTimeout(() => {\n        this.resize();\n      }, 125);\n    });\n    this.domElement = document.querySelector('#canvas-target');\n    this.domElement.append(this.renderer.domElement);\n    this.resize();\n    scene.resize();\n  }\n\n  setSize() {\n    const w = Math.min(window.innerWidth, Math.max(this.padding.minX, window.innerWidth - this.padding.x * 2));\n    const h = Math.min(window.innerHeight, Math.max(this.padding.minY, window.innerHeight - this.padding.y * 2));\n    this.width = w;\n    this.height = h;\n    if (!this.size) {\n      this.size = new THREE.Vector2(this.width, this.height);\n    } else {\n      this.size.x = this.width;\n      this.size.y = this.height;\n    }\n  }\n\n  resize() {\n    this.setSize();\n    this.domElement.style.width = `${this.width}px`;\n    this.domElement.style.height = `${this.height}px`;\n    this.renderer.setSize(this.width, this.height);\n    this.composer.setSize(this.width, this.height);\n    this.passBloom.setSize(this.width, this.height);\n    //this.passFXAA.uniforms['resolution'].value.set(1/this.width, 1/this.height);\n  }\n\n  draw(delta) {\n    this.composer.render(delta);\n  }\n}\n\n\n\n//# sourceURL=webpack://CLM/./js/modules/renderer.js?");

/***/ }),

/***/ "./js/modules/scene.js":
/*!*****************************!*\
  !*** ./js/modules/scene.js ***!
  \*****************************/
/*! exports provided: Scene */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Scene\", function() { return Scene; });\n/* harmony import */ var _world__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./world */ \"./js/modules/world/index.js\");\n/**\r\n * 3D scene handler.\r\n **/\n\n\n\nclass Scene {\n  constructor() {\n    this.element = document.querySelector('#canvas-target');\n    this.width = window.innerWidth;\n    this.height = window.innerHeight;\n    this.scene = new THREE.Scene();\n    this.colliderSystem = new Collider.System();\n    this.player = new _world__WEBPACK_IMPORTED_MODULE_0__[\"Player\"](this);\n    this.camera = new _world__WEBPACK_IMPORTED_MODULE_0__[\"Camera\"](this);\n    this.lighting = new _world__WEBPACK_IMPORTED_MODULE_0__[\"Lighting\"](this);\n    this.map = new _world__WEBPACK_IMPORTED_MODULE_0__[\"Map\"](this);\n\n    // events\n    window.addEventListener('resize', () => {\n      this.resize();\n    });\n    window.addEventListener('orientationchange', () => {\n      setTimeout(() => {\n        this.resize();\n      }, 125);\n    });\n  }\n\n  resize() {\n    const rect = this.element.getBoundingClientRect();\n    this.width = rect.width;\n    this.height = rect.height;\n    this.camera.resize();\n  }\n\n  update(delta) {\n    this.player.update(delta);\n    this.camera.update(delta);\n    this.map.update(delta);\n  }\n}\n\n\n\n//# sourceURL=webpack://CLM/./js/modules/scene.js?");

/***/ }),

/***/ "./js/modules/surface.js":
/*!*******************************!*\
  !*** ./js/modules/surface.js ***!
  \*******************************/
/*! exports provided: Surface */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Surface\", function() { return Surface; });\n/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ui */ \"./js/modules/ui/index.js\");\n/* harmony import */ var _maths__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./maths */ \"./js/modules/maths/index.js\");\n/**\r\n * Control surface and player interface.\r\n **/\n\n\n\n\nclass Surface {\n  constructor(scene, renderer, isMobile) {\n    this.scene = scene;\n    this.isMobile = isMobile;\n    this.player = this.scene.player;\n    this.domElement = document.querySelector('#canvas-target');\n    this.centre = { x: 0, y: 0 };\n    this.setSize();\n    this.rotation = new THREE.Vector2();\n    this.timestamp = null;\n    this.threshold = { click: 150, pan: 200 };\n    this.scaleRotation = { x: isMobile ? 0.75 : 1, y: 1 };\n\n    // events\n    document.querySelectorAll('#gallery-controls .controls__inner .control').forEach(e => {\n      if (!isMobile) {\n        e.addEventListener('mousedown', evt => {\n          this.onControlDown(evt.currentTarget);\n        });\n        e.addEventListener('mouseup', evt => {\n          this.onControlUp(evt.currentTarget);\n        });\n        e.addEventListener('mouseleave', evt => {\n          this.onControlLeave(evt.currentTarget);\n        });\n      } else {\n        e.addEventListener('touchstart', evt => {\n          evt.preventDefault();\n          this.onControlDown(evt.currentTarget);\n        });\n        e.addEventListener('touchend', evt => {\n          evt.preventDefault();\n          this.onControlUp(evt.currentTarget);\n        });\n      }\n    });\n    this.controls = {\n      up: document.querySelector('#ctrl-U'),\n      down: document.querySelector('#ctrl-D'),\n      left: document.querySelector('#ctrl-L'),\n      right: document.querySelector('#ctrl-R')\n    };\n    this.keyboard = new _ui__WEBPACK_IMPORTED_MODULE_0__[\"Keyboard\"](key => {\n      this.onKeyboard(key);\n    });\n    if (!this.isMobile) {\n      this.mouse = new _ui__WEBPACK_IMPORTED_MODULE_0__[\"Mouse\"](this.domElement, e => {\n        this.onMouseDown(e);\n      }, e => {\n        this.onMouseMove(e);\n      }, e => {\n        this.onMouseUp(e);\n      }, this.isMobile);\n    } else {\n      this.mouse = new _ui__WEBPACK_IMPORTED_MODULE_0__[\"Mouse\"](this.domElement, e => {\n        this.onMouseDown(this.processTouch(e));\n      }, e => {\n        this.onMouseMove(this.processTouch(e));\n      }, e => {\n        this.onMouseUp(this.processTouch(e));\n      }, this.isMobile);\n    }\n    window.addEventListener('resize', () => {\n      this.resize();\n    });\n    window.addEventListener('orientationchange', () => {\n      setTimeout(() => {\n        this.resize();\n      }, 125);\n    });\n\n    // 2d canvas\n    this.canvas = new _ui__WEBPACK_IMPORTED_MODULE_0__[\"OverlayCanvas\"](this, this.domElement, renderer.renderer.domElement);\n\n    // artwork handler\n    this.floorPlan = new _ui__WEBPACK_IMPORTED_MODULE_0__[\"FloorPlan\"](this);\n  }\n\n  processTouch(e) {\n    // touch event -> mouse analogue\n    var x = 0;\n    var y = 0;\n    if (e.targetTouches.length) {\n      const rect = this.domElement.getBoundingClientRect();\n      const touch = e.targetTouches[0];\n      x = touch.pageX - rect.left;\n      y = touch.pageY - rect.top;\n    }\n    return { offsetX: x, offsetY: y };\n  }\n\n  onMouseDown(e) {\n    // record player rotation\n    this.rotation.y = this.player.rotation.y;\n    this.rotation.x = this.player.rotation.x;\n    this.timestamp = Date.now();\n    this.mouse.start(e);\n\n    // set cursor position mobile\n    if (this.isMobile) {\n      this.onMouseMove(e);\n    }\n  }\n\n  onMouseMove(e) {\n    this.mouse.move(e);\n\n    if (this.mouse.active) {\n      // update player rotation\n      if (!(this.player.keys.left || this.player.keys.right)) {\n        const yaw = this.rotation.x + this.mouse.delta.x / this.centre.x * this.scaleRotation.x;\n        const pitch = Object(_maths__WEBPACK_IMPORTED_MODULE_1__[\"Clamp\"])(this.rotation.y + this.mouse.delta.y / this.centre.y * this.scaleRotation.y, this.player.minPitch, this.player.maxPitch);\n        if (pitch == this.player.minPitch || pitch == this.player.maxPitch) {\n          this.mouse.origin.y = e.offsetY;\n          this.rotation.y = pitch;\n        }\n        this.player.setRotation(pitch, yaw);\n      }\n    } else {\n      // update artwork nodes\n      this.floorPlan.mouseOver(this.mouse.x, this.mouse.y);\n    }\n  }\n\n  onMouseUp(e) {\n    this.mouse.stop();\n    if (Date.now() - this.timestamp < this.threshold.click) {\n      this.floorPlan.click(this.mouse.x, this.mouse.y);\n    }\n  }\n\n  onControlUp(e) {\n    switch (e.dataset.dir) {\n      case 'up':\n        this.player.keys.up = false;\n        break;\n      case 'down':\n        this.player.keys.down = false;\n        break;\n      case 'left':\n        this.player.keys.left = false;\n        break;\n      case 'right':\n        this.player.keys.right = false;\n        break;\n      default:\n        break;\n    }\n    e.classList.remove('active');\n  }\n\n  onControlDown(e) {\n    switch (e.dataset.dir) {\n      case 'up':\n        this.player.keys.up = true;\n        break;\n      case 'down':\n        this.player.keys.down = true;\n        break;\n      case 'left':\n        this.player.keys.left = true;\n        break;\n      case 'right':\n        this.player.keys.right = true;\n        break;\n      default:\n        break;\n    }\n    e.classList.add('active');\n  }\n\n  onControlLeave(e) {\n    this.onControlUp(e);\n  }\n\n  onKeyboard(key) {\n    switch (key) {\n      case 'a':case 'A':case 'ArrowLeft':\n        this.player.keys.left = this.keyboard.keys[key];\n        if (this.player.keys.left) {\n          this.controls.left.classList.add('active');\n        } else {\n          this.controls.left.classList.remove('active');\n        }\n        break;\n      case 'd':case 'D':case 'ArrowRight':\n        this.player.keys.right = this.keyboard.keys[key];\n        if (this.player.keys.right) {\n          this.controls.right.classList.add('active');\n        } else {\n          this.controls.right.classList.remove('active');\n        }\n        break;\n      case 'w':case 'W':case 'ArrowUp':\n        this.player.keys.up = this.keyboard.keys[key];\n        if (this.player.keys.up) {\n          this.controls.up.classList.add('active');\n        } else {\n          this.controls.up.classList.remove('active');\n        }\n        break;\n      case 's':case 'S':case 'ArrowDown':\n        this.player.keys.down = this.keyboard.keys[key];\n        if (this.player.keys.down) {\n          this.controls.down.classList.add('active');\n        } else {\n          this.controls.down.classList.remove('active');\n        }\n        break;\n      case ' ':\n        this.player.keys.jump = this.keyboard.keys[key];\n        break;\n      case 'x':case 'X':\n        // toggle noclip on ctrl+x\n        if (this.keyboard.keys['x'] || this.keyboard.keys['X']) {\n          if (this.keyboard.isControl()) {\n            this.player.toggleNoclip();\n          }\n          this.keyboard.release('x');\n          this.keyboard.release('X');\n        }\n        break;\n      default:\n        break;\n    }\n  }\n\n  setSize() {\n    // get centre of canvas\n    const rect = this.domElement.getBoundingClientRect();\n    this.centre.x = rect.width / 2;\n    this.centre.y = rect.height / 2;\n  }\n\n  resize() {\n    //this.raycaster.resize();\n    this.setSize();\n    this.canvas.resize();\n  }\n\n  update(delta) {\n    // update artwork display\n    this.floorPlan.update(delta);\n    if (this.floorPlan.activeArtwork != null) {\n      this.activeTitle = this.floorPlan.activeArtwork.data.title;\n      this.domElement.classList.add('clickable');\n    } else {\n      this.activeTitle = '';\n      this.domElement.classList.remove('clickable');\n    }\n  }\n\n  draw() {\n    this.canvas.clear();\n    this.floorPlan.draw(this.canvas);\n    this.canvas.promptTouchMove(this.mouse.active && Date.now() - this.timestamp > this.threshold.pan);\n    //this.canvas.promptClick(this.activeTitle, (!this.mouse.active && this.floorPlan.activeArtwork != null), this.mouse.x, this.mouse.y);\n    if (this.player.noclip) {\n      this.canvas.promptGodMode();\n      this.canvas.drawDevOverlay();\n    } else {\n      this.canvas.drawDevOverlay();\n    }\n  }\n}\n\n\n\n//# sourceURL=webpack://CLM/./js/modules/surface.js?");

/***/ }),

/***/ "./js/modules/ui/artwork.js":
/*!**********************************!*\
  !*** ./js/modules/ui/artwork.js ***!
  \**********************************/
/*! exports provided: Artwork */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Artwork\", function() { return Artwork; });\n/* harmony import */ var _interaction_nodes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interaction_nodes */ \"./js/modules/ui/interaction_nodes/index.js\");\n/**\r\n ** Handle individual artwork.\r\n **/\n\n\n\nclass Artwork {\n  constructor(id, e) {\n    this.id = id;\n    this.active = false;\n    this.position = new THREE.Vector3();\n    this.direction = new THREE.Vector3();\n    this.element = e;\n    this.nearRadius = 5;\n    this.thickness = 0.2;\n    this.upstairs = false;\n    this.data = {\n      url: e.dataset.url,\n      title: e.dataset.title || '',\n      subtitle: e.dataset.subtitle || '',\n      desc: e.dataset.desc || '',\n      link: e.dataset.link || '',\n      width: parseFloat(e.dataset.width),\n      offset: {\n        horizontal: parseFloat(e.dataset.hoff),\n        vertical: parseFloat(e.dataset.voff)\n      },\n      index: parseInt(e.dataset.location) - 1 || e.dataset.location\n    };\n  }\n\n  init(scene, p, v) {\n    const planeOffset = this.thickness / 2 + 0.01;\n    this.board = new THREE.Mesh(new THREE.BoxBufferGeometry(1, 1, 1), new THREE.MeshStandardMaterial({ color: 0x0, roughness: 0.75, metalness: 0 }));\n    this.plane = new THREE.Mesh(new THREE.PlaneBufferGeometry(1, 1), new THREE.MeshStandardMaterial({ roughness: 1.0, metalness: 0.5 }));\n\n    // set position, create node\n    this.baseY = p.y;\n    p.x += (v.x != 0 ? 0 : 1) * this.data.offset.horizontal;\n    p.y += this.data.offset.vertical;\n    p.z += (v.z != 0 ? 0 : 1) * this.data.offset.horizontal;\n    this.plane.position.set(p.x + v.x * planeOffset, p.y, p.z + v.z * planeOffset);\n    this.position.set(p.x, p.y, p.z);\n    this.direction.set(v.x, v.y, v.z);\n    this.node = new _interaction_nodes__WEBPACK_IMPORTED_MODULE_0__[\"InteractionNodeView\"](p, null, v, this);\n\n    // get texture from image file\n    const texture = new THREE.TextureLoader().load(this.data.url, tex => {\n      // scale to image dimensions\n      const height = this.data.width * (tex.image.naturalHeight / tex.image.naturalWidth);\n      this.plane.scale.x = this.data.width;\n      this.plane.scale.y = height;\n      this.board.scale.x = v.x != 0 ? this.thickness : this.data.width;\n      this.board.scale.y = height;\n      this.board.scale.z = v.z != 0 ? this.thickness : this.data.width;\n\n      // set\n      this.node.setCorners();\n    });\n\n    // set artwork texture\n    this.plane.material.map = texture;\n\n    // required for NPOT textures\n    texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;\n    texture.minFilter = THREE.LinearFilter;\n\n    if (v.z == 1) {\n      // default\n    } else if (v.z == -1) {\n      this.plane.rotation.y = Math.PI;\n    } else if (v.x == 1) {\n      this.plane.rotation.y = Math.PI * 0.5;\n    } else if (v.x == -1) {\n      this.plane.rotation.y = Math.PI * 1.5;\n    }\n\n    this.board.scale.x = v.x != 0 ? this.thickness : 1;\n    this.board.scale.z = v.z != 0 ? this.thickness : 1;\n    this.board.position.set(p.x, p.y, p.z);\n\n    // add\n    scene.add(this.plane);\n    scene.add(this.board);\n  }\n\n  activate() {\n    if (!this.active) {\n      this.active = true;\n    }\n  }\n\n  deactivate() {\n    if (this.active) {\n      this.active = false;\n    }\n  }\n\n  getDistanceTo(p) {\n    return this.position.distanceTo(p);\n  }\n\n  isFacing(p) {\n    // check if (position->p . direction) >= 0\n    const v = p.clone();\n    v.sub(this.position);\n    return v.dot(this.direction) >= 0;\n  }\n\n  getCameraDot(p, v) {\n    // get dot product p->position . v\n    const d = this.position.clone();\n    d.sub(p);\n    d.normalize();\n    return d.dot(v);\n  }\n\n  update(delta) {}\n}\n\n\n\n//# sourceURL=webpack://CLM/./js/modules/ui/artwork.js?");

/***/ }),

/***/ "./js/modules/ui/floor_plan.js":
/*!*************************************!*\
  !*** ./js/modules/ui/floor_plan.js ***!
  \*************************************/
/*! exports provided: FloorPlan */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FloorPlan\", function() { return FloorPlan; });\n/* harmony import */ var _interaction_nodes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interaction_nodes */ \"./js/modules/ui/interaction_nodes/index.js\");\n/* harmony import */ var _artwork__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./artwork */ \"./js/modules/ui/artwork.js\");\n/**\r\n ** Load, place and manage artworks.\r\n **/\n\n\n\n\nclass FloorPlan {\n  constructor(root) {\n    this.root = root;\n    this.player = this.root.scene.player;\n    this.camera = this.root.scene.camera.camera;\n    this.scene = this.root.scene.scene;\n    this.centre = this.root.centre;\n    this.cameraDirection = new THREE.Vector3();\n    this.artworkActiveRadius = 10;\n    this.artworks = [];\n    this.isDev = window.location.host.indexOf('localhost') != -1;\n\n    // get artworks\n    var count = 0;\n    document.querySelectorAll('#artworks .image').forEach(e => {\n      this.artworks.push(new _artwork__WEBPACK_IMPORTED_MODULE_1__[\"Artwork\"](++count, e));\n    });\n    this.placeArtworks();\n\n    // doc\n    this.domElement = document.querySelector('#artwork-target');\n    this.el = {\n      title: this.domElement.querySelector('.title'),\n      subtitle: this.domElement.querySelector('.subtitle'),\n      desc: this.domElement.querySelector('.desc'),\n      link: this.domElement.querySelector('.link')\n    };\n\n    // make notes\n    this.notes = [];\n    //this.notes.push( new InteractionNodeNote('<- something here?', new THREE.Vector3(0, 14, 6), null) );\n  }\n\n  placeArtworks() {\n    // 32\n    const positions = [\n    // brick wall (8)\n    { x: -24, y: 4, z: 23, nx: 0, nz: -1 }, { x: -10.5, y: 3.5, z: 23, nx: 0, nz: -1 }, { x: -8, y: 3.5, z: 23, nx: 0, nz: -1 }, { x: -5.5, y: 3.5, z: 23, nx: 0, nz: -1 }, { x: 5.5, y: 3.5, z: 23, nx: 0, nz: -1 }, { x: 8, y: 3.5, z: 23, nx: 0, nz: -1 }, { x: 10.5, y: 3.5, z: 23, nx: 0, nz: -1 }, { x: 24, y: 4, z: 23, nx: 0, nz: -1 },\n    // central block A (6)\n    { x: -12, y: 3.5, z: 8, nx: 0, nz: 1 }, { x: -8, y: 3.5, z: 8, nx: 0, nz: 1 }, { x: -4, y: 3.5, z: 8, nx: 0, nz: 1 }, { x: 4, y: 3.5, z: 8, nx: 0, nz: 1 }, { x: 8, y: 3.5, z: 8, nx: 0, nz: 1 }, { x: 12, y: 3.5, z: 8, nx: 0, nz: 1 },\n    // end walls (6)\n    { x: -31, y: 4, z: 14, nx: 1, nz: 0 }, { x: -29.5, y: 4, z: 6, nx: 1, nz: 0 }, { x: -31, y: 4, z: -2, nx: 1, nz: 0 }, { x: 32, y: 4, z: 14, nx: -1, nz: 0 }, { x: 30, y: 4, z: 6, nx: -1, nz: 0 }, { x: 32, y: 4, z: -2, nx: -1, nz: 0 },\n    // central block B (6)\n    { x: -12, y: 3.5, z: 4, nx: 0, nz: -1 }, { x: -8, y: 3.5, z: 4, nx: 0, nz: -1 }, { x: -4, y: 3.5, z: 4, nx: 0, nz: -1 }, { x: 4, y: 3.5, z: 4, nx: 0, nz: -1 }, { x: 8, y: 3.5, z: 4, nx: 0, nz: -1 }, { x: 12, y: 3.5, z: 4, nx: 0, nz: -1 },\n    // white wall downstairs (2)\n    { x: -8, y: 3.5, z: -11.5, nx: 0, nz: 1 }, { x: 8, y: 3.5, z: -11.5, nx: 0, nz: 1 },\n    // upstairs (4)\n    { x: -24, y: 11, z: -11, nx: 0, nz: 1, upstairs: true }, { x: -8, y: 11, z: -11.5, nx: 0, nz: 1, upstairs: true }, { x: 8, y: 11, z: -11.5, nx: 0, nz: 1, upstairs: true }, { x: 24, y: 11, z: -11, nx: 0, nz: 1, upstairs: true }];\n\n    for (var i = 0; i < this.artworks.length; i++) {\n      const artwork = this.artworks[i];\n      var p = null;\n\n      // get position slot\n      if (typeof artwork.data.index == 'number' && artwork.data.index < positions.length && positions[artwork.data.index].active == undefined) {\n        p = positions[artwork.data.index];\n        p.active = true;\n      }\n\n      // auto\n      if (p == null) {\n        for (var j = 0; j < positions.length; j++) {\n          if (!positions[j].active) {\n            p = positions[j];\n            p.active = true;\n            break;\n          }\n        }\n      }\n\n      if (p != null) {\n        const position = new THREE.Vector3(p.x, p.y, p.z);\n        const direction = new THREE.Vector3(p.nx, 0, p.nz);\n        artwork.init(this.scene, position, direction);\n        if (p.upstairs !== undefined) {\n          artwork.upstairs = true;\n        }\n      } else {\n        console.log('Error: Duplicate artwork slot reference.');\n        this.artworks.splice(i, 1);\n        i -= 1;\n      }\n    }\n\n    // placeholders\n    if (this.isDev) {\n      const mat = new THREE.MeshStandardMaterial({ color: 0x0, roughness: 0.75, metalness: 0 });\n      positions.forEach(p => {\n        if (!p.active) {\n          const board = new THREE.Mesh(new THREE.BoxBufferGeometry(0.25, 0.25, 0.25), mat);\n          board.position.set(p.x, p.y, p.z);\n          this.scene.add(board);\n        }\n      });\n    }\n  }\n\n  mouseOver(x, y) {\n    for (var i = 0, len = this.artworks.length; i < len; ++i) {\n      this.artworks[i].node.mouseOver(x, y, this.player.position);\n    }\n  }\n\n  click(x, y) {\n    for (var i = 0, len = this.artworks.length; i < len; ++i) {\n      this.artworks[i].node.mouseOver(x, y, this.player.position);\n      if (this.artworks[i].node.isHover()) {\n        this.player.moveToArtwork(this.artworks[i]);\n        break;\n      }\n    }\n  }\n\n  update(delta) {\n    // get closest artwork, update interaction nodes, get active artwork node\n    this.camera.getWorldDirection(this.cameraDirection);\n    var res = false;\n    var maxDot = -1;\n    this.activeArtwork = null;\n\n    for (var i = 0; i < this.artworks.length; ++i) {\n      const a = this.artworks[i];\n      a.update(delta);\n\n      // check if artwork in range, facing camera, best match\n      if (a.getDistanceTo(this.camera.position) < this.artworkActiveRadius && a.isFacing(this.camera.position)) {\n        const dot = a.getCameraDot(this.camera.position, this.cameraDirection);\n        if (dot > 0.66 && dot > maxDot) {\n          maxDot = dot;\n          res = a;\n        }\n      }\n\n      // update node\n      a.node.update(delta, this.player, this.camera, this.cameraDirection, this.centre);\n      if (a.node.isHover()) {\n        this.activeArtwork = a;\n      }\n    }\n\n    // display\n    if (res) {\n      if (this.domElement.dataset.active === undefined || this.domElement.dataset.active != res.id || !this.domElement.classList.contains('active')) {\n        this.domElement.dataset.active = res.id;\n        this.domElement.classList.add('active');\n        this.el.title.innerHTML = res.data.title;\n        this.el.subtitle.innerHTML = res.data.subtitle;\n        this.el.desc.innerHTML = res.data.desc;\n        this.el.link.innerHTML = res.data.link ? `<a href='${res.data.link}' target='_blank'>Link</a>` : '';\n        this.artworks.forEach(a => {\n          a.deactivate();\n        });\n        res.activate();\n      }\n    } else {\n      this.domElement.classList.remove('active');\n      this.artworks.forEach(a => {\n        a.deactivate();\n      });\n    }\n\n    // update notes\n    for (var i = 0, len = this.notes.length; i < len; ++i) {\n      this.notes[i].update(this.camera, this.cameraDirection, this.centre);\n    }\n  }\n\n  draw(cvs) {\n    // artwork interaction nodes\n    for (var i = 0, len = this.artworks.length; i < len; ++i) {\n      cvs.drawNode(this.artworks[i].node);\n    }\n\n    // notes\n    for (var i = 0, len = this.notes.length; i < len; ++i) {\n      cvs.drawNode(this.notes[i]);\n    }\n  }\n}\n\n\n\n//# sourceURL=webpack://CLM/./js/modules/ui/floor_plan.js?");

/***/ }),

/***/ "./js/modules/ui/index.js":
/*!********************************!*\
  !*** ./js/modules/ui/index.js ***!
  \********************************/
/*! exports provided: Mouse, Keyboard, OverlayCanvas, FloorPlan */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _mouse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mouse */ \"./js/modules/ui/mouse.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Mouse\", function() { return _mouse__WEBPACK_IMPORTED_MODULE_0__[\"Mouse\"]; });\n\n/* harmony import */ var _keyboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keyboard */ \"./js/modules/ui/keyboard.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Keyboard\", function() { return _keyboard__WEBPACK_IMPORTED_MODULE_1__[\"Keyboard\"]; });\n\n/* harmony import */ var _overlay_canvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./overlay_canvas */ \"./js/modules/ui/overlay_canvas.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"OverlayCanvas\", function() { return _overlay_canvas__WEBPACK_IMPORTED_MODULE_2__[\"OverlayCanvas\"]; });\n\n/* harmony import */ var _floor_plan__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./floor_plan */ \"./js/modules/ui/floor_plan.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"FloorPlan\", function() { return _floor_plan__WEBPACK_IMPORTED_MODULE_3__[\"FloorPlan\"]; });\n\n\n\n\n\n\n//# sourceURL=webpack://CLM/./js/modules/ui/index.js?");

/***/ }),

/***/ "./js/modules/ui/interaction_nodes/index.js":
/*!**************************************************!*\
  !*** ./js/modules/ui/interaction_nodes/index.js ***!
  \**************************************************/
/*! exports provided: InteractionNodeView, InteractionNodeNote */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _interaction_node_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interaction_node_view */ \"./js/modules/ui/interaction_nodes/interaction_node_view.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"InteractionNodeView\", function() { return _interaction_node_view__WEBPACK_IMPORTED_MODULE_0__[\"InteractionNodeView\"]; });\n\n/* harmony import */ var _interaction_node_note__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./interaction_node_note */ \"./js/modules/ui/interaction_nodes/interaction_node_note.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"InteractionNodeNote\", function() { return _interaction_node_note__WEBPACK_IMPORTED_MODULE_1__[\"InteractionNodeNote\"]; });\n\n\n\n\n//# sourceURL=webpack://CLM/./js/modules/ui/interaction_nodes/index.js?");

/***/ }),

/***/ "./js/modules/ui/interaction_nodes/interaction_node_base.js":
/*!******************************************************************!*\
  !*** ./js/modules/ui/interaction_nodes/interaction_node_base.js ***!
  \******************************************************************/
/*! exports provided: InteractionNodeBase */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InteractionNodeBase\", function() { return InteractionNodeBase; });\n/**\r\n * Base UI node. Converts world space to screen space.\r\n **/\n\nclass InteractionNodeBase {\n  constructor(position, clipping) {\n    this.onscreen = true;\n    this.position = position;\n    this.clipping = clipping || null;\n    this.coords = new THREE.Vector2();\n    this.helper = new THREE.Vector3();\n  }\n\n  calculateNodePosition(camera, worldVec, centre) {\n    this.helper.copy(camera.position);\n    this.helper.sub(this.position);\n    this.helper.normalize();\n    if (this.helper.dot(worldVec) <= 0) {\n      this.onscreen = true;\n      this.helper.copy(this.position);\n      this.helper.project(camera);\n      this.coords.x = (this.helper.x + 1) * centre.x;\n      this.coords.y = (-this.helper.y + 1) * centre.y;\n    } else {\n      this.onscreen = false;\n    }\n\n    // clip plane\n    if (this.clipping && this.onscreen) {\n      this.helper.copy(camera.position);\n      this.helper.sub(this.position);\n      if (this.helper.dot(this.clipping) < 0) {\n        this.onscreen = false;\n      }\n    }\n  }\n}\n\n\n\n//# sourceURL=webpack://CLM/./js/modules/ui/interaction_nodes/interaction_node_base.js?");

/***/ }),

/***/ "./js/modules/ui/interaction_nodes/interaction_node_note.js":
/*!******************************************************************!*\
  !*** ./js/modules/ui/interaction_nodes/interaction_node_note.js ***!
  \******************************************************************/
/*! exports provided: InteractionNodeNote */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InteractionNodeNote\", function() { return InteractionNodeNote; });\n/* harmony import */ var _interaction_node_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interaction_node_base */ \"./js/modules/ui/interaction_nodes/interaction_node_base.js\");\n\n\nclass InteractionNodeNote extends _interaction_node_base__WEBPACK_IMPORTED_MODULE_0__[\"InteractionNodeBase\"] {\n  constructor(msg, position, clipping) {\n    super(position, clipping || null);\n    this.message = msg;\n  }\n\n  update(camera, worldVec, centre) {\n    this.calculateNodePosition(camera, worldVec, centre);\n  }\n\n  draw(ctx) {\n    if (this.onscreen) {\n      ctx.globalAlpha = 1;\n      ctx.fillText(this.message, this.coords.x, this.coords.y);\n    }\n  }\n}\n\n\n\n//# sourceURL=webpack://CLM/./js/modules/ui/interaction_nodes/interaction_node_note.js?");

/***/ }),

/***/ "./js/modules/ui/interaction_nodes/interaction_node_view.js":
/*!******************************************************************!*\
  !*** ./js/modules/ui/interaction_nodes/interaction_node_view.js ***!
  \******************************************************************/
/*! exports provided: InteractionNodeView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InteractionNodeView\", function() { return InteractionNodeView; });\n/* harmony import */ var _interaction_node_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interaction_node_base */ \"./js/modules/ui/interaction_nodes/interaction_node_base.js\");\n/* harmony import */ var _point_to_screen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./point_to_screen */ \"./js/modules/ui/interaction_nodes/point_to_screen.js\");\n/**\r\n * Signify view location exists.\r\n **/\n\n\n\n\nclass InteractionNodeView extends _interaction_node_base__WEBPACK_IMPORTED_MODULE_0__[\"InteractionNodeBase\"] {\n  constructor(position, rotation, clipping, root) {\n    super(position, clipping || null);\n    this.rotation = rotation;\n    this.active = true;\n    this.hover = false;\n    this.radius = { min: 5, max: 24, fadeThreshold: 3 };\n    this.corners = {\n      world: { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3(), d: new THREE.Vector3() },\n      screen: { a: new THREE.Vector2(), b: new THREE.Vector2(), c: new THREE.Vector2(), d: new THREE.Vector2() }\n    };\n    this.distance = -1;\n    this.maxVerticalDifference = 4;\n    this.opacity = 1;\n\n    // set root (optional)\n    this.root = root || null;\n  }\n\n  isCorrectQuadrant(p) {\n    return p.x <= -16 || p.x >= 16 || p.z >= 6 && this.position.z >= 6 || p.z <= 6 && this.position.z <= 6;\n  }\n\n  mouseOver(x, y, player) {\n    // check if mouse hover\n    if (this.active && this.onscreen) {\n      const minX = Math.min(this.corners.screen.a.x, this.corners.screen.b.x) - 4;\n      const maxX = Math.max(this.corners.screen.a.x, this.corners.screen.b.x) + 4;\n      const minY = this.corners.screen.a.y + 4;\n      const maxY = this.corners.screen.c.y - 4;\n      this.hover = x >= minX && x <= maxX && y >= minY && y <= maxY && this.isCorrectQuadrant(player);\n    } else {\n      this.hover = false;\n    }\n  }\n\n  isHover() {\n    return this.hover && this.active;\n  }\n\n  update(delta, player, camera, worldVec, centre) {\n    this.calculateNodePosition(camera, worldVec, centre);\n\n    // fade out and deactivate\n    this.distance = player.position.distanceTo(this.position);\n    this.height = Math.abs(player.position.y + player.height - (this.root == null ? this.position.y : this.root.baseY));\n\n    if (this.distance < this.radius.min || this.distance > this.radius.max || this.height > this.maxVerticalDifference) {\n      this.active = false;\n    } else {\n      this.active = true;\n\n      // calculate corners\n      if (this.root) {\n        Object(_point_to_screen__WEBPACK_IMPORTED_MODULE_1__[\"pointToScreen\"])(this.corners.world.a, camera, centre, this.corners.screen.a);\n        Object(_point_to_screen__WEBPACK_IMPORTED_MODULE_1__[\"pointToScreen\"])(this.corners.world.b, camera, centre, this.corners.screen.b);\n        Object(_point_to_screen__WEBPACK_IMPORTED_MODULE_1__[\"pointToScreen\"])(this.corners.world.c, camera, centre, this.corners.screen.c);\n        Object(_point_to_screen__WEBPACK_IMPORTED_MODULE_1__[\"pointToScreen\"])(this.corners.world.d, camera, centre, this.corners.screen.d);\n      }\n\n      if (this.distance < this.radius.min + this.radius.fadeThreshold) {\n        this.opacity = (this.distance - this.radius.min) / this.radius.fadeThreshold;\n      } else if (this.distance > this.radius.max - this.radius.fadeThreshold) {\n        this.opacity = (this.radius.max - this.distance) / this.radius.fadeThreshold;\n      } else {\n        this.opacity = 1;\n      }\n    }\n  }\n\n  setCorners() {\n    // set 2D corner positions\n    const p = this.root.position;\n    const v = this.root.direction;\n    const s = this.root.board.scale;\n    const scale = 0.5;\n    const xo = v.x * this.root.thickness / 2;\n    const zo = v.z * this.root.thickness / 2;\n    this.corners.world.a.set(p.x - (v.x != 0 ? 0 : s.x * scale) + xo, p.y + s.y * scale, p.z - (v.z != 0 ? 0 : s.z * scale) + zo);\n    this.corners.world.b.set(p.x + (v.x != 0 ? 0 : s.x * scale) + xo, p.y + s.y * scale, p.z + (v.z != 0 ? 0 : s.z * scale) + zo);\n    this.corners.world.c.set(p.x + (v.x != 0 ? 0 : s.x * scale) + xo, p.y - s.y * scale, p.z + (v.z != 0 ? 0 : s.z * scale) + zo);\n    this.corners.world.d.set(p.x - (v.x != 0 ? 0 : s.x * scale) + xo, p.y - s.y * scale, p.z - (v.z != 0 ? 0 : s.z * scale) + zo);\n  }\n\n  shouldDraw() {\n    // check onscreen, active, and corners not distorting\n    return this.onscreen && this.active && this.hover && Math.max(this.corners.screen.a.x, this.corners.screen.b.x) - Math.min(this.corners.screen.a.x, this.corners.screen.b.x) < window.innerWidth;\n  }\n\n  draw(ctx) {\n    if (this.shouldDraw()) {\n      ctx.globalAlpha = this.opacity;\n      ctx.beginPath();\n      ctx.moveTo(this.corners.screen.a.x, this.corners.screen.a.y);\n      ctx.lineTo(this.corners.screen.b.x, this.corners.screen.b.y);\n      ctx.lineTo(this.corners.screen.c.x, this.corners.screen.c.y);\n      ctx.lineTo(this.corners.screen.d.x, this.corners.screen.d.y);\n      ctx.closePath();\n      ctx.stroke();\n      const x = Math.max(this.corners.screen.c.x, this.corners.screen.d.x);\n      const y = x == this.corners.screen.c.x ? this.corners.screen.c.y : this.corners.screen.d.y;\n      ctx.fillText(this.root.data.title, x + 8, y);\n    }\n  }\n}\n\n\n\n//# sourceURL=webpack://CLM/./js/modules/ui/interaction_nodes/interaction_node_view.js?");

/***/ }),

/***/ "./js/modules/ui/interaction_nodes/point_to_screen.js":
/*!************************************************************!*\
  !*** ./js/modules/ui/interaction_nodes/point_to_screen.js ***!
  \************************************************************/
/*! exports provided: pointToScreen */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pointToScreen\", function() { return pointToScreen; });\n/**\r\n * Convert world space to screen space.\r\n **/\n\nconst pointToScreen = (p, camera, centre, target) => {\n  const point = p.clone();\n  point.project(camera);\n  target.x = (point.x + 1) * centre.x;\n  target.y = (-point.y + 1) * centre.y;\n};\n\n\n\n//# sourceURL=webpack://CLM/./js/modules/ui/interaction_nodes/point_to_screen.js?");

/***/ }),

/***/ "./js/modules/ui/keyboard.js":
/*!***********************************!*\
  !*** ./js/modules/ui/keyboard.js ***!
  \***********************************/
/*! exports provided: Keyboard */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Keyboard\", function() { return Keyboard; });\n/**\r\n * Keyboard interface.\r\n **/\n\nclass Keyboard {\n  constructor(onEvent) {\n    this.keys = {};\n    this.onEvent = onEvent;\n    document.addEventListener('keydown', key => {\n      this.onKeyDown(key);\n    });\n    document.addEventListener('keyup', key => {\n      this.onKeyUp(key);\n    });\n  }\n\n  onKeyDown(key) {\n    this.keys[key.key] = true;\n    this.onEvent(key.key);\n  }\n\n  onKeyUp(key) {\n    this.keys[key.key] = false;\n    this.onEvent(key.key);\n  }\n\n  release(key) {\n    this.keys[key] = false;\n  }\n\n  isSpecial() {\n    return this.keys['Shift'] || this.keys['Control'] || this.keys['Alt'];\n  }\n\n  isControl() {\n    return this.keys['Control'];\n  }\n\n  isShift() {\n    return this.keys['Shift'];\n  }\n\n  isAlt() {\n    return this.keys['Alt'];\n  }\n}\n\n\n\n//# sourceURL=webpack://CLM/./js/modules/ui/keyboard.js?");

/***/ }),

/***/ "./js/modules/ui/mouse.js":
/*!********************************!*\
  !*** ./js/modules/ui/mouse.js ***!
  \********************************/
/*! exports provided: Mouse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Mouse\", function() { return Mouse; });\n/**\r\n * Mouse interface.\r\n **/\n\nclass Mouse {\n  constructor(domElement, onDown, onMove, onUp, isMobile) {\n    this.x = 0;\n    this.y = 0;\n    this.origin = { x: 0, y: 0 };\n    this.delta = { x: 0, y: 0 };\n    this.active = false;\n\n    // dom events\n    this.domElement = domElement;\n\n    if (!isMobile) {\n      this.domElement.addEventListener('mousedown', onDown, false);\n      this.domElement.addEventListener('mousemove', onMove, false);\n      this.domElement.addEventListener('mouseup', onUp, false);\n      this.domElement.addEventListener('mouseleave', onUp, false);\n    } else {\n      this.domElement.addEventListener('touchstart', onDown, false);\n      this.domElement.addEventListener('touchmove', onMove, false);\n      this.domElement.addEventListener('touchend', onUp, false);\n\n      // capture click\n      //this.domElement.addEventListener('click', e => {onDown(e); onUp(e);}, false);\n    }\n  }\n\n  start(e) {\n    this.active = true;\n    this.origin.x = e.offsetX;\n    this.origin.y = e.offsetY;\n  }\n\n  move(e) {\n    this.x = e.offsetX;\n    this.y = e.offsetY;\n    this.delta.x = this.x - this.origin.x;\n    this.delta.y = this.y - this.origin.y;\n  }\n\n  stop() {\n    this.active = false;\n  }\n}\n\n\n\n//# sourceURL=webpack://CLM/./js/modules/ui/mouse.js?");

/***/ }),

/***/ "./js/modules/ui/overlay_canvas.js":
/*!*****************************************!*\
  !*** ./js/modules/ui/overlay_canvas.js ***!
  \*****************************************/
/*! exports provided: OverlayCanvas */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OverlayCanvas\", function() { return OverlayCanvas; });\n/**\r\n * Render HUD/ 2d overlay.\r\n **/\n\nclass OverlayCanvas {\n  constructor(root, domElement, canvasTarget) {\n    this.root = root;\n    this.cvs = document.createElement('canvas');\n    this.ctx = this.cvs.getContext('2d');\n    this.domElement = domElement;\n    this.canvasTarget = canvasTarget;\n    this.resize();\n    this.domElement.append(this.cvs);\n\n    // draw settings\n    this.prompt = {};\n    this.prompt.touchMove = { alpha: { current: 0, min: 0, max: 1 }, size: { current: 12, min: 12, max: 24 } };\n    this.prompt.click = { alpha: { current: 0, min: 0, max: 1 } };\n  }\n\n  clear() {\n    this.ctx.clearRect(0, 0, this.cvs.width, this.cvs.height);\n    this.ctx.font = '14px Karla';\n    this.ctx.strokeStyle = '#fff';\n    this.ctx.fillStyle = '#fff';\n    this.ctx.lineWidth = 1.5;\n    this.ctx.lineCap = 'round';\n  }\n\n  resize() {\n    //const rect = this.domElement.getBoundingClientRect();\n    this.cvs.width = this.canvasTarget.width;\n    this.cvs.height = this.canvasTarget.height;\n  }\n\n  promptClick(text, active, x, y) {\n    // animate click prompt\n    if (active) {\n      this.prompt.click.alpha.current += (this.prompt.click.alpha.max - this.prompt.click.alpha.current) * 0.2;\n    } else {\n      this.prompt.click.alpha.current += (this.prompt.click.alpha.min - this.prompt.click.alpha.current) * 0.2;\n    }\n\n    // draw\n    if (this.prompt.click.alpha.current > 0) {\n      this.ctx.globalAlpha = this.prompt.click.alpha.current;\n      this.ctx.fillText(text, x + 12, y + 12);\n    }\n  }\n\n  promptTouchMove(active) {\n    // animate in/out prompt\n    if (active) {\n      this.prompt.touchMove.alpha.current += (this.prompt.touchMove.alpha.max - this.prompt.touchMove.alpha.current) * 0.2;\n      this.prompt.touchMove.size.current += (this.prompt.touchMove.size.max - this.prompt.touchMove.size.current) * 0.2;\n    } else {\n      this.prompt.touchMove.alpha.current += (this.prompt.touchMove.alpha.min - this.prompt.touchMove.alpha.current) * 0.2;\n      this.prompt.touchMove.size.current += (this.prompt.touchMove.size.min - this.prompt.touchMove.size.current) * 0.2;\n    }\n\n    // draw\n    if (this.prompt.touchMove.alpha.current > 0) {\n      const s1 = this.prompt.touchMove.size.current;\n      const s2 = s1 * 2;\n      const cx = this.cvs.width / 2;\n      const cy = this.cvs.height / 2;\n      this.ctx.globalAlpha = this.prompt.touchMove.alpha.current;\n      this.ctx.beginPath();\n      this.ctx.arc(cx, cy, s1, 0, Math.PI * 2, false);\n      this.ctx.moveTo(cx - s1, cy);\n      this.ctx.lineTo(cx + s1, cy);\n      this.ctx.moveTo(cx, cy - 4);\n      this.ctx.lineTo(cx, cy + 4);\n      this.ctx.stroke();\n    }\n  }\n\n  promptGodMode() {\n    this.ctx.globalAlpha = 1;\n    this.ctx.fillText('fly mode', 20, this.cvs.height - 40);\n    const x = Math.round(this.root.player.position.x * 10) / 10;\n    const y = Math.round(this.root.player.position.y * 10) / 10;\n    const z = Math.round(this.root.player.position.z * 10) / 10;\n    const rx = Math.round(this.root.player.rotation.x * 100) / 100;\n    this.ctx.fillText(`${x}, ${y}, ${z}, ${rx}`, 20, this.cvs.height - 20);\n  }\n\n  drawDevOverlay() {\n    //\n  }\n\n  drawNode(node) {\n    node.draw(this.ctx);\n  }\n}\n\n\n\n//# sourceURL=webpack://CLM/./js/modules/ui/overlay_canvas.js?");

/***/ }),

/***/ "./js/modules/world/camera.js":
/*!************************************!*\
  !*** ./js/modules/world/camera.js ***!
  \************************************/
/*! exports provided: Camera */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Camera\", function() { return Camera; });\n/**\r\n * Perspective camera tracking player.\r\n **/\n\nclass Camera {\n  constructor(root) {\n    this.root = root;\n    this.position = root.player.position;\n    this.rotation = root.player.rotation;\n    this.height = root.player.height;\n    this.target = new THREE.Vector3();\n    this.fov = 65;\n    this.aspectRatio = this.root.width / this.root.height;\n    this.offset = 1;\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspectRatio, 0.1, 2000000);\n    this.camera.up = new THREE.Vector3(0, 1, 0);\n  }\n\n  resize(w, h) {\n    this.aspectRatio = this.root.width / this.root.height;\n    this.camera.aspect = this.aspectRatio;\n    this.camera.updateProjectionMatrix();\n  }\n\n  update(delta) {\n    const offsetXZ = this.offset - this.offset * Math.abs(Math.sin(this.rotation.y));\n    const offsetY = this.offset;\n    const y = this.position.y + this.height;\n    //this.camera.up.z = 0; //this.camera.up.x = 0;\n    this.camera.position.x = this.position.x - Math.sin(this.rotation.x) * offsetXZ / 4;\n    this.camera.position.y = y - Math.sin(this.rotation.y) * offsetY / 4;\n    this.camera.position.z = this.position.z - Math.cos(this.rotation.x) * offsetXZ / 4;\n    this.target.x = this.position.x + Math.sin(this.rotation.x) * offsetXZ;\n    this.target.y = y + Math.sin(this.rotation.y) * offsetY;\n    this.target.z = this.position.z + Math.cos(this.rotation.x) * offsetXZ;\n    this.camera.lookAt(this.target);\n  }\n}\n\n\n\n//# sourceURL=webpack://CLM/./js/modules/world/camera.js?");

/***/ }),

/***/ "./js/modules/world/index.js":
/*!***********************************!*\
  !*** ./js/modules/world/index.js ***!
  \***********************************/
/*! exports provided: Camera, Lighting, Map, Player */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./camera */ \"./js/modules/world/camera.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Camera\", function() { return _camera__WEBPACK_IMPORTED_MODULE_0__[\"Camera\"]; });\n\n/* harmony import */ var _lighting__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lighting */ \"./js/modules/world/lighting.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Lighting\", function() { return _lighting__WEBPACK_IMPORTED_MODULE_1__[\"Lighting\"]; });\n\n/* harmony import */ var _map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./map */ \"./js/modules/world/map.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Map\", function() { return _map__WEBPACK_IMPORTED_MODULE_2__[\"Map\"]; });\n\n/* harmony import */ var _player__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./player */ \"./js/modules/world/player.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Player\", function() { return _player__WEBPACK_IMPORTED_MODULE_3__[\"Player\"]; });\n\n\n\n\n\n\n//# sourceURL=webpack://CLM/./js/modules/world/index.js?");

/***/ }),

/***/ "./js/modules/world/lighting.js":
/*!**************************************!*\
  !*** ./js/modules/world/lighting.js ***!
  \**************************************/
/*! exports provided: Lighting */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Lighting\", function() { return Lighting; });\n/* harmony import */ var _lib_glsl_SkyShader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/glsl/SkyShader.js */ \"./js/lib/glsl/SkyShader.js\");\n/* harmony import */ var _lib_glsl_SkyShader_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib_glsl_SkyShader_js__WEBPACK_IMPORTED_MODULE_0__);\n/**\r\n * Load lighting.\r\n **/\n\n\n\nclass Lighting {\n  constructor(root) {\n    this.scene = root.scene;\n\n    // skybox\n    this.sky = new THREE.Sky();\n    this.sky.scale.setScalar(450000);\n    const d = 400000;\n    const azimuth = 0.25;\n    const inclination = 0.4875;\n    const theta = Math.PI * (inclination - 0.5);\n    const phi = Math.PI * 2 * (azimuth - 0.5);\n    const sunPos = new THREE.Vector3(d * Math.cos(phi), d * Math.sin(phi) * Math.sin(theta), d * Math.sin(phi) * Math.cos(theta));\n    this.sky.material.uniforms.sunPosition.value.copy(sunPos);\n    this.scene.add(this.sky);\n\n    // lighting\n    this.lights = { point: {}, ambient: {}, directional: {}, hemisphere: {} };\n    this.lights.point.a = new THREE.PointLight(0xffffff, 1, 24, 2);\n    this.lights.point.b = new THREE.PointLight(0xffffff, 1, 32, 2);\n    this.lights.point.c = new THREE.PointLight(0xffffff, 1, 20, 2);\n    this.lights.ambient.a = new THREE.AmbientLight(0xffffff, 0.3);\n    this.lights.directional.a = new THREE.DirectionalLight(0xffffff, 0.5);\n    this.lights.hemisphere.a = new THREE.HemisphereLight(0x0, 0x0000ff, 0.25);\n\n    // light placement\n    this.lights.point.a.position.set(-8, 10, 14);\n    this.lights.point.b.position.set(0, 10, -4);\n    this.lights.point.c.position.set(26, 10, 6);\n    this.lights.directional.a.position.set(-1, 1.5, -1);\n\n    // add to scene\n    Object.keys(this.lights).forEach(type => {\n      Object.keys(this.lights[type]).forEach(light => {\n        this.scene.add(this.lights[type][light]);\n      });\n    });\n  }\n}\n\n\n\n//# sourceURL=webpack://CLM/./js/modules/world/lighting.js?");

/***/ }),

/***/ "./js/modules/world/map.js":
/*!*********************************!*\
  !*** ./js/modules/world/map.js ***!
  \*********************************/
/*! exports provided: Map */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Map\", function() { return Map; });\n/* harmony import */ var _materials__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./materials */ \"./js/modules/world/materials.js\");\n/* harmony import */ var _loaders__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../loaders */ \"./js/modules/loaders/index.js\");\n/**\r\n * Load models.\r\n **/\n\n\n\n\nclass Map {\n  constructor(root) {\n    this.root = root;\n    this.scene = root.scene;\n    this.colliderSystem = root.colliderSystem;\n    this.materials = new _materials__WEBPACK_IMPORTED_MODULE_0__[\"Materials\"]('assets');\n    this.loader = new _loaders__WEBPACK_IMPORTED_MODULE_1__[\"Loader\"]('assets');\n    this.loadScene();\n  }\n\n  loadScene() {\n    // invisible floor\n    this.floor = new THREE.Mesh(new THREE.BoxBufferGeometry(100, 1, 100), new THREE.MeshPhongMaterial({}));\n    this.floor.position.y = -0.25;\n    this.colliderSystem.add(this.floor);\n\n    // onloads\n    this.toLoad = 2;\n    this.checkLoaded = () => {\n      this.toLoad -= 1;\n      if (this.toLoad == 0) {\n        const target = document.querySelector('#open-gallery');\n        target.classList.remove('is-loading');\n        target.classList.add('flash');\n        target.innerHTML = 'Open Gallery';\n      }\n    };\n\n    // visual map\n    this.loader.loadFBX('map').then(map => {\n      this.scene.add(map);\n      this.conformGroups(map);\n      this.checkLoaded();\n    }, err => {\n      console.log(err);\n    });\n\n    // collision map\n    this.loader.loadOBJ('collision').then(map => {\n      this.addCollisionMap(map);\n      this.checkLoaded();\n    }, err => {\n      console.log(err);\n    });\n\n    // peripherals (doesn't affect loading)\n    this.loader.loadFBX('props').then(map => {\n      this.scene.add(map);\n      this.conformGroups(map);\n    });\n\n    // revolving display\n    this.makeBox();\n  }\n\n  addCollisionMap(obj) {\n    // recursively add object group to collider\n    if (obj.type === 'Mesh') {\n      this.colliderSystem.add(obj);\n    } else if (obj.children && obj.children.length) {\n      obj.children.forEach(child => {\n        this.addCollisionMap(child);\n      });\n    }\n  }\n\n  conformGroups(obj) {\n    // recursively conform object groups\n    if (obj.type === 'Mesh') {\n      this.materials.conform(obj.material);\n    } else if (obj.children && obj.children.length) {\n      obj.children.forEach(child => {\n        this.conformGroups(child);\n      });\n    }\n  }\n\n  makeBox() {\n    /*\r\n    this.box = new THREE.Group();\r\n    const w = 2.0;\r\n    const r = 0.1;\r\n    const o = w/2 - r/2;\r\n    const arr = [\r\n      [w, r, r, 0, o, o], [w, r, r, 0, o, -o], [w, r, r, 0, -o, o], [w, r, r, 0, -o, -o],\r\n      [r, w, r, o, 0, o], [r, w, r, o, 0, -o], [r, w, r, -o, 0, o], [r, w, r, -o, 0, -o],\r\n      [r, r, w, o, o, 0], [r, r, w, -o, o, 0], [r, r, w, -o, -o, 0], [r, r, w, o, -o, 0]\r\n    ];\r\n    arr.forEach(e => {\r\n      const mesh = new THREE.Mesh(new THREE.BoxBufferGeometry(e[0], e[1], e[2]), this.materials.mat.neon);\r\n      mesh.position.set(e[3], e[4], e[5]);\r\n      this.box.add(mesh);\r\n    });\r\n    this.box.position.set(0, 17, 19.5);\r\n    this.scene.add(this.box);\r\n    */\n\n    // neon lights\n    const size = 0.1;\n    const rodSize = 4;\n    for (var x = -16; x <= 16; x += 8) {\n      const y = 19;\n      const mesh = new THREE.Mesh(new THREE.BoxBufferGeometry(size, size, rodSize), this.materials.mat.neon);\n      const holster = new THREE.Mesh(new THREE.BoxBufferGeometry(size, size * 4, rodSize), this.materials.mat.dark);\n      const rod1 = new THREE.Mesh(new THREE.BoxBufferGeometry(size, 1, size), this.materials.mat.dark);\n      const rod2 = rod1.clone();\n      mesh.position.set(x, y, 6);\n      holster.position.set(x, y + size * 2.5, 6);\n      rod1.position.set(x, y + size * 4.5 + 0.5, 6 + rodSize / 3);\n      rod2.position.set(x, y + size * 4.5 + 0.5, 6 - rodSize / 3);\n      rod1.rotation.y = Math.PI / 4;\n      rod2.rotation.y = Math.PI / 4;\n      this.scene.add(mesh, holster, rod1, rod2);\n    }\n  }\n\n  update(delta) {\n    this.materials.update(delta);\n    //this.box.rotation.y += delta * Math.PI / 12;\n  }\n}\n\n\n\n//# sourceURL=webpack://CLM/./js/modules/world/map.js?");

/***/ }),

/***/ "./js/modules/world/materials.js":
/*!***************************************!*\
  !*** ./js/modules/world/materials.js ***!
  \***************************************/
/*! exports provided: Materials */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Materials\", function() { return Materials; });\n/**\r\n * Material manager.\r\n **/\n\nclass Materials {\n  constructor(path) {\n    this.path = `${APP_ROOT}/${path}/`;\n    this.mat = {};\n    this.mat.default = new THREE.MeshPhysicalMaterial({ emissive: 0, roughness: 1, envMapIntensity: 0.25 });\n    this.mat.porcelain = new THREE.MeshPhysicalMaterial({ color: 0xffffff, emissive: 0x888888, emissiveIntensity: 0.6, roughness: 0.55, metalness: 0.125, envMapIntensity: 0.5 });\n    this.mat.metal = new THREE.MeshPhysicalMaterial({ color: 0xa88e79, emissive: 0x0, roughness: 0.25, metalness: 1.0, envMapIntensity: 0.5 });\n    this.mat.neon = new THREE.MeshPhysicalMaterial({ emissive: 0xffffff, emissiveIntensity: 1.0 });\n    this.mat.dark = new THREE.MeshPhysicalMaterial({ color: 0x0, roughness: 0.5, metalness: 0 });\n    const envMapSources = ['posx', 'negx', 'posy', 'negy', 'posz', 'negz'].map(filename => `${this.path}envmap/${filename}.jpg`);\n    this.envMap = new THREE.CubeTextureLoader().load(envMapSources);\n    this.normalMap = new THREE.TextureLoader().load(this.path + 'textures/noise.jpg');\n    this.normalMap.wrapS = this.normalMap.wrapT = THREE.RepeatWrapping;\n    this.normalMap.repeat.set(32, 32);\n\n    // set envmaps\n    Object.keys(this.mat).forEach(key => {\n      if (this.mat[key].type && this.mat[key].type === 'MeshPhysicalMaterial') {\n        this.mat[key].envMap = this.envMap;\n      }\n    });\n\n    // custom shader uniforms\n    this.uniforms = { time: { value: 0 } };\n\n    // reference file-loaded materials\n    this.loaded = {};\n  }\n\n  conform(mat) {\n    if (!this.loaded[mat.name]) {\n      this.loaded[mat.name] = mat;\n    }\n\n    // mat specific\n    mat.envMap = this.envMap;\n    mat.envMapIntensity = 0.5;\n\n    switch (mat.name) {\n      case 'concrete':\n        mat.normalScale.x = 0.25;\n        mat.normalScale.y = 0.25;\n        break;\n      case 'gold':\n        break;\n      case 'neon':case 'neon1':\n        mat.emissive = new THREE.Color(1, 1, 1);\n        mat.emissiveIntensity = 1.0;\n        //mat.fog = false;\n        break;\n      case 'nu_metal':\n        mat.normalScale.x = 0.25;\n        mat.normalScale.y = 0.25;\n        break;\n      case 'plastic':\n        //mat.emissive = new THREE.Color(1, .95, .95);\n        //mat.emissiveIntensity = .75;\n        break;\n      default:\n        break;\n    }\n  }\n\n  getCustomMaterial(type) {\n    //if (type == 'warp') {\n    const mat = this.mat.metal.clone();\n    mat.onBeforeCompile = shader => {\n      shader.vertexShader = `uniform float time;\\n${shader.vertexShader}`;\n      const beginVertex = `\n        vec4 mvp = modelMatrix * vec4(position, 1.0);\n        float theta = sin(time * 0.1 + mvp.x / 2.0);\n        float c = cos(theta);\n        float s = sin(theta);\n        float off = 1.0;// + 0.2 * sin(time + position.x * 200.0);\n        mat3 roty = mat3(c, 0, s, 0, 1, 0, -s, 0, c);\n        //mat3 sy = mat3(s, 0, 0, 0, 1, 0, 0, 0, 1);\n        mat4 m = mat4(1, 0, 0, 0, 0, 1, 0, s * off * 2.0, 0, 0, 1, s * off, 0, 0, 0, 1);\n        vec4 t = vec4(position, 1.0) * m;\n        vec3 transformed = vec3(t.x, t.y, t.z);\n        vNormal = vNormal * roty;\n      `;\n      shader.vertexShader = shader.vertexShader.replace('#include <begin_vertex>', beginVertex);\n\n      // hook uniforms\n      shader.uniforms.time = this.uniforms.time;\n    };\n    mat.roughness = 0.5;\n    return mat;\n    //const index = shader.vertexShader.indexOf('#include <common>')''\n    //shader.vertexShader = shader.vertexShader.slice(0, index) + '//funcs here' + shader.vertexShader.slice(index);\n  }\n\n  update(delta) {\n    this.uniforms.time.value += delta;\n  }\n}\n\n\n\n//# sourceURL=webpack://CLM/./js/modules/world/materials.js?");

/***/ }),

/***/ "./js/modules/world/player.js":
/*!************************************!*\
  !*** ./js/modules/world/player.js ***!
  \************************************/
/*! exports provided: Player */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Player\", function() { return Player; });\n/* harmony import */ var _maths__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../maths */ \"./js/modules/maths/index.js\");\n/**\r\n * Handles user input and moves player on collision map.\r\n **/\n\n\n\nclass Player {\n  constructor(root) {\n    this.root = root;\n    this.position = new THREE.Vector3(-24, 1, 16);\n    this.rotation = new THREE.Vector2(Math.PI * 0.55, Math.PI * -0.05);\n    this.motion = new THREE.Vector3();\n    this.target = {\n      position: this.position.clone(),\n      rotation: this.rotation.clone(),\n      motion: this.motion.clone()\n    };\n    this.collider = new Collider.Collider(this.target.position, this.motion);\n    this.collider.setPhysics({ gravity: 20 });\n\n    // automatic motion and panning\n    this.automove = {\n      active: { position: true, rotation: true },\n      speed: { current: 0, max: 5 },\n      position: this.position.clone(),\n      rotation: new THREE.Vector2(Math.PI * 0.55, Math.PI * 0.03),\n      threshold: {\n        position: { outer: 2, inner: 0.02 },\n        rotation: Math.PI / 1000 // ~0.006\n      }\n    };\n\n    // physical attributes\n    this.speed = 6; //5\n    this.rotationSpeed = Math.PI * 0.5; //0.5\n    this.jump = 8;\n    this.jumpSpeedMultiplier = 0.25;\n    this.height = 3;\n    this.falling = false;\n    this.fallTime = 0;\n    this.fallTimeThreshold = 0.2;\n    this.noclip = false;\n    this.noclipSpeed = 36;\n    this.toggleNoclip = () => {\n      this.noclip = this.noclip == false;\n    };\n    this.minPitch = Math.PI * -0.125;\n    this.maxPitch = Math.PI * 0.125;\n    this.adjust = { slow: 0.05, normal: 0.1, fast: 0.125, maximum: 0.3 };\n\n    // input\n    this.keys = { disabled: true };\n\n    // add to scene\n    this.group = new THREE.Group();\n    this.light = new THREE.PointLight(0xffffff, 1.0, 12, 2);\n    this.light.position.y = this.height + 0.25;\n    this.group.add(this.light);\n    this.root.scene.add(this.group);\n  }\n\n  move(delta) {\n    // key input to motion\n    if (this.keys.left || this.keys.right) {\n      if (this.automove.active.rotation) {\n        this.target.rotation.copy(this.rotation);\n        this.automove.active.rotation = false;\n      }\n      const d = (this.keys.left ? 1 : 0) + (this.keys.right ? -1 : 0);\n      this.target.rotation.x += d * this.rotationSpeed * delta;\n    }\n\n    if (this.keys.up || this.keys.down) {\n      if (this.automove.active.position) {\n        this.automove.active.position = false;\n        this.target.position.copy(this.position);\n      }\n      const speed = this.noclip ? this.noclipSpeed * (1 - Math.abs(Math.sin(this.target.rotation.y))) : this.speed;\n      const dir = (this.keys.up ? 1 : 0) + (this.keys.down ? -1 : 0);\n      this.target.motion.x = Math.sin(this.rotation.x) * speed * dir;\n      this.target.motion.z = Math.cos(this.rotation.x) * speed * dir;\n    } else {\n      this.target.motion.x = 0;\n      this.target.motion.z = 0;\n    }\n\n    if (this.keys.jump) {\n      if (this.motion.y == 0 || this.fallTime < this.fallTimeThreshold) {\n        this.motion.y = this.jump;\n        this.fallTime = this.fallTimeThreshold;\n      }\n    }\n\n    // decide if falling\n    this.falling = this.motion.y != 0;\n    this.fallTime = this.falling ? this.fallTime + delta : 0;\n\n    // noclip\n    if (this.noclip) {\n      this.falling = false;\n      if (this.keys.up || this.keys.down) {\n        const d = (this.keys.up ? 1 : 0) + (this.keys.down ? -1 : 0);\n        this.target.motion.y = Math.sin(this.target.rotation.y) * d * this.noclipSpeed;\n      } else {\n        this.target.motion.y = 0;\n      }\n      this.motion.y = this.target.motion.y;\n    }\n\n    // reduce speed if falling\n    if (!this.falling) {\n      this.motion.x = this.target.motion.x;\n      this.motion.z = this.target.motion.z;\n    } else {\n      this.motion.x = Object(_maths__WEBPACK_IMPORTED_MODULE_0__[\"Blend\"])(this.motion.x, this.target.motion.x, this.jumpSpeedMultiplier);\n      this.motion.z = Object(_maths__WEBPACK_IMPORTED_MODULE_0__[\"Blend\"])(this.motion.z, this.target.motion.z, this.jumpSpeedMultiplier);\n    }\n  }\n\n  moveToArtwork(artwork) {\n    const p = artwork.position.clone();\n    const v = artwork.direction.clone();\n    v.normalize();\n    v.multiplyScalar(3);\n    p.add(v);\n    this.automove.position.set(p.x, p.y, p.z);\n    this.automove.active.position = true;\n  }\n\n  applyAutomove(delta) {\n    // position\n    if (this.automove.active.position) {\n      const p = this.automove.position.clone();\n      p.sub(this.position);\n      p.y = 0; // use x, z only\n      const mag = p.length();\n      p.normalize();\n\n      // increase speed, reduce speed, or stop\n      if (mag > this.automove.threshold.position.outer) {\n        this.automove.speed.current += (this.automove.speed.max - this.automove.speed.current) * 0.1;\n        p.multiplyScalar(this.automove.speed.current * delta);\n        this.position.add(p);\n      } else {\n        if (mag > this.automove.threshold.position.inner) {\n          const speed = this.automove.speed.max * (mag / this.automove.threshold.position.outer);\n          this.automove.speed.current += (speed - this.automove.speed.current) * 0.1;\n          p.multiplyScalar(this.automove.speed.current * delta);\n          this.position.add(p);\n        } else {\n          // reset y and jump to final position\n          this.automove.position.y = this.target.position.y;\n          this.target.position.copy(this.automove.position);\n          this.automove.active.position = false;\n          this.keys.disabled = false;\n        }\n      }\n    } else {\n      this.automove.speed.current = 0;\n    }\n\n    // rotation\n    if (this.automove.active.rotation) {\n      const rx = Object(_maths__WEBPACK_IMPORTED_MODULE_0__[\"MinAngleBetween\"])(this.rotation.x, this.automove.rotation.x);\n      const ry = Object(_maths__WEBPACK_IMPORTED_MODULE_0__[\"MinAngleBetween\"])(this.rotation.y, this.automove.rotation.y);\n      const mag = Math.hypot(rx, ry);\n      this.rotation.x += rx * 0.025;\n      this.rotation.y += ry * 0.025;\n\n      if (mag < this.automove.threshold.rotation) {\n        this.automove.active.rotation = false;\n        this.target.rotation.copy(this.automove.rotation);\n      }\n    }\n  }\n\n  update(delta) {\n    this.applyAutomove(delta);\n\n    // move\n    if (!this.keys.disabled && !this.automove.active.position) {\n      this.move(delta);\n      if (!this.noclip) {\n        this.collider.move(delta, this.root.colliderSystem);\n      } else {\n        this.target.position.x += this.motion.x * delta;\n        this.target.position.y += this.motion.y * delta;\n        this.target.position.z += this.motion.z * delta;\n      }\n      this.position.x = Object(_maths__WEBPACK_IMPORTED_MODULE_0__[\"Blend\"])(this.position.x, this.target.position.x, this.adjust.maximum);\n      this.position.y = Object(_maths__WEBPACK_IMPORTED_MODULE_0__[\"Blend\"])(this.position.y, this.target.position.y, this.adjust.maximum);\n      this.position.z = Object(_maths__WEBPACK_IMPORTED_MODULE_0__[\"Blend\"])(this.position.z, this.target.position.z, this.adjust.maximum);\n    }\n\n    // rotate\n    if (!this.automove.active.rotation) {\n      this.rotation.x += Object(_maths__WEBPACK_IMPORTED_MODULE_0__[\"MinAngleBetween\"])(this.rotation.x, this.target.rotation.x) * this.adjust.normal;\n      this.rotation.y = Object(_maths__WEBPACK_IMPORTED_MODULE_0__[\"Blend\"])(this.rotation.y, this.target.rotation.y, this.adjust.normal);\n    }\n\n    this.group.position.set(this.position.x, this.position.y, this.position.z);\n  }\n\n  setRotation(pitch, yaw) {\n    this.target.rotation.y = pitch;\n    this.target.rotation.x = yaw;\n    this.automove.active.rotation = false;\n  }\n\n  getTargetPosition() {\n    return this.target.position;\n  }\n};\n\n\n\n//# sourceURL=webpack://CLM/./js/modules/world/player.js?");

/***/ }),

/***/ "./js/utils/index.js":
/*!***************************!*\
  !*** ./js/utils/index.js ***!
  \***************************/
/*! exports provided: detectMobile, detectMobileAndTablet, Menu */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _mobile_check__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mobile_check */ \"./js/utils/mobile_check.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"detectMobile\", function() { return _mobile_check__WEBPACK_IMPORTED_MODULE_0__[\"detectMobile\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"detectMobileAndTablet\", function() { return _mobile_check__WEBPACK_IMPORTED_MODULE_0__[\"detectMobileAndTablet\"]; });\n\n/* harmony import */ var _menu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./menu */ \"./js/utils/menu.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Menu\", function() { return _menu__WEBPACK_IMPORTED_MODULE_1__[\"Menu\"]; });\n\n\n\n\n//# sourceURL=webpack://CLM/./js/utils/index.js?");

/***/ }),

/***/ "./js/utils/menu.js":
/*!**************************!*\
  !*** ./js/utils/menu.js ***!
  \**************************/
/*! exports provided: Menu */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Menu\", function() { return Menu; });\n/**\r\n * Hook up menus.\r\n **/\n\nclass Menu {\n  constructor(root) {\n    this.isDev = window.location.host.indexOf('localhost') != -1;\n    this.root = root;\n    this.openGalleryButton = document.querySelector('#open-gallery');\n    this.openGalleryButton.onclick = () => {\n      if (!this.openGalleryButton.classList.contains('is-loading')) {\n        this.openGalleryButton.classList.remove('flash');\n        this.toggleGallery();\n      }\n    };\n    document.querySelectorAll('.close-gallery').forEach(e => {\n      e.addEventListener('click', () => {\n        this.closeGalleryMenu();\n        this.toggleGallery();\n      });\n    });\n    this.initMenus();\n\n    // dev\n    if (this.isDev) {\n      this.toggleGallery();\n    }\n  }\n\n  toggleGallery() {\n    if (!this.lock) {\n      this.lock = true;\n      this.toggleCount = this.toggleCount ? this.toggleCount + 1 : 1;\n      const content = document.querySelector('#pane-content');\n      const gallery = document.querySelector('#pane-gallery');\n      const grid = document.querySelector('#background-grid');\n      const nav = document.querySelector('.nav');\n      const logo = document.querySelector('.logo-main');\n\n      if (content.classList.contains('active')) {\n        content.classList.remove('active');\n        gallery.classList.add('active');\n        grid.classList.add('active');\n        nav.classList.add('active');\n        logo.classList.add('active');\n        document.documentElement.classList.add('freeze');\n        if (this.toggleCount == 1) {\n          setTimeout(() => {\n            this.lock = false;\n            gallery.querySelectorAll('canvas').forEach(e => {\n              e.classList.add('active');\n            });\n            this.root.activate();\n          }, this.isDev ? 125 : 1000);\n        } else {\n          this.root.activate();\n          this.lock = false;\n        }\n      } else {\n        gallery.classList.remove('active');\n        content.classList.add('active');\n        grid.classList.remove('active');\n        nav.classList.remove('active');\n        logo.classList.remove('active');\n        document.documentElement.classList.remove('freeze');\n        this.root.deactivate();\n        this.lock = false;\n      }\n    }\n  }\n\n  closeGalleryMenu() {\n    document.querySelectorAll('#nav-gallery .item.active, .gallery-menu .active').forEach(e => {\n      e.classList.remove('active');\n    });\n    document.querySelector('#nav-gallery .close-gallery-menu').classList.add('active');\n\n    // show controls\n    document.querySelector('#gallery-controls').classList.remove('display-none');\n  }\n\n  onMenuItem(el) {\n    if (el.dataset.active) {\n      const target = document.querySelector(el.dataset.active);\n      if (target) {\n        el.parentNode.querySelectorAll('.active').forEach(e => {\n          e.classList.remove('active');\n        });\n        el.classList.add('active');\n\n        // close pages or menus\n        if (el.parentNode.getAttribute('id') == 'nav-content') {\n          document.querySelectorAll('.pane-content .page.active').forEach(e => {\n            e.classList.remove('active');\n          });\n        } else {\n          document.querySelectorAll('.gallery-menu .menu.active').forEach(e => {\n            e.classList.remove('active');\n            e.querySelectorAll('.requires-activate').forEach(f => {\n              f.classList.remove('active');\n            });\n          });\n\n          // hide controls\n          document.querySelector('#gallery-controls').classList.add('display-none');\n        }\n\n        // open target\n        target.classList.add('active');\n        target.querySelectorAll('.requires-activate').forEach(e => {\n          e.classList.add('active');\n        });\n      }\n    }\n  }\n\n  initMenus() {\n    document.querySelectorAll('.pane-content-nav .item').forEach(item => {\n      item.addEventListener('click', evt => {\n        this.onMenuItem(evt.currentTarget);\n      });\n    });\n\n    document.querySelectorAll('.close-gallery-menu').forEach(item => {\n      item.addEventListener('click', evt => {\n        this.closeGalleryMenu();\n      });\n    });\n\n    // open controls menu\n    this.onMenuItem(document.querySelector('#nav-item-controls'));\n  }\n}\n\n\n\n//# sourceURL=webpack://CLM/./js/utils/menu.js?");

/***/ }),

/***/ "./js/utils/mobile_check.js":
/*!**********************************!*\
  !*** ./js/utils/mobile_check.js ***!
  \**********************************/
/*! exports provided: detectMobile, detectMobileAndTablet */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"detectMobile\", function() { return detectMobile; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"detectMobileAndTablet\", function() { return detectMobileAndTablet; });\nconst detectMobile = () => {\n  var check = false;\n  (function (a) {\n    if (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0, 4))) check = true;\n  })(navigator.userAgent || navigator.vendor || window.opera);\n  return check;\n};\n\nconst detectMobileAndTablet = () => {\n  var check = false;\n  (function (a) {\n    if (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(a.substr(0, 4))) check = true;\n  })(navigator.userAgent || navigator.vendor || window.opera);\n  return check;\n};\n\n\n\n//# sourceURL=webpack://CLM/./js/utils/mobile_check.js?");

/***/ })

/******/ });